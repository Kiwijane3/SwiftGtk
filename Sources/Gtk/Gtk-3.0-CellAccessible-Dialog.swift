import CGLib
import CCairo
import CPango
import CGdkPixbuf
import CGdk
import CAtk
import CGtk
import GLib
import GLibObject
import GIO
import Pango
import Cairo
import PangoCairo
import GdkPixbuf
import Gdk
import Atk

// MARK: - CellAccessible Class

/// The `CellAccessibleProtocol` protocol exposes the methods and properties of an underlying `GtkCellAccessible` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellAccessible`.
/// Alternatively, use `CellAccessibleRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///

public protocol CellAccessibleProtocol: AccessibleProtocol, Atk.ActionProtocol, Atk.ComponentProtocol, Atk.TableCellProtocol {
    /// Untyped pointer to the underlying `GtkCellAccessible` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkCellAccessible` instance.
    var cell_accessible_ptr: UnsafeMutablePointer<GtkCellAccessible> { get }
}

/// The `CellAccessibleRef` type acts as a lightweight Swift reference to an underlying `GtkCellAccessible` instance.
/// It exposes methods that can operate on this data type through `CellAccessibleProtocol` conformance.
/// Use `CellAccessibleRef` only as an `unowned` reference to an existing `GtkCellAccessible` instance.
///

public struct CellAccessibleRef: CellAccessibleProtocol {
    /// Untyped pointer to the underlying `GtkCellAccessible` instance.
    /// For type-safe access, use the generated, typed pointer `cell_accessible_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension CellAccessibleRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkCellAccessible>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `CellAccessibleProtocol`
    init<T: CellAccessibleProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAccessibleProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAccessibleProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAccessibleProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAccessibleProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAccessibleProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `CellAccessible` type acts as a reference-counted owner of an underlying `GtkCellAccessible` instance.
/// It provides the methods that can operate on this data type through `CellAccessibleProtocol` conformance.
/// Use `CellAccessible` as a strong reference or owner of a `GtkCellAccessible` instance.
///

open class CellAccessible: Accessible, CellAccessibleProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `CellAccessible` instance.
    public init(_ op: UnsafeMutablePointer<GtkCellAccessible>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `CellAccessibleProtocol`
    /// Will retain `GtkCellAccessible`.
    public convenience init<T: CellAccessibleProtocol>(_ other: T) {
        self.init(cast(other.cell_accessible_ptr))
        g_object_ref(cast(cell_accessible_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAccessibleProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkCellAccessible.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAccessibleProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkCellAccessible.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAccessibleProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkCellAccessible.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAccessibleProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkCellAccessible>(opaquePointer))
    }



}

public enum CellAccessiblePropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case widget = "widget"
}

public extension CellAccessibleProtocol {
    /// Bind a `CellAccessiblePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellAccessiblePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(cell_accessible_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum CellAccessibleSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyWidget = "notify::widget"
}

public extension CellAccessibleProtocol {
    /// Connect a `CellAccessibleSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: CellAccessibleSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(cell_accessible_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension CellAccessibleProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellAccessible` instance.
    var cell_accessible_ptr: UnsafeMutablePointer<GtkCellAccessible> { return ptr.assumingMemoryBound(to: GtkCellAccessible.self) }

}



// MARK: - CellArea Class

/// The `CellAreaProtocol` protocol exposes the methods and properties of an underlying `GtkCellArea` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellArea`.
/// Alternatively, use `CellAreaRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// The `GtkCellArea` is an abstract class for `GtkCellLayout` widgets
/// (also referred to as "layouting widgets") to interface with an
/// arbitrary number of `GtkCellRenderers` and interact with the user
/// for a given `GtkTreeModel` row.
/// 
/// The cell area handles events, focus navigation, drawing and
/// size requests and allocations for a given row of data.
/// 
/// Usually users dont have to interact with the `GtkCellArea` directly
/// unless they are implementing a cell-layouting widget themselves.
/// 
/// # Requesting area sizes
/// 
/// As outlined in
/// [GtkWidget’s geometry management section](#geometry-management),
/// GTK+ uses a height-for-width
/// geometry management system to compute the sizes of widgets and user
/// interfaces. `GtkCellArea` uses the same semantics to calculate the
/// size of an area for an arbitrary number of `GtkTreeModel` rows.
/// 
/// When requesting the size of a cell area one needs to calculate
/// the size for a handful of rows, and this will be done differently by
/// different layouting widgets. For instance a `GtkTreeViewColumn`
/// always lines up the areas from top to bottom while a `GtkIconView`
/// on the other hand might enforce that all areas received the same
/// width and wrap the areas around, requesting height for more cell
/// areas when allocated less width.
/// 
/// It’s also important for areas to maintain some cell
/// alignments with areas rendered for adjacent rows (cells can
/// appear “columnized” inside an area even when the size of
/// cells are different in each row). For this reason the `GtkCellArea`
/// uses a `GtkCellAreaContext` object to store the alignments
/// and sizes along the way (as well as the overall largest minimum
/// and natural size for all the rows which have been calculated
/// with the said context).
/// 
/// The `GtkCellAreaContext` is an opaque object specific to the
/// `GtkCellArea` which created it (see `gtk_cell_area_create_context()`).
/// The owning cell-layouting widget can create as many contexts as
/// it wishes to calculate sizes of rows which should receive the
/// same size in at least one orientation (horizontally or vertically),
/// However, it’s important that the same `GtkCellAreaContext` which
/// was used to request the sizes for a given `GtkTreeModel` row be
/// used when rendering or processing events for that row.
/// 
/// In order to request the width of all the rows at the root level
/// of a `GtkTreeModel` one would do the following:
/// 
/// (C Language Example):
/// ```C
/// GtkTreeIter iter;
/// gint        minimum_width;
/// gint        natural_width;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_get_preferred_width (area, context, widget, NULL, NULL);
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// gtk_cell_area_context_get_preferred_width (context, &minimum_width, &natural_width);
/// ```
/// 
/// Note that in this example it’s not important to observe the
/// returned minimum and natural width of the area for each row
/// unless the cell-layouting object is actually interested in the
/// widths of individual rows. The overall width is however stored
/// in the accompanying `GtkCellAreaContext` object and can be consulted
/// at any time.
/// 
/// This can be useful since `GtkCellLayout` widgets usually have to
/// support requesting and rendering rows in treemodels with an
/// exceedingly large amount of rows. The `GtkCellLayout` widget in
/// that case would calculate the required width of the rows in an
/// idle or timeout source (see `g_timeout_add()`) and when the widget
/// is requested its actual width in `GtkWidgetClass.get_preferred_width``()`
/// it can simply consult the width accumulated so far in the
/// `GtkCellAreaContext` object.
/// 
/// A simple example where rows are rendered from top to bottom and
/// take up the full width of the layouting widget would look like:
/// 
/// (C Language Example):
/// ```C
/// static void
/// foo_get_preferred_width (GtkWidget       *widget,
///                          gint            *minimum_size,
///                          gint            *natural_size)
/// {
///   Foo        *foo  = FOO (widget);
///   FooPrivate *priv = foo->priv;
/// 
///   foo_ensure_at_least_one_handfull_of_rows_have_been_requested (foo);
/// 
///   gtk_cell_area_context_get_preferred_width (priv->context, minimum_size, natural_size);
/// }
/// ```
/// 
/// In the above example the Foo widget has to make sure that some
/// row sizes have been calculated (the amount of rows that Foo judged
/// was appropriate to request space for in a single timeout iteration)
/// before simply returning the amount of space required by the area via
/// the `GtkCellAreaContext`.
/// 
/// Requesting the height for width (or width for height) of an area is
/// a similar task except in this case the `GtkCellAreaContext` does not
/// store the data (actually, it does not know how much space the layouting
/// widget plans to allocate it for every row. It’s up to the layouting
/// widget to render each row of data with the appropriate height and
/// width which was requested by the `GtkCellArea`).
/// 
/// In order to request the height for width of all the rows at the
/// root level of a `GtkTreeModel` one would do the following:
/// 
/// (C Language Example):
/// ```C
/// GtkTreeIter iter;
/// gint        minimum_height;
/// gint        natural_height;
/// gint        full_minimum_height = 0;
/// gint        full_natural_height = 0;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_get_preferred_height_for_width (area, context, widget,
///                                                   width, &minimum_height, &natural_height);
/// 
///     if (width_is_for_allocation)
///        cache_row_height (&iter, minimum_height, natural_height);
/// 
///     full_minimum_height += minimum_height;
///     full_natural_height += natural_height;
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// ```
/// 
/// Note that in the above example we would need to cache the heights
/// returned for each row so that we would know what sizes to render the
/// areas for each row. However we would only want to really cache the
/// heights if the request is intended for the layouting widgets real
/// allocation.
/// 
/// In some cases the layouting widget is requested the height for an
/// arbitrary for_width, this is a special case for layouting widgets
/// who need to request size for tens of thousands  of rows. For this
/// case it’s only important that the layouting widget calculate
/// one reasonably sized chunk of rows and return that height
/// synchronously. The reasoning here is that any layouting widget is
/// at least capable of synchronously calculating enough height to fill
/// the screen height (or scrolled window height) in response to a single
/// call to `GtkWidgetClass.get_preferred_height_for_width``()`. Returning
/// a perfect height for width that is larger than the screen area is
/// inconsequential since after the layouting receives an allocation
/// from a scrolled window it simply continues to drive the scrollbar
/// values while more and more height is required for the row heights
/// that are calculated in the background.
/// 
/// # Rendering Areas
/// 
/// Once area sizes have been aquired at least for the rows in the
/// visible area of the layouting widget they can be rendered at
/// `GtkWidgetClass.draw``()` time.
/// 
/// A crude example of how to render all the rows at the root level
/// runs as follows:
/// 
/// (C Language Example):
/// ```C
/// GtkAllocation allocation;
/// GdkRectangle  cell_area = { 0, };
/// GtkTreeIter   iter;
/// gint          minimum_width;
/// gint          natural_width;
/// 
/// gtk_widget_get_allocation (widget, &allocation);
/// cell_area.width = allocation.width;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     cell_area.height = get_cached_height_for_row (&iter);
/// 
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_render (area, context, widget, cr,
///                           &cell_area, &cell_area, state_flags, FALSE);
/// 
///     cell_area.y += cell_area.height;
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// ```
/// 
/// Note that the cached height in this example really depends on how
/// the layouting widget works. The layouting widget might decide to
/// give every row its minimum or natural height or, if the model content
/// is expected to fit inside the layouting widget without scrolling, it
/// would make sense to calculate the allocation for each row at
/// `GtkWidget::size`-allocate time using `gtk_distribute_natural_allocation()`.
/// 
/// # Handling Events and Driving Keyboard Focus
/// 
/// Passing events to the area is as simple as handling events on any
/// normal widget and then passing them to the `gtk_cell_area_event()`
/// API as they come in. Usually `GtkCellArea` is only interested in
/// button events, however some customized derived areas can be implemented
/// who are interested in handling other events. Handling an event can
/// trigger the `GtkCellArea::focus`-changed signal to fire; as well as
/// `GtkCellArea::add`-editable in the case that an editable cell was
/// clicked and needs to start editing. You can call
/// `gtk_cell_area_stop_editing()` at any time to cancel any cell editing
/// that is currently in progress.
/// 
/// The `GtkCellArea` drives keyboard focus from cell to cell in a way
/// similar to `GtkWidget`. For layouting widgets that support giving
/// focus to cells it’s important to remember to pass `GTK_CELL_RENDERER_FOCUSED`
/// to the area functions for the row that has focus and to tell the
/// area to paint the focus at render time.
/// 
/// Layouting widgets that accept focus on cells should implement the
/// `GtkWidgetClass.focus``()` virtual method. The layouting widget is always
/// responsible for knowing where `GtkTreeModel` rows are rendered inside
/// the widget, so at `GtkWidgetClass.focus``()` time the layouting widget
/// should use the `GtkCellArea` methods to navigate focus inside the area
/// and then observe the GtkDirectionType to pass the focus to adjacent
/// rows and areas.
/// 
/// A basic example of how the `GtkWidgetClass.focus``()` virtual method
/// should be implemented:
/// 
/// (C Language Example):
/// ```C
/// static gboolean
/// foo_focus (GtkWidget       *widget,
///            GtkDirectionType direction)
/// {
///   Foo        *foo  = FOO (widget);
///   FooPrivate *priv = foo->priv;
///   gint        focus_row;
///   gboolean    have_focus = FALSE;
/// 
///   focus_row = priv->focus_row;
/// 
///   if (!gtk_widget_has_focus (widget))
///     gtk_widget_grab_focus (widget);
/// 
///   valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, priv->focus_row);
///   while (valid)
///     {
///       gtk_cell_area_apply_attributes (priv->area, priv->model, &iter, FALSE, FALSE);
/// 
///       if (gtk_cell_area_focus (priv->area, direction))
///         {
///            priv->focus_row = focus_row;
///            have_focus = TRUE;
///            break;
///         }
///       else
///         {
///           if (direction == GTK_DIR_RIGHT ||
///               direction == GTK_DIR_LEFT)
///             break;
///           else if (direction == GTK_DIR_UP ||
///                    direction == GTK_DIR_TAB_BACKWARD)
///            {
///               if (focus_row == 0)
///                 break;
///               else
///                {
///                   focus_row--;
///                   valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, focus_row);
///                }
///             }
///           else
///             {
///               if (focus_row == last_row)
///                 break;
///               else
///                 {
///                   focus_row++;
///                   valid = gtk_tree_model_iter_next (priv->model, &iter);
///                 }
///             }
///         }
///     }
///     return have_focus;
/// }
/// ```
/// 
/// Note that the layouting widget is responsible for matching the
/// GtkDirectionType values to the way it lays out its cells.
/// 
/// # Cell Properties
/// 
/// The `GtkCellArea` introduces cell properties for `GtkCellRenderers`
/// in very much the same way that `GtkContainer` introduces
/// [child properties](#child-properties)
/// for `GtkWidgets`. This provides some general interfaces for defining
/// the relationship cell areas have with their cells. For instance in a
/// `GtkCellAreaBox` a cell might “expand” and receive extra space when
/// the area is allocated more than its full natural request, or a cell
/// might be configured to “align” with adjacent rows which were requested
/// and rendered with the same `GtkCellAreaContext`.
/// 
/// Use `gtk_cell_area_class_install_cell_property()` to install cell
/// properties for a cell area class and `gtk_cell_area_class_find_cell_property()`
/// or `gtk_cell_area_class_list_cell_properties()` to get information about
/// existing cell properties.
/// 
/// To set the value of a cell property, use `gtk_cell_area_cell_set_property()`,
/// `gtk_cell_area_cell_set()` or `gtk_cell_area_cell_set_valist()`. To obtain
/// the value of a cell property, use `gtk_cell_area_cell_get_property()`,
/// `gtk_cell_area_cell_get()` or `gtk_cell_area_cell_get_valist()`.
public protocol CellAreaProtocol: InitiallyUnownedProtocol, BuildableProtocol, CellLayoutProtocol {
    /// Untyped pointer to the underlying `GtkCellArea` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkCellArea` instance.
    var cell_area_ptr: UnsafeMutablePointer<GtkCellArea> { get }
}

/// The `CellAreaRef` type acts as a lightweight Swift reference to an underlying `GtkCellArea` instance.
/// It exposes methods that can operate on this data type through `CellAreaProtocol` conformance.
/// Use `CellAreaRef` only as an `unowned` reference to an existing `GtkCellArea` instance.
///
/// The `GtkCellArea` is an abstract class for `GtkCellLayout` widgets
/// (also referred to as "layouting widgets") to interface with an
/// arbitrary number of `GtkCellRenderers` and interact with the user
/// for a given `GtkTreeModel` row.
/// 
/// The cell area handles events, focus navigation, drawing and
/// size requests and allocations for a given row of data.
/// 
/// Usually users dont have to interact with the `GtkCellArea` directly
/// unless they are implementing a cell-layouting widget themselves.
/// 
/// # Requesting area sizes
/// 
/// As outlined in
/// [GtkWidget’s geometry management section](#geometry-management),
/// GTK+ uses a height-for-width
/// geometry management system to compute the sizes of widgets and user
/// interfaces. `GtkCellArea` uses the same semantics to calculate the
/// size of an area for an arbitrary number of `GtkTreeModel` rows.
/// 
/// When requesting the size of a cell area one needs to calculate
/// the size for a handful of rows, and this will be done differently by
/// different layouting widgets. For instance a `GtkTreeViewColumn`
/// always lines up the areas from top to bottom while a `GtkIconView`
/// on the other hand might enforce that all areas received the same
/// width and wrap the areas around, requesting height for more cell
/// areas when allocated less width.
/// 
/// It’s also important for areas to maintain some cell
/// alignments with areas rendered for adjacent rows (cells can
/// appear “columnized” inside an area even when the size of
/// cells are different in each row). For this reason the `GtkCellArea`
/// uses a `GtkCellAreaContext` object to store the alignments
/// and sizes along the way (as well as the overall largest minimum
/// and natural size for all the rows which have been calculated
/// with the said context).
/// 
/// The `GtkCellAreaContext` is an opaque object specific to the
/// `GtkCellArea` which created it (see `gtk_cell_area_create_context()`).
/// The owning cell-layouting widget can create as many contexts as
/// it wishes to calculate sizes of rows which should receive the
/// same size in at least one orientation (horizontally or vertically),
/// However, it’s important that the same `GtkCellAreaContext` which
/// was used to request the sizes for a given `GtkTreeModel` row be
/// used when rendering or processing events for that row.
/// 
/// In order to request the width of all the rows at the root level
/// of a `GtkTreeModel` one would do the following:
/// 
/// (C Language Example):
/// ```C
/// GtkTreeIter iter;
/// gint        minimum_width;
/// gint        natural_width;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_get_preferred_width (area, context, widget, NULL, NULL);
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// gtk_cell_area_context_get_preferred_width (context, &minimum_width, &natural_width);
/// ```
/// 
/// Note that in this example it’s not important to observe the
/// returned minimum and natural width of the area for each row
/// unless the cell-layouting object is actually interested in the
/// widths of individual rows. The overall width is however stored
/// in the accompanying `GtkCellAreaContext` object and can be consulted
/// at any time.
/// 
/// This can be useful since `GtkCellLayout` widgets usually have to
/// support requesting and rendering rows in treemodels with an
/// exceedingly large amount of rows. The `GtkCellLayout` widget in
/// that case would calculate the required width of the rows in an
/// idle or timeout source (see `g_timeout_add()`) and when the widget
/// is requested its actual width in `GtkWidgetClass.get_preferred_width``()`
/// it can simply consult the width accumulated so far in the
/// `GtkCellAreaContext` object.
/// 
/// A simple example where rows are rendered from top to bottom and
/// take up the full width of the layouting widget would look like:
/// 
/// (C Language Example):
/// ```C
/// static void
/// foo_get_preferred_width (GtkWidget       *widget,
///                          gint            *minimum_size,
///                          gint            *natural_size)
/// {
///   Foo        *foo  = FOO (widget);
///   FooPrivate *priv = foo->priv;
/// 
///   foo_ensure_at_least_one_handfull_of_rows_have_been_requested (foo);
/// 
///   gtk_cell_area_context_get_preferred_width (priv->context, minimum_size, natural_size);
/// }
/// ```
/// 
/// In the above example the Foo widget has to make sure that some
/// row sizes have been calculated (the amount of rows that Foo judged
/// was appropriate to request space for in a single timeout iteration)
/// before simply returning the amount of space required by the area via
/// the `GtkCellAreaContext`.
/// 
/// Requesting the height for width (or width for height) of an area is
/// a similar task except in this case the `GtkCellAreaContext` does not
/// store the data (actually, it does not know how much space the layouting
/// widget plans to allocate it for every row. It’s up to the layouting
/// widget to render each row of data with the appropriate height and
/// width which was requested by the `GtkCellArea`).
/// 
/// In order to request the height for width of all the rows at the
/// root level of a `GtkTreeModel` one would do the following:
/// 
/// (C Language Example):
/// ```C
/// GtkTreeIter iter;
/// gint        minimum_height;
/// gint        natural_height;
/// gint        full_minimum_height = 0;
/// gint        full_natural_height = 0;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_get_preferred_height_for_width (area, context, widget,
///                                                   width, &minimum_height, &natural_height);
/// 
///     if (width_is_for_allocation)
///        cache_row_height (&iter, minimum_height, natural_height);
/// 
///     full_minimum_height += minimum_height;
///     full_natural_height += natural_height;
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// ```
/// 
/// Note that in the above example we would need to cache the heights
/// returned for each row so that we would know what sizes to render the
/// areas for each row. However we would only want to really cache the
/// heights if the request is intended for the layouting widgets real
/// allocation.
/// 
/// In some cases the layouting widget is requested the height for an
/// arbitrary for_width, this is a special case for layouting widgets
/// who need to request size for tens of thousands  of rows. For this
/// case it’s only important that the layouting widget calculate
/// one reasonably sized chunk of rows and return that height
/// synchronously. The reasoning here is that any layouting widget is
/// at least capable of synchronously calculating enough height to fill
/// the screen height (or scrolled window height) in response to a single
/// call to `GtkWidgetClass.get_preferred_height_for_width``()`. Returning
/// a perfect height for width that is larger than the screen area is
/// inconsequential since after the layouting receives an allocation
/// from a scrolled window it simply continues to drive the scrollbar
/// values while more and more height is required for the row heights
/// that are calculated in the background.
/// 
/// # Rendering Areas
/// 
/// Once area sizes have been aquired at least for the rows in the
/// visible area of the layouting widget they can be rendered at
/// `GtkWidgetClass.draw``()` time.
/// 
/// A crude example of how to render all the rows at the root level
/// runs as follows:
/// 
/// (C Language Example):
/// ```C
/// GtkAllocation allocation;
/// GdkRectangle  cell_area = { 0, };
/// GtkTreeIter   iter;
/// gint          minimum_width;
/// gint          natural_width;
/// 
/// gtk_widget_get_allocation (widget, &allocation);
/// cell_area.width = allocation.width;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     cell_area.height = get_cached_height_for_row (&iter);
/// 
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_render (area, context, widget, cr,
///                           &cell_area, &cell_area, state_flags, FALSE);
/// 
///     cell_area.y += cell_area.height;
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// ```
/// 
/// Note that the cached height in this example really depends on how
/// the layouting widget works. The layouting widget might decide to
/// give every row its minimum or natural height or, if the model content
/// is expected to fit inside the layouting widget without scrolling, it
/// would make sense to calculate the allocation for each row at
/// `GtkWidget::size`-allocate time using `gtk_distribute_natural_allocation()`.
/// 
/// # Handling Events and Driving Keyboard Focus
/// 
/// Passing events to the area is as simple as handling events on any
/// normal widget and then passing them to the `gtk_cell_area_event()`
/// API as they come in. Usually `GtkCellArea` is only interested in
/// button events, however some customized derived areas can be implemented
/// who are interested in handling other events. Handling an event can
/// trigger the `GtkCellArea::focus`-changed signal to fire; as well as
/// `GtkCellArea::add`-editable in the case that an editable cell was
/// clicked and needs to start editing. You can call
/// `gtk_cell_area_stop_editing()` at any time to cancel any cell editing
/// that is currently in progress.
/// 
/// The `GtkCellArea` drives keyboard focus from cell to cell in a way
/// similar to `GtkWidget`. For layouting widgets that support giving
/// focus to cells it’s important to remember to pass `GTK_CELL_RENDERER_FOCUSED`
/// to the area functions for the row that has focus and to tell the
/// area to paint the focus at render time.
/// 
/// Layouting widgets that accept focus on cells should implement the
/// `GtkWidgetClass.focus``()` virtual method. The layouting widget is always
/// responsible for knowing where `GtkTreeModel` rows are rendered inside
/// the widget, so at `GtkWidgetClass.focus``()` time the layouting widget
/// should use the `GtkCellArea` methods to navigate focus inside the area
/// and then observe the GtkDirectionType to pass the focus to adjacent
/// rows and areas.
/// 
/// A basic example of how the `GtkWidgetClass.focus``()` virtual method
/// should be implemented:
/// 
/// (C Language Example):
/// ```C
/// static gboolean
/// foo_focus (GtkWidget       *widget,
///            GtkDirectionType direction)
/// {
///   Foo        *foo  = FOO (widget);
///   FooPrivate *priv = foo->priv;
///   gint        focus_row;
///   gboolean    have_focus = FALSE;
/// 
///   focus_row = priv->focus_row;
/// 
///   if (!gtk_widget_has_focus (widget))
///     gtk_widget_grab_focus (widget);
/// 
///   valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, priv->focus_row);
///   while (valid)
///     {
///       gtk_cell_area_apply_attributes (priv->area, priv->model, &iter, FALSE, FALSE);
/// 
///       if (gtk_cell_area_focus (priv->area, direction))
///         {
///            priv->focus_row = focus_row;
///            have_focus = TRUE;
///            break;
///         }
///       else
///         {
///           if (direction == GTK_DIR_RIGHT ||
///               direction == GTK_DIR_LEFT)
///             break;
///           else if (direction == GTK_DIR_UP ||
///                    direction == GTK_DIR_TAB_BACKWARD)
///            {
///               if (focus_row == 0)
///                 break;
///               else
///                {
///                   focus_row--;
///                   valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, focus_row);
///                }
///             }
///           else
///             {
///               if (focus_row == last_row)
///                 break;
///               else
///                 {
///                   focus_row++;
///                   valid = gtk_tree_model_iter_next (priv->model, &iter);
///                 }
///             }
///         }
///     }
///     return have_focus;
/// }
/// ```
/// 
/// Note that the layouting widget is responsible for matching the
/// GtkDirectionType values to the way it lays out its cells.
/// 
/// # Cell Properties
/// 
/// The `GtkCellArea` introduces cell properties for `GtkCellRenderers`
/// in very much the same way that `GtkContainer` introduces
/// [child properties](#child-properties)
/// for `GtkWidgets`. This provides some general interfaces for defining
/// the relationship cell areas have with their cells. For instance in a
/// `GtkCellAreaBox` a cell might “expand” and receive extra space when
/// the area is allocated more than its full natural request, or a cell
/// might be configured to “align” with adjacent rows which were requested
/// and rendered with the same `GtkCellAreaContext`.
/// 
/// Use `gtk_cell_area_class_install_cell_property()` to install cell
/// properties for a cell area class and `gtk_cell_area_class_find_cell_property()`
/// or `gtk_cell_area_class_list_cell_properties()` to get information about
/// existing cell properties.
/// 
/// To set the value of a cell property, use `gtk_cell_area_cell_set_property()`,
/// `gtk_cell_area_cell_set()` or `gtk_cell_area_cell_set_valist()`. To obtain
/// the value of a cell property, use `gtk_cell_area_cell_get_property()`,
/// `gtk_cell_area_cell_get()` or `gtk_cell_area_cell_get_valist()`.
public struct CellAreaRef: CellAreaProtocol {
    /// Untyped pointer to the underlying `GtkCellArea` instance.
    /// For type-safe access, use the generated, typed pointer `cell_area_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension CellAreaRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkCellArea>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `CellAreaProtocol`
    init<T: CellAreaProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `CellArea` type acts as a reference-counted owner of an underlying `GtkCellArea` instance.
/// It provides the methods that can operate on this data type through `CellAreaProtocol` conformance.
/// Use `CellArea` as a strong reference or owner of a `GtkCellArea` instance.
///
/// The `GtkCellArea` is an abstract class for `GtkCellLayout` widgets
/// (also referred to as "layouting widgets") to interface with an
/// arbitrary number of `GtkCellRenderers` and interact with the user
/// for a given `GtkTreeModel` row.
/// 
/// The cell area handles events, focus navigation, drawing and
/// size requests and allocations for a given row of data.
/// 
/// Usually users dont have to interact with the `GtkCellArea` directly
/// unless they are implementing a cell-layouting widget themselves.
/// 
/// # Requesting area sizes
/// 
/// As outlined in
/// [GtkWidget’s geometry management section](#geometry-management),
/// GTK+ uses a height-for-width
/// geometry management system to compute the sizes of widgets and user
/// interfaces. `GtkCellArea` uses the same semantics to calculate the
/// size of an area for an arbitrary number of `GtkTreeModel` rows.
/// 
/// When requesting the size of a cell area one needs to calculate
/// the size for a handful of rows, and this will be done differently by
/// different layouting widgets. For instance a `GtkTreeViewColumn`
/// always lines up the areas from top to bottom while a `GtkIconView`
/// on the other hand might enforce that all areas received the same
/// width and wrap the areas around, requesting height for more cell
/// areas when allocated less width.
/// 
/// It’s also important for areas to maintain some cell
/// alignments with areas rendered for adjacent rows (cells can
/// appear “columnized” inside an area even when the size of
/// cells are different in each row). For this reason the `GtkCellArea`
/// uses a `GtkCellAreaContext` object to store the alignments
/// and sizes along the way (as well as the overall largest minimum
/// and natural size for all the rows which have been calculated
/// with the said context).
/// 
/// The `GtkCellAreaContext` is an opaque object specific to the
/// `GtkCellArea` which created it (see `gtk_cell_area_create_context()`).
/// The owning cell-layouting widget can create as many contexts as
/// it wishes to calculate sizes of rows which should receive the
/// same size in at least one orientation (horizontally or vertically),
/// However, it’s important that the same `GtkCellAreaContext` which
/// was used to request the sizes for a given `GtkTreeModel` row be
/// used when rendering or processing events for that row.
/// 
/// In order to request the width of all the rows at the root level
/// of a `GtkTreeModel` one would do the following:
/// 
/// (C Language Example):
/// ```C
/// GtkTreeIter iter;
/// gint        minimum_width;
/// gint        natural_width;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_get_preferred_width (area, context, widget, NULL, NULL);
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// gtk_cell_area_context_get_preferred_width (context, &minimum_width, &natural_width);
/// ```
/// 
/// Note that in this example it’s not important to observe the
/// returned minimum and natural width of the area for each row
/// unless the cell-layouting object is actually interested in the
/// widths of individual rows. The overall width is however stored
/// in the accompanying `GtkCellAreaContext` object and can be consulted
/// at any time.
/// 
/// This can be useful since `GtkCellLayout` widgets usually have to
/// support requesting and rendering rows in treemodels with an
/// exceedingly large amount of rows. The `GtkCellLayout` widget in
/// that case would calculate the required width of the rows in an
/// idle or timeout source (see `g_timeout_add()`) and when the widget
/// is requested its actual width in `GtkWidgetClass.get_preferred_width``()`
/// it can simply consult the width accumulated so far in the
/// `GtkCellAreaContext` object.
/// 
/// A simple example where rows are rendered from top to bottom and
/// take up the full width of the layouting widget would look like:
/// 
/// (C Language Example):
/// ```C
/// static void
/// foo_get_preferred_width (GtkWidget       *widget,
///                          gint            *minimum_size,
///                          gint            *natural_size)
/// {
///   Foo        *foo  = FOO (widget);
///   FooPrivate *priv = foo->priv;
/// 
///   foo_ensure_at_least_one_handfull_of_rows_have_been_requested (foo);
/// 
///   gtk_cell_area_context_get_preferred_width (priv->context, minimum_size, natural_size);
/// }
/// ```
/// 
/// In the above example the Foo widget has to make sure that some
/// row sizes have been calculated (the amount of rows that Foo judged
/// was appropriate to request space for in a single timeout iteration)
/// before simply returning the amount of space required by the area via
/// the `GtkCellAreaContext`.
/// 
/// Requesting the height for width (or width for height) of an area is
/// a similar task except in this case the `GtkCellAreaContext` does not
/// store the data (actually, it does not know how much space the layouting
/// widget plans to allocate it for every row. It’s up to the layouting
/// widget to render each row of data with the appropriate height and
/// width which was requested by the `GtkCellArea`).
/// 
/// In order to request the height for width of all the rows at the
/// root level of a `GtkTreeModel` one would do the following:
/// 
/// (C Language Example):
/// ```C
/// GtkTreeIter iter;
/// gint        minimum_height;
/// gint        natural_height;
/// gint        full_minimum_height = 0;
/// gint        full_natural_height = 0;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_get_preferred_height_for_width (area, context, widget,
///                                                   width, &minimum_height, &natural_height);
/// 
///     if (width_is_for_allocation)
///        cache_row_height (&iter, minimum_height, natural_height);
/// 
///     full_minimum_height += minimum_height;
///     full_natural_height += natural_height;
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// ```
/// 
/// Note that in the above example we would need to cache the heights
/// returned for each row so that we would know what sizes to render the
/// areas for each row. However we would only want to really cache the
/// heights if the request is intended for the layouting widgets real
/// allocation.
/// 
/// In some cases the layouting widget is requested the height for an
/// arbitrary for_width, this is a special case for layouting widgets
/// who need to request size for tens of thousands  of rows. For this
/// case it’s only important that the layouting widget calculate
/// one reasonably sized chunk of rows and return that height
/// synchronously. The reasoning here is that any layouting widget is
/// at least capable of synchronously calculating enough height to fill
/// the screen height (or scrolled window height) in response to a single
/// call to `GtkWidgetClass.get_preferred_height_for_width``()`. Returning
/// a perfect height for width that is larger than the screen area is
/// inconsequential since after the layouting receives an allocation
/// from a scrolled window it simply continues to drive the scrollbar
/// values while more and more height is required for the row heights
/// that are calculated in the background.
/// 
/// # Rendering Areas
/// 
/// Once area sizes have been aquired at least for the rows in the
/// visible area of the layouting widget they can be rendered at
/// `GtkWidgetClass.draw``()` time.
/// 
/// A crude example of how to render all the rows at the root level
/// runs as follows:
/// 
/// (C Language Example):
/// ```C
/// GtkAllocation allocation;
/// GdkRectangle  cell_area = { 0, };
/// GtkTreeIter   iter;
/// gint          minimum_width;
/// gint          natural_width;
/// 
/// gtk_widget_get_allocation (widget, &allocation);
/// cell_area.width = allocation.width;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     cell_area.height = get_cached_height_for_row (&iter);
/// 
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_render (area, context, widget, cr,
///                           &cell_area, &cell_area, state_flags, FALSE);
/// 
///     cell_area.y += cell_area.height;
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// ```
/// 
/// Note that the cached height in this example really depends on how
/// the layouting widget works. The layouting widget might decide to
/// give every row its minimum or natural height or, if the model content
/// is expected to fit inside the layouting widget without scrolling, it
/// would make sense to calculate the allocation for each row at
/// `GtkWidget::size`-allocate time using `gtk_distribute_natural_allocation()`.
/// 
/// # Handling Events and Driving Keyboard Focus
/// 
/// Passing events to the area is as simple as handling events on any
/// normal widget and then passing them to the `gtk_cell_area_event()`
/// API as they come in. Usually `GtkCellArea` is only interested in
/// button events, however some customized derived areas can be implemented
/// who are interested in handling other events. Handling an event can
/// trigger the `GtkCellArea::focus`-changed signal to fire; as well as
/// `GtkCellArea::add`-editable in the case that an editable cell was
/// clicked and needs to start editing. You can call
/// `gtk_cell_area_stop_editing()` at any time to cancel any cell editing
/// that is currently in progress.
/// 
/// The `GtkCellArea` drives keyboard focus from cell to cell in a way
/// similar to `GtkWidget`. For layouting widgets that support giving
/// focus to cells it’s important to remember to pass `GTK_CELL_RENDERER_FOCUSED`
/// to the area functions for the row that has focus and to tell the
/// area to paint the focus at render time.
/// 
/// Layouting widgets that accept focus on cells should implement the
/// `GtkWidgetClass.focus``()` virtual method. The layouting widget is always
/// responsible for knowing where `GtkTreeModel` rows are rendered inside
/// the widget, so at `GtkWidgetClass.focus``()` time the layouting widget
/// should use the `GtkCellArea` methods to navigate focus inside the area
/// and then observe the GtkDirectionType to pass the focus to adjacent
/// rows and areas.
/// 
/// A basic example of how the `GtkWidgetClass.focus``()` virtual method
/// should be implemented:
/// 
/// (C Language Example):
/// ```C
/// static gboolean
/// foo_focus (GtkWidget       *widget,
///            GtkDirectionType direction)
/// {
///   Foo        *foo  = FOO (widget);
///   FooPrivate *priv = foo->priv;
///   gint        focus_row;
///   gboolean    have_focus = FALSE;
/// 
///   focus_row = priv->focus_row;
/// 
///   if (!gtk_widget_has_focus (widget))
///     gtk_widget_grab_focus (widget);
/// 
///   valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, priv->focus_row);
///   while (valid)
///     {
///       gtk_cell_area_apply_attributes (priv->area, priv->model, &iter, FALSE, FALSE);
/// 
///       if (gtk_cell_area_focus (priv->area, direction))
///         {
///            priv->focus_row = focus_row;
///            have_focus = TRUE;
///            break;
///         }
///       else
///         {
///           if (direction == GTK_DIR_RIGHT ||
///               direction == GTK_DIR_LEFT)
///             break;
///           else if (direction == GTK_DIR_UP ||
///                    direction == GTK_DIR_TAB_BACKWARD)
///            {
///               if (focus_row == 0)
///                 break;
///               else
///                {
///                   focus_row--;
///                   valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, focus_row);
///                }
///             }
///           else
///             {
///               if (focus_row == last_row)
///                 break;
///               else
///                 {
///                   focus_row++;
///                   valid = gtk_tree_model_iter_next (priv->model, &iter);
///                 }
///             }
///         }
///     }
///     return have_focus;
/// }
/// ```
/// 
/// Note that the layouting widget is responsible for matching the
/// GtkDirectionType values to the way it lays out its cells.
/// 
/// # Cell Properties
/// 
/// The `GtkCellArea` introduces cell properties for `GtkCellRenderers`
/// in very much the same way that `GtkContainer` introduces
/// [child properties](#child-properties)
/// for `GtkWidgets`. This provides some general interfaces for defining
/// the relationship cell areas have with their cells. For instance in a
/// `GtkCellAreaBox` a cell might “expand” and receive extra space when
/// the area is allocated more than its full natural request, or a cell
/// might be configured to “align” with adjacent rows which were requested
/// and rendered with the same `GtkCellAreaContext`.
/// 
/// Use `gtk_cell_area_class_install_cell_property()` to install cell
/// properties for a cell area class and `gtk_cell_area_class_find_cell_property()`
/// or `gtk_cell_area_class_list_cell_properties()` to get information about
/// existing cell properties.
/// 
/// To set the value of a cell property, use `gtk_cell_area_cell_set_property()`,
/// `gtk_cell_area_cell_set()` or `gtk_cell_area_cell_set_valist()`. To obtain
/// the value of a cell property, use `gtk_cell_area_cell_get_property()`,
/// `gtk_cell_area_cell_get()` or `gtk_cell_area_cell_get_valist()`.
open class CellArea: InitiallyUnowned, CellAreaProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `CellArea` instance.
    public init(_ op: UnsafeMutablePointer<GtkCellArea>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `CellAreaProtocol`
    /// Will retain `GtkCellArea`.
    public convenience init<T: CellAreaProtocol>(_ other: T) {
        self.init(cast(other.cell_area_ptr))
        g_object_ref(cast(cell_area_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkCellArea.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkCellArea.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkCellArea.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkCellArea>(opaquePointer))
    }



}

public enum CellAreaPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    /// The widget currently editing the edited cell
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case editWidget = "edit-widget"
    /// The cell in the area that is currently edited
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case editedCell = "edited-cell"
    /// The cell in the area that currently has focus
    case focusCell = "focus-cell"
}

public extension CellAreaProtocol {
    /// Bind a `CellAreaPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellAreaPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(cell_area_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum CellAreaSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// Indicates that editing has started on `renderer` and that `editable`
    /// should be added to the owning cell-layouting widget at `cell_area`.
    case addEditable = "add-editable"
    /// This signal is emitted whenever applying attributes to `area` from `model`
    case applyAttributes = "apply-attributes"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// Indicates that focus changed on this `area`. This signal
    /// is emitted either as a result of focus handling or event
    /// handling.
    /// 
    /// It's possible that the signal is emitted even if the
    /// currently focused renderer did not change, this is
    /// because focus may change to the same renderer in the
    /// same cell area for a different row of data.
    case focusChanged = "focus-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// Indicates that editing finished on `renderer` and that `editable`
    /// should be removed from the owning cell-layouting widget.
    case removeEditable = "remove-editable"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    /// The widget currently editing the edited cell
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case notifyEditWidget = "notify::edit-widget"
    /// The cell in the area that is currently edited
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case notifyEditedCell = "notify::edited-cell"
    /// The cell in the area that currently has focus
    case notifyFocusCell = "notify::focus-cell"
}

public extension CellAreaProtocol {
    /// Connect a `CellAreaSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: CellAreaSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(cell_area_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension CellAreaProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellArea` instance.
    var cell_area_ptr: UnsafeMutablePointer<GtkCellArea> { return ptr.assumingMemoryBound(to: GtkCellArea.self) }

    /// Activates `area`, usually by activating the currently focused
    /// cell, however some subclasses which embed widgets in the area
    /// can also activate a widget if it currently has the focus.
    func activate(context: CellAreaContextProtocol, widget: WidgetProtocol, cellArea cell_area: Gdk.RectangleProtocol, flags: CellRendererState, editOnly edit_only: Bool) -> Bool {
        let rv = gtk_cell_area_activate(cast(cell_area_ptr), cast(context.ptr), cast(widget.ptr), cast(cell_area.ptr), flags, gboolean(edit_only ? 1 : 0))
        return Bool(rv != 0)
    }

    /// This is used by `GtkCellArea` subclasses when handling events
    /// to activate cells, the base `GtkCellArea` class activates cells
    /// for keyboard events for free in its own `GtkCellArea->activate()`
    /// implementation.
    func activateCell(widget: WidgetProtocol, renderer: CellRendererProtocol, event: UnsafeMutablePointer<GdkEvent>, cellArea cell_area: Gdk.RectangleProtocol, flags: CellRendererState) -> Bool {
        let rv = gtk_cell_area_activate_cell(cast(cell_area_ptr), cast(widget.ptr), cast(renderer.ptr), cast(event), cast(cell_area.ptr), flags)
        return Bool(rv != 0)
    }

    /// Adds `renderer` to `area` with the default child cell properties.
    func add(renderer: CellRendererProtocol) {
        gtk_cell_area_add(cast(cell_area_ptr), cast(renderer.ptr))
    
    }

    /// Adds `sibling` to `renderer`’s focusable area, focus will be drawn
    /// around `renderer` and all of its siblings if `renderer` can
    /// focus for a given row.
    /// 
    /// Events handled by focus siblings can also activate the given
    /// focusable `renderer`.
    func addFocusSibling(renderer: CellRendererProtocol, sibling: CellRendererProtocol) {
        gtk_cell_area_add_focus_sibling(cast(cell_area_ptr), cast(renderer.ptr), cast(sibling.ptr))
    
    }


    // *** addWithProperties() is not available because it has a varargs (...) parameter!


    /// Applies any connected attributes to the renderers in
    /// `area` by pulling the values from `tree_model`.
    func applyAttributes(treeModel tree_model: TreeModelProtocol, iter: TreeIterProtocol, isExpander is_expander: Bool, isExpanded is_expanded: Bool) {
        gtk_cell_area_apply_attributes(cast(cell_area_ptr), cast(tree_model.ptr), cast(iter.ptr), gboolean(is_expander ? 1 : 0), gboolean(is_expanded ? 1 : 0))
    
    }

    /// Connects an `attribute` to apply values from `column` for the
    /// `GtkTreeModel` in use.
    func attributeConnect(renderer: CellRendererProtocol, attribute: UnsafePointer<gchar>, column: CInt) {
        gtk_cell_area_attribute_connect(cast(cell_area_ptr), cast(renderer.ptr), attribute, gint(column))
    
    }

    /// Disconnects `attribute` for the `renderer` in `area` so that
    /// attribute will no longer be updated with values from the
    /// model.
    func attributeDisconnect(renderer: CellRendererProtocol, attribute: UnsafePointer<gchar>) {
        gtk_cell_area_attribute_disconnect(cast(cell_area_ptr), cast(renderer.ptr), attribute)
    
    }

    /// Returns the model column that an attribute has been mapped to,
    /// or -1 if the attribute is not mapped.
    func attributeGetColumn(renderer: CellRendererProtocol, attribute: UnsafePointer<gchar>) -> CInt {
        let rv = gtk_cell_area_attribute_get_column(cast(cell_area_ptr), cast(renderer.ptr), attribute)
        return CInt(rv)
    }


    // *** cellGet() is not available because it has a varargs (...) parameter!


    /// Gets the value of a cell property for `renderer` in `area`.
    func cellGetProperty(renderer: CellRendererProtocol, propertyName property_name: UnsafePointer<gchar>, value: GLibObject.ValueProtocol) {
        gtk_cell_area_cell_get_property(cast(cell_area_ptr), cast(renderer.ptr), property_name, cast(value.ptr))
    
    }

    /// Gets the values of one or more cell properties for `renderer` in `area`.
    func cellGetValist(renderer: CellRendererProtocol, firstPropertyName first_property_name: UnsafePointer<gchar>, varArgs var_args: CVaListPointer) {
        gtk_cell_area_cell_get_valist(cast(cell_area_ptr), cast(renderer.ptr), first_property_name, var_args)
    
    }


    // *** cellSet() is not available because it has a varargs (...) parameter!


    /// Sets a cell property for `renderer` in `area`.
    func cellSetProperty(renderer: CellRendererProtocol, propertyName property_name: UnsafePointer<gchar>, value: GLibObject.ValueProtocol) {
        gtk_cell_area_cell_set_property(cast(cell_area_ptr), cast(renderer.ptr), property_name, cast(value.ptr))
    
    }

    /// Sets one or more cell properties for `renderer` in `area`.
    func cellSetValist(renderer: CellRendererProtocol, firstPropertyName first_property_name: UnsafePointer<gchar>, varArgs var_args: CVaListPointer) {
        gtk_cell_area_cell_set_valist(cast(cell_area_ptr), cast(renderer.ptr), first_property_name, var_args)
    
    }

    /// This is sometimes needed for cases where rows need to share
    /// alignments in one orientation but may be separately grouped
    /// in the opposing orientation.
    /// 
    /// For instance, `GtkIconView` creates all icons (rows) to have
    /// the same width and the cells theirin to have the same
    /// horizontal alignments. However each row of icons may have
    /// a separate collective height. `GtkIconView` uses this to
    /// request the heights of each row based on a context which
    /// was already used to request all the row widths that are
    /// to be displayed.
    func copy(context: CellAreaContextProtocol) -> UnsafeMutablePointer<GtkCellAreaContext>! {
        let rv = gtk_cell_area_copy_context(cast(cell_area_ptr), cast(context.ptr))
        return cast(rv)
    }

    /// Creates a `GtkCellAreaContext` to be used with `area` for
    /// all purposes. `GtkCellAreaContext` stores geometry information
    /// for rows for which it was operated on, it is important to use
    /// the same context for the same row of data at all times (i.e.
    /// one should render and handle events with the same `GtkCellAreaContext`
    /// which was used to request the size of those rows of data).
    func createContext() -> UnsafeMutablePointer<GtkCellAreaContext>! {
        let rv = gtk_cell_area_create_context(cast(cell_area_ptr))
        return cast(rv)
    }

    /// Delegates event handling to a `GtkCellArea`.
    func event(context: CellAreaContextProtocol, widget: WidgetProtocol, event: UnsafeMutablePointer<GdkEvent>, cellArea cell_area: Gdk.RectangleProtocol, flags: CellRendererState) -> CInt {
        let rv = gtk_cell_area_event(cast(cell_area_ptr), cast(context.ptr), cast(widget.ptr), cast(event), cast(cell_area.ptr), flags)
        return CInt(rv)
    }

    /// This should be called by the `area`’s owning layout widget
    /// when focus is to be passed to `area`, or moved within `area`
    /// for a given `direction` and row data.
    /// 
    /// Implementing `GtkCellArea` classes should implement this
    /// method to receive and navigate focus in its own way particular
    /// to how it lays out cells.
    func focus(direction: DirectionType) -> Bool {
        let rv = gtk_cell_area_focus(cast(cell_area_ptr), direction)
        return Bool(rv != 0)
    }

    /// Calls `callback` for every `GtkCellRenderer` in `area`.
    func foreach(callback: @escaping CellCallback, callbackData callback_data: UnsafeMutableRawPointer) {
        gtk_cell_area_foreach(cast(cell_area_ptr), callback, cast(callback_data))
    
    }

    /// Calls `callback` for every `GtkCellRenderer` in `area` with the
    /// allocated rectangle inside `cell_area`.
    func foreachAlloc(context: CellAreaContextProtocol, widget: WidgetProtocol, cellArea cell_area: Gdk.RectangleProtocol, backgroundArea background_area: Gdk.RectangleProtocol, callback: @escaping CellAllocCallback, callbackData callback_data: UnsafeMutableRawPointer) {
        gtk_cell_area_foreach_alloc(cast(cell_area_ptr), cast(context.ptr), cast(widget.ptr), cast(cell_area.ptr), cast(background_area.ptr), callback, cast(callback_data))
    
    }

    /// Derives the allocation of `renderer` inside `area` if `area`
    /// were to be renderered in `cell_area`.
    func getCellAllocation(context: CellAreaContextProtocol, widget: WidgetProtocol, renderer: CellRendererProtocol, cellArea cell_area: Gdk.RectangleProtocol, allocation: Gdk.RectangleProtocol) {
        gtk_cell_area_get_cell_allocation(cast(cell_area_ptr), cast(context.ptr), cast(widget.ptr), cast(renderer.ptr), cast(cell_area.ptr), cast(allocation.ptr))
    
    }

    /// Gets the `GtkCellRenderer` at `x` and `y` coordinates inside `area` and optionally
    /// returns the full cell allocation for it inside `cell_area`.
    func getCellAtPosition(context: CellAreaContextProtocol, widget: WidgetProtocol, cellArea cell_area: Gdk.RectangleProtocol, x: CInt, y: CInt, allocArea alloc_area: Gdk.RectangleProtocol) -> UnsafeMutablePointer<GtkCellRenderer>! {
        let rv = gtk_cell_area_get_cell_at_position(cast(cell_area_ptr), cast(context.ptr), cast(widget.ptr), cast(cell_area.ptr), gint(x), gint(y), cast(alloc_area.ptr))
        return cast(rv)
    }

    /// Gets the current `GtkTreePath` string for the currently
    /// applied `GtkTreeIter`, this is implicitly updated when
    /// `gtk_cell_area_apply_attributes()` is called and can be
    /// used to interact with renderers from `GtkCellArea`
    /// subclasses.
    func getCurrentPathString() -> String! {
        let rv = gtk_cell_area_get_current_path_string(cast(cell_area_ptr))
        return rv.map { String(cString: UnsafePointer<CChar>($0)) }
    }

    /// Gets the `GtkCellEditable` widget currently used
    /// to edit the currently edited cell.
    func getEditWidget() -> UnsafeMutablePointer<GtkCellEditable>! {
        let rv = gtk_cell_area_get_edit_widget(cast(cell_area_ptr))
        return cast(rv)
    }

    /// Gets the `GtkCellRenderer` in `area` that is currently
    /// being edited.
    func getEditedCell() -> UnsafeMutablePointer<GtkCellRenderer>! {
        let rv = gtk_cell_area_get_edited_cell(cast(cell_area_ptr))
        return cast(rv)
    }

    /// Retrieves the currently focused cell for `area`
    func getFocusCell() -> UnsafeMutablePointer<GtkCellRenderer>! {
        let rv = gtk_cell_area_get_focus_cell(cast(cell_area_ptr))
        return cast(rv)
    }

    /// Gets the `GtkCellRenderer` which is expected to be focusable
    /// for which `renderer` is, or may be a sibling.
    /// 
    /// This is handy for `GtkCellArea` subclasses when handling events,
    /// after determining the renderer at the event location it can
    /// then chose to activate the focus cell for which the event
    /// cell may have been a sibling.
    func getFocusFromSibling(renderer: CellRendererProtocol) -> UnsafeMutablePointer<GtkCellRenderer>! {
        let rv = gtk_cell_area_get_focus_from_sibling(cast(cell_area_ptr), cast(renderer.ptr))
        return cast(rv)
    }

    /// Gets the focus sibling cell renderers for `renderer`.
    func getFocusSiblings(renderer: CellRendererProtocol) -> UnsafePointer<GList>! {
        let rv = gtk_cell_area_get_focus_siblings(cast(cell_area_ptr), cast(renderer.ptr))
        return cast(rv)
    }

    /// Retrieves a cell area’s initial minimum and natural height.
    /// 
    /// `area` will store some geometrical information in `context` along the way;
    /// when requesting sizes over an arbitrary number of rows, it’s not important
    /// to check the `minimum_height` and `natural_height` of this call but rather to
    /// consult `gtk_cell_area_context_get_preferred_height()` after a series of
    /// requests.
    func getPreferredHeight(context: CellAreaContextProtocol, widget: WidgetProtocol, minimumHeight minimum_height: UnsafeMutablePointer<CInt>, naturalHeight natural_height: UnsafeMutablePointer<CInt>) {
        gtk_cell_area_get_preferred_height(cast(cell_area_ptr), cast(context.ptr), cast(widget.ptr), cast(minimum_height), cast(natural_height))
    
    }

    /// Retrieves a cell area’s minimum and natural height if it would be given
    /// the specified `width`.
    /// 
    /// `area` stores some geometrical information in `context` along the way
    /// while calling `gtk_cell_area_get_preferred_width()`. It’s important to
    /// perform a series of `gtk_cell_area_get_preferred_width()` requests with
    /// `context` first and then call `gtk_cell_area_get_preferred_height_for_width()`
    /// on each cell area individually to get the height for width of each
    /// fully requested row.
    /// 
    /// If at some point, the width of a single row changes, it should be
    /// requested with `gtk_cell_area_get_preferred_width()` again and then
    /// the full width of the requested rows checked again with
    /// `gtk_cell_area_context_get_preferred_width()`.
    func getPreferredHeightForWidth(context: CellAreaContextProtocol, widget: WidgetProtocol, width: CInt, minimumHeight minimum_height: UnsafeMutablePointer<CInt>, naturalHeight natural_height: UnsafeMutablePointer<CInt>) {
        gtk_cell_area_get_preferred_height_for_width(cast(cell_area_ptr), cast(context.ptr), cast(widget.ptr), gint(width), cast(minimum_height), cast(natural_height))
    
    }

    /// Retrieves a cell area’s initial minimum and natural width.
    /// 
    /// `area` will store some geometrical information in `context` along the way;
    /// when requesting sizes over an arbitrary number of rows, it’s not important
    /// to check the `minimum_width` and `natural_width` of this call but rather to
    /// consult `gtk_cell_area_context_get_preferred_width()` after a series of
    /// requests.
    func getPreferredWidth(context: CellAreaContextProtocol, widget: WidgetProtocol, minimumWidth minimum_width: UnsafeMutablePointer<CInt>, naturalWidth natural_width: UnsafeMutablePointer<CInt>) {
        gtk_cell_area_get_preferred_width(cast(cell_area_ptr), cast(context.ptr), cast(widget.ptr), cast(minimum_width), cast(natural_width))
    
    }

    /// Retrieves a cell area’s minimum and natural width if it would be given
    /// the specified `height`.
    /// 
    /// `area` stores some geometrical information in `context` along the way
    /// while calling `gtk_cell_area_get_preferred_height()`. It’s important to
    /// perform a series of `gtk_cell_area_get_preferred_height()` requests with
    /// `context` first and then call `gtk_cell_area_get_preferred_width_for_height()`
    /// on each cell area individually to get the height for width of each
    /// fully requested row.
    /// 
    /// If at some point, the height of a single row changes, it should be
    /// requested with `gtk_cell_area_get_preferred_height()` again and then
    /// the full height of the requested rows checked again with
    /// `gtk_cell_area_context_get_preferred_height()`.
    func getPreferredWidthForHeight(context: CellAreaContextProtocol, widget: WidgetProtocol, height: CInt, minimumWidth minimum_width: UnsafeMutablePointer<CInt>, naturalWidth natural_width: UnsafeMutablePointer<CInt>) {
        gtk_cell_area_get_preferred_width_for_height(cast(cell_area_ptr), cast(context.ptr), cast(widget.ptr), gint(height), cast(minimum_width), cast(natural_width))
    
    }

    /// Gets whether the area prefers a height-for-width layout
    /// or a width-for-height layout.
    func getRequestMode() -> GtkSizeRequestMode {
        let rv = gtk_cell_area_get_request_mode(cast(cell_area_ptr))
        return rv
    }

    /// Checks if `area` contains `renderer`.
    func has(renderer: CellRendererProtocol) -> Bool {
        let rv = gtk_cell_area_has_renderer(cast(cell_area_ptr), cast(renderer.ptr))
        return Bool(rv != 0)
    }

    /// This is a convenience function for `GtkCellArea` implementations
    /// to get the inner area where a given `GtkCellRenderer` will be
    /// rendered. It removes any padding previously added by `gtk_cell_area_request_renderer()`.
    func innerCellArea(widget: WidgetProtocol, cellArea cell_area: Gdk.RectangleProtocol, innerArea inner_area: Gdk.RectangleProtocol) {
        gtk_cell_area_inner_cell_area(cast(cell_area_ptr), cast(widget.ptr), cast(cell_area.ptr), cast(inner_area.ptr))
    
    }

    /// Returns whether `sibling` is one of `renderer`’s focus siblings
    /// (see `gtk_cell_area_add_focus_sibling()`).
    func isFocusSibling(renderer: CellRendererProtocol, sibling: CellRendererProtocol) -> Bool {
        let rv = gtk_cell_area_is_focus_sibling(cast(cell_area_ptr), cast(renderer.ptr), cast(sibling.ptr))
        return Bool(rv != 0)
    }

    /// Removes `renderer` from `area`.
    func remove(renderer: CellRendererProtocol) {
        gtk_cell_area_remove(cast(cell_area_ptr), cast(renderer.ptr))
    
    }

    /// Removes `sibling` from `renderer`’s focus sibling list
    /// (see `gtk_cell_area_add_focus_sibling()`).
    func removeFocusSibling(renderer: CellRendererProtocol, sibling: CellRendererProtocol) {
        gtk_cell_area_remove_focus_sibling(cast(cell_area_ptr), cast(renderer.ptr), cast(sibling.ptr))
    
    }

    /// Renders `area`’s cells according to `area`’s layout onto `widget` at
    /// the given coordinates.
    func render(context: CellAreaContextProtocol, widget: WidgetProtocol, cr: cairo.ContextProtocol, backgroundArea background_area: Gdk.RectangleProtocol, cellArea cell_area: Gdk.RectangleProtocol, flags: CellRendererState, paintFocus paint_focus: Bool) {
        gtk_cell_area_render(cast(cell_area_ptr), cast(context.ptr), cast(widget.ptr), cast(cr.ptr), cast(background_area.ptr), cast(cell_area.ptr), flags, gboolean(paint_focus ? 1 : 0))
    
    }

    /// This is a convenience function for `GtkCellArea` implementations
    /// to request size for cell renderers. It’s important to use this
    /// function to request size and then use `gtk_cell_area_inner_cell_area()`
    /// at render and event time since this function will add padding
    /// around the cell for focus painting.
    func request(renderer: CellRendererProtocol, orientation: Orientation, widget: WidgetProtocol, forSize for_size: CInt, minimumSize minimum_size: UnsafeMutablePointer<CInt>, naturalSize natural_size: UnsafeMutablePointer<CInt>) {
        gtk_cell_area_request_renderer(cast(cell_area_ptr), cast(renderer.ptr), orientation, cast(widget.ptr), gint(for_size), cast(minimum_size), cast(natural_size))
    
    }

    /// Explicitly sets the currently focused cell to `renderer`.
    /// 
    /// This is generally called by implementations of
    /// `GtkCellAreaClass.focus``()` or `GtkCellAreaClass.event``()`,
    /// however it can also be used to implement functions such
    /// as `gtk_tree_view_set_cursor_on_cell()`.
    func setFocusCell(renderer: CellRendererProtocol) {
        gtk_cell_area_set_focus_cell(cast(cell_area_ptr), cast(renderer.ptr))
    
    }

    /// Explicitly stops the editing of the currently edited cell.
    /// 
    /// If `canceled` is `true`, the currently edited cell renderer
    /// will emit the `editing`-canceled signal, otherwise the
    /// the `editing`-done signal will be emitted on the current
    /// edit widget.
    /// 
    /// See `gtk_cell_area_get_edited_cell()` and `gtk_cell_area_get_edit_widget()`.
    func stopEditing(canceled: Bool) {
        gtk_cell_area_stop_editing(cast(cell_area_ptr), gboolean(canceled ? 1 : 0))
    
    }
    /// Gets the current `GtkTreePath` string for the currently
    /// applied `GtkTreeIter`, this is implicitly updated when
    /// `gtk_cell_area_apply_attributes()` is called and can be
    /// used to interact with renderers from `GtkCellArea`
    /// subclasses.
    var currentPathString: String! {
        /// Gets the current `GtkTreePath` string for the currently
        /// applied `GtkTreeIter`, this is implicitly updated when
        /// `gtk_cell_area_apply_attributes()` is called and can be
        /// used to interact with renderers from `GtkCellArea`
        /// subclasses.
        get {
            let rv = gtk_cell_area_get_current_path_string(cast(cell_area_ptr))
            return rv.map { String(cString: UnsafePointer<CChar>($0)) }
        }
    }

    /// Gets the `GtkCellEditable` widget currently used
    /// to edit the currently edited cell.
    var editWidget: UnsafeMutablePointer<GtkCellEditable>! {
        /// Gets the `GtkCellEditable` widget currently used
        /// to edit the currently edited cell.
        get {
            let rv = gtk_cell_area_get_edit_widget(cast(cell_area_ptr))
            return cast(rv)
        }
    }

    /// Gets the `GtkCellRenderer` in `area` that is currently
    /// being edited.
    var editedCell: UnsafeMutablePointer<GtkCellRenderer>! {
        /// Gets the `GtkCellRenderer` in `area` that is currently
        /// being edited.
        get {
            let rv = gtk_cell_area_get_edited_cell(cast(cell_area_ptr))
            return cast(rv)
        }
    }

    /// Retrieves the currently focused cell for `area`
    var focusCell: UnsafeMutablePointer<GtkCellRenderer>! {
        /// Retrieves the currently focused cell for `area`
        get {
            let rv = gtk_cell_area_get_focus_cell(cast(cell_area_ptr))
            return cast(rv)
        }
        /// Explicitly sets the currently focused cell to `renderer`.
        /// 
        /// This is generally called by implementations of
        /// `GtkCellAreaClass.focus``()` or `GtkCellAreaClass.event``()`,
        /// however it can also be used to implement functions such
        /// as `gtk_tree_view_set_cursor_on_cell()`.
        nonmutating set {
            gtk_cell_area_set_focus_cell(cast(cell_area_ptr), cast(newValue))
        }
    }

    /// Returns whether the area can do anything when activated,
    /// after applying new attributes to `area`.
    var isActivatable: Bool {
        /// Returns whether the area can do anything when activated,
        /// after applying new attributes to `area`.
        get {
            let rv = gtk_cell_area_is_activatable(cast(cell_area_ptr))
            return Bool(rv != 0)
        }
    }

    /// Gets whether the area prefers a height-for-width layout
    /// or a width-for-height layout.
    var requestMode: GtkSizeRequestMode {
        /// Gets whether the area prefers a height-for-width layout
        /// or a width-for-height layout.
        get {
            let rv = gtk_cell_area_get_request_mode(cast(cell_area_ptr))
            return rv
        }
    }
}



// MARK: - CellAreaBox Class

/// The `CellAreaBoxProtocol` protocol exposes the methods and properties of an underlying `GtkCellAreaBox` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellAreaBox`.
/// Alternatively, use `CellAreaBoxRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// The `GtkCellAreaBox` renders cell renderers into a row or a column
/// depending on its `GtkOrientation`.
/// 
/// GtkCellAreaBox uses a notion of packing. Packing
/// refers to adding cell renderers with reference to a particular position
/// in a `GtkCellAreaBox`. There are two reference positions: the
/// start and the end of the box.
/// When the `GtkCellAreaBox` is oriented in the `GTK_ORIENTATION_VERTICAL`
/// orientation, the start is defined as the top of the box and the end is
/// defined as the bottom. In the `GTK_ORIENTATION_HORIZONTAL` orientation
/// start is defined as the left side and the end is defined as the right
/// side.
/// 
/// Alignments of `GtkCellRenderers` rendered in adjacent rows can be
/// configured by configuring the `GtkCellAreaBox` align child cell property
/// with `gtk_cell_area_cell_set_property()` or by specifying the "align"
/// argument to `gtk_cell_area_box_pack_start()` and `gtk_cell_area_box_pack_end()`.
public protocol CellAreaBoxProtocol: CellAreaProtocol, OrientableProtocol {
    /// Untyped pointer to the underlying `GtkCellAreaBox` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkCellAreaBox` instance.
    var cell_area_box_ptr: UnsafeMutablePointer<GtkCellAreaBox> { get }
}

/// The `CellAreaBoxRef` type acts as a lightweight Swift reference to an underlying `GtkCellAreaBox` instance.
/// It exposes methods that can operate on this data type through `CellAreaBoxProtocol` conformance.
/// Use `CellAreaBoxRef` only as an `unowned` reference to an existing `GtkCellAreaBox` instance.
///
/// The `GtkCellAreaBox` renders cell renderers into a row or a column
/// depending on its `GtkOrientation`.
/// 
/// GtkCellAreaBox uses a notion of packing. Packing
/// refers to adding cell renderers with reference to a particular position
/// in a `GtkCellAreaBox`. There are two reference positions: the
/// start and the end of the box.
/// When the `GtkCellAreaBox` is oriented in the `GTK_ORIENTATION_VERTICAL`
/// orientation, the start is defined as the top of the box and the end is
/// defined as the bottom. In the `GTK_ORIENTATION_HORIZONTAL` orientation
/// start is defined as the left side and the end is defined as the right
/// side.
/// 
/// Alignments of `GtkCellRenderers` rendered in adjacent rows can be
/// configured by configuring the `GtkCellAreaBox` align child cell property
/// with `gtk_cell_area_cell_set_property()` or by specifying the "align"
/// argument to `gtk_cell_area_box_pack_start()` and `gtk_cell_area_box_pack_end()`.
public struct CellAreaBoxRef: CellAreaBoxProtocol {
    /// Untyped pointer to the underlying `GtkCellAreaBox` instance.
    /// For type-safe access, use the generated, typed pointer `cell_area_box_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension CellAreaBoxRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkCellAreaBox>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `CellAreaBoxProtocol`
    init<T: CellAreaBoxProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellAreaBox`.
    init() {
        let rv = gtk_cell_area_box_new()
        self.init(cast(rv))
    }
}

/// The `CellAreaBox` type acts as a reference-counted owner of an underlying `GtkCellAreaBox` instance.
/// It provides the methods that can operate on this data type through `CellAreaBoxProtocol` conformance.
/// Use `CellAreaBox` as a strong reference or owner of a `GtkCellAreaBox` instance.
///
/// The `GtkCellAreaBox` renders cell renderers into a row or a column
/// depending on its `GtkOrientation`.
/// 
/// GtkCellAreaBox uses a notion of packing. Packing
/// refers to adding cell renderers with reference to a particular position
/// in a `GtkCellAreaBox`. There are two reference positions: the
/// start and the end of the box.
/// When the `GtkCellAreaBox` is oriented in the `GTK_ORIENTATION_VERTICAL`
/// orientation, the start is defined as the top of the box and the end is
/// defined as the bottom. In the `GTK_ORIENTATION_HORIZONTAL` orientation
/// start is defined as the left side and the end is defined as the right
/// side.
/// 
/// Alignments of `GtkCellRenderers` rendered in adjacent rows can be
/// configured by configuring the `GtkCellAreaBox` align child cell property
/// with `gtk_cell_area_cell_set_property()` or by specifying the "align"
/// argument to `gtk_cell_area_box_pack_start()` and `gtk_cell_area_box_pack_end()`.
open class CellAreaBox: CellArea, CellAreaBoxProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `CellAreaBox` instance.
    public init(_ op: UnsafeMutablePointer<GtkCellAreaBox>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `CellAreaBoxProtocol`
    /// Will retain `GtkCellAreaBox`.
    public convenience init<T: CellAreaBoxProtocol>(_ other: T) {
        self.init(cast(other.cell_area_box_ptr))
        g_object_ref(cast(cell_area_box_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkCellAreaBox.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkCellAreaBox.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkCellAreaBox.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkCellAreaBox>(opaquePointer))
    }

    /// Creates a new `GtkCellAreaBox`.
    public convenience init() {
        let rv = gtk_cell_area_box_new()
        self.init(cast(rv))
    }


}

public enum CellAreaBoxPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    /// The widget currently editing the edited cell
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case editWidget = "edit-widget"
    /// The cell in the area that is currently edited
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case editedCell = "edited-cell"
    /// The cell in the area that currently has focus
    case focusCell = "focus-cell"
    /// The amount of space to reserve between cells.
    case spacing = "spacing"
}

public extension CellAreaBoxProtocol {
    /// Bind a `CellAreaBoxPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellAreaBoxPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(cell_area_box_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum CellAreaBoxSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// Indicates that editing has started on `renderer` and that `editable`
    /// should be added to the owning cell-layouting widget at `cell_area`.
    case addEditable = "add-editable"
    /// This signal is emitted whenever applying attributes to `area` from `model`
    case applyAttributes = "apply-attributes"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// Indicates that focus changed on this `area`. This signal
    /// is emitted either as a result of focus handling or event
    /// handling.
    /// 
    /// It's possible that the signal is emitted even if the
    /// currently focused renderer did not change, this is
    /// because focus may change to the same renderer in the
    /// same cell area for a different row of data.
    case focusChanged = "focus-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// Indicates that editing finished on `renderer` and that `editable`
    /// should be removed from the owning cell-layouting widget.
    case removeEditable = "remove-editable"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    /// The widget currently editing the edited cell
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case notifyEditWidget = "notify::edit-widget"
    /// The cell in the area that is currently edited
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case notifyEditedCell = "notify::edited-cell"
    /// The cell in the area that currently has focus
    case notifyFocusCell = "notify::focus-cell"
    /// The amount of space to reserve between cells.
    case notifySpacing = "notify::spacing"
}

public extension CellAreaBoxProtocol {
    /// Connect a `CellAreaBoxSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: CellAreaBoxSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(cell_area_box_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension CellAreaBoxProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellAreaBox` instance.
    var cell_area_box_ptr: UnsafeMutablePointer<GtkCellAreaBox> { return ptr.assumingMemoryBound(to: GtkCellAreaBox.self) }

    /// Gets the spacing added between cell renderers.
    func getSpacing() -> CInt {
        let rv = gtk_cell_area_box_get_spacing(cast(cell_area_box_ptr))
        return CInt(rv)
    }

    /// Adds `renderer` to `box`, packed with reference to the end of `box`.
    /// 
    /// The `renderer` is packed after (away from end of) any other
    /// `GtkCellRenderer` packed with reference to the end of `box`.
    func packEnd(renderer: CellRendererProtocol, expand: Bool, align: Bool, fixed: Bool) {
        gtk_cell_area_box_pack_end(cast(cell_area_box_ptr), cast(renderer.ptr), gboolean(expand ? 1 : 0), gboolean(align ? 1 : 0), gboolean(fixed ? 1 : 0))
    
    }

    /// Adds `renderer` to `box`, packed with reference to the start of `box`.
    /// 
    /// The `renderer` is packed after any other `GtkCellRenderer` packed
    /// with reference to the start of `box`.
    func packStart(renderer: CellRendererProtocol, expand: Bool, align: Bool, fixed: Bool) {
        gtk_cell_area_box_pack_start(cast(cell_area_box_ptr), cast(renderer.ptr), gboolean(expand ? 1 : 0), gboolean(align ? 1 : 0), gboolean(fixed ? 1 : 0))
    
    }

    /// Sets the spacing to add between cell renderers in `box`.
    func set(spacing: CInt) {
        gtk_cell_area_box_set_spacing(cast(cell_area_box_ptr), gint(spacing))
    
    }
    /// The amount of space to reserve between cells.
    var spacing: CInt {
        /// Gets the spacing added between cell renderers.
        get {
            let rv = gtk_cell_area_box_get_spacing(cast(cell_area_box_ptr))
            return CInt(rv)
        }
        /// Sets the spacing to add between cell renderers in `box`.
        nonmutating set {
            gtk_cell_area_box_set_spacing(cast(cell_area_box_ptr), gint(newValue))
        }
    }
}



// MARK: - CellAreaContext Class

/// The `CellAreaContextProtocol` protocol exposes the methods and properties of an underlying `GtkCellAreaContext` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellAreaContext`.
/// Alternatively, use `CellAreaContextRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// The `GtkCellAreaContext` object is created by a given `GtkCellArea`
/// implementation via its `GtkCellAreaClass.create_context``()` virtual
/// method and is used to store cell sizes and alignments for a series of
/// `GtkTreeModel` rows that are requested and rendered in the same context.
/// 
/// `GtkCellLayout` widgets can create any number of contexts in which to
/// request and render groups of data rows. However, it’s important that the
/// same context which was used to request sizes for a given `GtkTreeModel`
/// row also be used for the same row when calling other `GtkCellArea` APIs
/// such as `gtk_cell_area_render()` and `gtk_cell_area_event()`.
public protocol CellAreaContextProtocol: GLibObject.ObjectProtocol {
    /// Untyped pointer to the underlying `GtkCellAreaContext` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkCellAreaContext` instance.
    var cell_area_context_ptr: UnsafeMutablePointer<GtkCellAreaContext> { get }
}

/// The `CellAreaContextRef` type acts as a lightweight Swift reference to an underlying `GtkCellAreaContext` instance.
/// It exposes methods that can operate on this data type through `CellAreaContextProtocol` conformance.
/// Use `CellAreaContextRef` only as an `unowned` reference to an existing `GtkCellAreaContext` instance.
///
/// The `GtkCellAreaContext` object is created by a given `GtkCellArea`
/// implementation via its `GtkCellAreaClass.create_context``()` virtual
/// method and is used to store cell sizes and alignments for a series of
/// `GtkTreeModel` rows that are requested and rendered in the same context.
/// 
/// `GtkCellLayout` widgets can create any number of contexts in which to
/// request and render groups of data rows. However, it’s important that the
/// same context which was used to request sizes for a given `GtkTreeModel`
/// row also be used for the same row when calling other `GtkCellArea` APIs
/// such as `gtk_cell_area_render()` and `gtk_cell_area_event()`.
public struct CellAreaContextRef: CellAreaContextProtocol {
    /// Untyped pointer to the underlying `GtkCellAreaContext` instance.
    /// For type-safe access, use the generated, typed pointer `cell_area_context_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension CellAreaContextRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkCellAreaContext>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `CellAreaContextProtocol`
    init<T: CellAreaContextProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `CellAreaContext` type acts as a reference-counted owner of an underlying `GtkCellAreaContext` instance.
/// It provides the methods that can operate on this data type through `CellAreaContextProtocol` conformance.
/// Use `CellAreaContext` as a strong reference or owner of a `GtkCellAreaContext` instance.
///
/// The `GtkCellAreaContext` object is created by a given `GtkCellArea`
/// implementation via its `GtkCellAreaClass.create_context``()` virtual
/// method and is used to store cell sizes and alignments for a series of
/// `GtkTreeModel` rows that are requested and rendered in the same context.
/// 
/// `GtkCellLayout` widgets can create any number of contexts in which to
/// request and render groups of data rows. However, it’s important that the
/// same context which was used to request sizes for a given `GtkTreeModel`
/// row also be used for the same row when calling other `GtkCellArea` APIs
/// such as `gtk_cell_area_render()` and `gtk_cell_area_event()`.
open class CellAreaContext: GLibObject.Object, CellAreaContextProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `CellAreaContext` instance.
    public init(_ op: UnsafeMutablePointer<GtkCellAreaContext>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `CellAreaContextProtocol`
    /// Will retain `GtkCellAreaContext`.
    public convenience init<T: CellAreaContextProtocol>(_ other: T) {
        self.init(cast(other.cell_area_context_ptr))
        g_object_ref(cast(cell_area_context_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkCellAreaContext.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkCellAreaContext.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkCellAreaContext.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkCellAreaContext>(opaquePointer))
    }



}

public enum CellAreaContextPropertyName: String, PropertyNameProtocol {
    /// The `GtkCellArea` this context was created by
    case area = "area"
    /// The minimum height for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_height()`.
    case minimumHeight = "minimum-height"
    /// The minimum width for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_width()`.
    case minimumWidth = "minimum-width"
    /// The natural height for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_height()`.
    case naturalHeight = "natural-height"
    /// The natural width for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_width()`.
    case naturalWidth = "natural-width"
}

public extension CellAreaContextProtocol {
    /// Bind a `CellAreaContextPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellAreaContextPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(cell_area_context_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum CellAreaContextSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `GtkCellArea` this context was created by
    case notifyArea = "notify::area"
    /// The minimum height for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_height()`.
    case notifyMinimumHeight = "notify::minimum-height"
    /// The minimum width for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_width()`.
    case notifyMinimumWidth = "notify::minimum-width"
    /// The natural height for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_height()`.
    case notifyNaturalHeight = "notify::natural-height"
    /// The natural width for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_width()`.
    case notifyNaturalWidth = "notify::natural-width"
}

public extension CellAreaContextProtocol {
    /// Connect a `CellAreaContextSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: CellAreaContextSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(cell_area_context_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension CellAreaContextProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellAreaContext` instance.
    var cell_area_context_ptr: UnsafeMutablePointer<GtkCellAreaContext> { return ptr.assumingMemoryBound(to: GtkCellAreaContext.self) }

    /// Allocates a width and/or a height for all rows which are to be
    /// rendered with `context`.
    /// 
    /// Usually allocation is performed only horizontally or sometimes
    /// vertically since a group of rows are usually rendered side by
    /// side vertically or horizontally and share either the same width
    /// or the same height. Sometimes they are allocated in both horizontal
    /// and vertical orientations producing a homogeneous effect of the
    /// rows. This is generally the case for `GtkTreeView` when
    /// `GtkTreeView:fixed`-height-mode is enabled.
    /// 
    /// Since 3.0
    func allocate(width: CInt, height: CInt) {
        gtk_cell_area_context_allocate(cast(cell_area_context_ptr), gint(width), gint(height))
    
    }

    /// Fetches the current allocation size for `context`.
    /// 
    /// If the context was not allocated in width or height, or if the
    /// context was recently reset with `gtk_cell_area_context_reset()`,
    /// the returned value will be -1.
    func getAllocation(width: UnsafeMutablePointer<CInt>, height: UnsafeMutablePointer<CInt>) {
        gtk_cell_area_context_get_allocation(cast(cell_area_context_ptr), cast(width), cast(height))
    
    }

    /// Fetches the `GtkCellArea` this `context` was created by.
    /// 
    /// This is generally unneeded by layouting widgets; however,
    /// it is important for the context implementation itself to
    /// fetch information about the area it is being used for.
    /// 
    /// For instance at `GtkCellAreaContextClass.allocate``()` time
    /// it’s important to know details about any cell spacing
    /// that the `GtkCellArea` is configured with in order to
    /// compute a proper allocation.
    func getArea() -> UnsafeMutablePointer<GtkCellArea>! {
        let rv = gtk_cell_area_context_get_area(cast(cell_area_context_ptr))
        return cast(rv)
    }

    /// Gets the accumulative preferred height for all rows which have been
    /// requested with this context.
    /// 
    /// After `gtk_cell_area_context_reset()` is called and/or before ever
    /// requesting the size of a `GtkCellArea`, the returned values are 0.
    func getPreferredHeight(minimumHeight minimum_height: UnsafeMutablePointer<CInt>, naturalHeight natural_height: UnsafeMutablePointer<CInt>) {
        gtk_cell_area_context_get_preferred_height(cast(cell_area_context_ptr), cast(minimum_height), cast(natural_height))
    
    }

    /// Gets the accumulative preferred height for `width` for all rows
    /// which have been requested for the same said `width` with this context.
    /// 
    /// After `gtk_cell_area_context_reset()` is called and/or before ever
    /// requesting the size of a `GtkCellArea`, the returned values are -1.
    func getPreferredHeightFor(width: CInt, minimumHeight minimum_height: UnsafeMutablePointer<CInt>, naturalHeight natural_height: UnsafeMutablePointer<CInt>) {
        gtk_cell_area_context_get_preferred_height_for_width(cast(cell_area_context_ptr), gint(width), cast(minimum_height), cast(natural_height))
    
    }

    /// Gets the accumulative preferred width for all rows which have been
    /// requested with this context.
    /// 
    /// After `gtk_cell_area_context_reset()` is called and/or before ever
    /// requesting the size of a `GtkCellArea`, the returned values are 0.
    func getPreferredWidth(minimumWidth minimum_width: UnsafeMutablePointer<CInt>, naturalWidth natural_width: UnsafeMutablePointer<CInt>) {
        gtk_cell_area_context_get_preferred_width(cast(cell_area_context_ptr), cast(minimum_width), cast(natural_width))
    
    }

    /// Gets the accumulative preferred width for `height` for all rows which
    /// have been requested for the same said `height` with this context.
    /// 
    /// After `gtk_cell_area_context_reset()` is called and/or before ever
    /// requesting the size of a `GtkCellArea`, the returned values are -1.
    func getPreferredWidthFor(height: CInt, minimumWidth minimum_width: UnsafeMutablePointer<CInt>, naturalWidth natural_width: UnsafeMutablePointer<CInt>) {
        gtk_cell_area_context_get_preferred_width_for_height(cast(cell_area_context_ptr), gint(height), cast(minimum_width), cast(natural_width))
    
    }

    /// Causes the minimum and/or natural height to grow if the new
    /// proposed sizes exceed the current minimum and natural height.
    /// 
    /// This is used by `GtkCellAreaContext` implementations during
    /// the request process over a series of `GtkTreeModel` rows to
    /// progressively push the requested height over a series of
    /// `gtk_cell_area_get_preferred_height()` requests.
    func pushPreferredHeight(minimumHeight minimum_height: CInt, naturalHeight natural_height: CInt) {
        gtk_cell_area_context_push_preferred_height(cast(cell_area_context_ptr), gint(minimum_height), gint(natural_height))
    
    }

    /// Causes the minimum and/or natural width to grow if the new
    /// proposed sizes exceed the current minimum and natural width.
    /// 
    /// This is used by `GtkCellAreaContext` implementations during
    /// the request process over a series of `GtkTreeModel` rows to
    /// progressively push the requested width over a series of
    /// `gtk_cell_area_get_preferred_width()` requests.
    func pushPreferredWidth(minimumWidth minimum_width: CInt, naturalWidth natural_width: CInt) {
        gtk_cell_area_context_push_preferred_width(cast(cell_area_context_ptr), gint(minimum_width), gint(natural_width))
    
    }

    /// Resets any previously cached request and allocation
    /// data.
    /// 
    /// When underlying `GtkTreeModel` data changes its
    /// important to reset the context if the content
    /// size is allowed to shrink. If the content size
    /// is only allowed to grow (this is usually an option
    /// for views rendering large data stores as a measure
    /// of optimization), then only the row that changed
    /// or was inserted needs to be (re)requested with
    /// `gtk_cell_area_get_preferred_width()`.
    /// 
    /// When the new overall size of the context requires
    /// that the allocated size changes (or whenever this
    /// allocation changes at all), the variable row
    /// sizes need to be re-requested for every row.
    /// 
    /// For instance, if the rows are displayed all with
    /// the same width from top to bottom then a change
    /// in the allocated width necessitates a recalculation
    /// of all the displayed row heights using
    /// `gtk_cell_area_get_preferred_height_for_width()`.
    /// 
    /// Since 3.0
    func reset() {
        gtk_cell_area_context_reset(cast(cell_area_context_ptr))
    
    }
    /// The `GtkCellArea` this context was created by
    var area: UnsafeMutablePointer<GtkCellArea>! {
        /// Fetches the `GtkCellArea` this `context` was created by.
        /// 
        /// This is generally unneeded by layouting widgets; however,
        /// it is important for the context implementation itself to
        /// fetch information about the area it is being used for.
        /// 
        /// For instance at `GtkCellAreaContextClass.allocate``()` time
        /// it’s important to know details about any cell spacing
        /// that the `GtkCellArea` is configured with in order to
        /// compute a proper allocation.
        get {
            let rv = gtk_cell_area_context_get_area(cast(cell_area_context_ptr))
            return cast(rv)
        }
    }
}



// MARK: - CellRenderer Class

/// The `CellRendererProtocol` protocol exposes the methods and properties of an underlying `GtkCellRenderer` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRenderer`.
/// Alternatively, use `CellRendererRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// The `GtkCellRenderer` is a base class of a set of objects used for
/// rendering a cell to a `cairo_t`.  These objects are used primarily by
/// the `GtkTreeView` widget, though they aren’t tied to them in any
/// specific way.  It is worth noting that `GtkCellRenderer` is not a
/// `GtkWidget` and cannot be treated as such.
/// 
/// The primary use of a `GtkCellRenderer` is for drawing a certain graphical
/// elements on a `cairo_t`. Typically, one cell renderer is used to
/// draw many cells on the screen.  To this extent, it isn’t expected that a
/// CellRenderer keep any permanent state around.  Instead, any state is set
/// just prior to use using `GObjects` property system.  Then, the
/// cell is measured using `gtk_cell_renderer_get_size()`. Finally, the cell
/// is rendered in the correct location using `gtk_cell_renderer_render()`.
/// 
/// There are a number of rules that must be followed when writing a new
/// `GtkCellRenderer`.  First and foremost, it’s important that a certain set
/// of properties will always yield a cell renderer of the same size,
/// barring a `GtkStyle` change.  The `GtkCellRenderer` also has a number of
/// generic properties that are expected to be honored by all children.
/// 
/// Beyond merely rendering a cell, cell renderers can optionally
/// provide active user interface elements. A cell renderer can be
/// “activatable” like `GtkCellRendererToggle`,
/// which toggles when it gets activated by a mouse click, or it can be
/// “editable” like `GtkCellRendererText`, which
/// allows the user to edit the text using a widget implementing the
/// `GtkCellEditable` interface, e.g. `GtkEntry`.
/// To make a cell renderer activatable or editable, you have to
/// implement the `GtkCellRendererClass.activate` or
/// `GtkCellRendererClass.start_editing` virtual functions, respectively.
/// 
/// Many properties of `GtkCellRenderer` and its subclasses have a
/// corresponding “set” property, e.g. “cell-background-set” corresponds
/// to “cell-background”. These “set” properties reflect whether a property
/// has been set or not. You should not set them independently.
public protocol CellRendererProtocol: InitiallyUnownedProtocol {
    /// Untyped pointer to the underlying `GtkCellRenderer` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkCellRenderer` instance.
    var cell_renderer_ptr: UnsafeMutablePointer<GtkCellRenderer> { get }
}

/// The `CellRendererRef` type acts as a lightweight Swift reference to an underlying `GtkCellRenderer` instance.
/// It exposes methods that can operate on this data type through `CellRendererProtocol` conformance.
/// Use `CellRendererRef` only as an `unowned` reference to an existing `GtkCellRenderer` instance.
///
/// The `GtkCellRenderer` is a base class of a set of objects used for
/// rendering a cell to a `cairo_t`.  These objects are used primarily by
/// the `GtkTreeView` widget, though they aren’t tied to them in any
/// specific way.  It is worth noting that `GtkCellRenderer` is not a
/// `GtkWidget` and cannot be treated as such.
/// 
/// The primary use of a `GtkCellRenderer` is for drawing a certain graphical
/// elements on a `cairo_t`. Typically, one cell renderer is used to
/// draw many cells on the screen.  To this extent, it isn’t expected that a
/// CellRenderer keep any permanent state around.  Instead, any state is set
/// just prior to use using `GObjects` property system.  Then, the
/// cell is measured using `gtk_cell_renderer_get_size()`. Finally, the cell
/// is rendered in the correct location using `gtk_cell_renderer_render()`.
/// 
/// There are a number of rules that must be followed when writing a new
/// `GtkCellRenderer`.  First and foremost, it’s important that a certain set
/// of properties will always yield a cell renderer of the same size,
/// barring a `GtkStyle` change.  The `GtkCellRenderer` also has a number of
/// generic properties that are expected to be honored by all children.
/// 
/// Beyond merely rendering a cell, cell renderers can optionally
/// provide active user interface elements. A cell renderer can be
/// “activatable” like `GtkCellRendererToggle`,
/// which toggles when it gets activated by a mouse click, or it can be
/// “editable” like `GtkCellRendererText`, which
/// allows the user to edit the text using a widget implementing the
/// `GtkCellEditable` interface, e.g. `GtkEntry`.
/// To make a cell renderer activatable or editable, you have to
/// implement the `GtkCellRendererClass.activate` or
/// `GtkCellRendererClass.start_editing` virtual functions, respectively.
/// 
/// Many properties of `GtkCellRenderer` and its subclasses have a
/// corresponding “set” property, e.g. “cell-background-set” corresponds
/// to “cell-background”. These “set” properties reflect whether a property
/// has been set or not. You should not set them independently.
public struct CellRendererRef: CellRendererProtocol {
    /// Untyped pointer to the underlying `GtkCellRenderer` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension CellRendererRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkCellRenderer>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `CellRendererProtocol`
    init<T: CellRendererProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `CellRenderer` type acts as a reference-counted owner of an underlying `GtkCellRenderer` instance.
/// It provides the methods that can operate on this data type through `CellRendererProtocol` conformance.
/// Use `CellRenderer` as a strong reference or owner of a `GtkCellRenderer` instance.
///
/// The `GtkCellRenderer` is a base class of a set of objects used for
/// rendering a cell to a `cairo_t`.  These objects are used primarily by
/// the `GtkTreeView` widget, though they aren’t tied to them in any
/// specific way.  It is worth noting that `GtkCellRenderer` is not a
/// `GtkWidget` and cannot be treated as such.
/// 
/// The primary use of a `GtkCellRenderer` is for drawing a certain graphical
/// elements on a `cairo_t`. Typically, one cell renderer is used to
/// draw many cells on the screen.  To this extent, it isn’t expected that a
/// CellRenderer keep any permanent state around.  Instead, any state is set
/// just prior to use using `GObjects` property system.  Then, the
/// cell is measured using `gtk_cell_renderer_get_size()`. Finally, the cell
/// is rendered in the correct location using `gtk_cell_renderer_render()`.
/// 
/// There are a number of rules that must be followed when writing a new
/// `GtkCellRenderer`.  First and foremost, it’s important that a certain set
/// of properties will always yield a cell renderer of the same size,
/// barring a `GtkStyle` change.  The `GtkCellRenderer` also has a number of
/// generic properties that are expected to be honored by all children.
/// 
/// Beyond merely rendering a cell, cell renderers can optionally
/// provide active user interface elements. A cell renderer can be
/// “activatable” like `GtkCellRendererToggle`,
/// which toggles when it gets activated by a mouse click, or it can be
/// “editable” like `GtkCellRendererText`, which
/// allows the user to edit the text using a widget implementing the
/// `GtkCellEditable` interface, e.g. `GtkEntry`.
/// To make a cell renderer activatable or editable, you have to
/// implement the `GtkCellRendererClass.activate` or
/// `GtkCellRendererClass.start_editing` virtual functions, respectively.
/// 
/// Many properties of `GtkCellRenderer` and its subclasses have a
/// corresponding “set” property, e.g. “cell-background-set” corresponds
/// to “cell-background”. These “set” properties reflect whether a property
/// has been set or not. You should not set them independently.
open class CellRenderer: InitiallyUnowned, CellRendererProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `CellRenderer` instance.
    public init(_ op: UnsafeMutablePointer<GtkCellRenderer>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `CellRendererProtocol`
    /// Will retain `GtkCellRenderer`.
    public convenience init<T: CellRendererProtocol>(_ other: T) {
        self.init(cast(other.cell_renderer_ptr))
        g_object_ref(cast(cell_renderer_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkCellRenderer.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkCellRenderer.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkCellRenderer.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkCellRenderer>(opaquePointer))
    }



}

public enum CellRendererPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkColor`
    ///
    /// **cell-background-gdk is deprecated:**
    /// Use #GtkCellRenderer:cell-background-rgba instead.
    case cellBackgroundGdk = "cell-background-gdk"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRGBA = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editing = "editing"
    case height = "height"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case mode = "mode"
    case sensitive = "sensitive"
    case visible = "visible"
    case width = "width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererProtocol {
    /// Bind a `CellRendererPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(cell_renderer_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum CellRendererSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK+ doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const gchar     *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkColor`
    ///
    /// **cell-background-gdk is deprecated:**
    /// Use #GtkCellRenderer:cell-background-rgba instead.
    case notifyCellBackgroundGdk = "notify::cell-background-gdk"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRGBA = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditing = "notify::editing"
    case notifyHeight = "notify::height"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyMode = "notify::mode"
    case notifySensitive = "notify::sensitive"
    case notifyVisible = "notify::visible"
    case notifyWidth = "notify::width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

public extension CellRendererProtocol {
    /// Connect a `CellRendererSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: CellRendererSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(cell_renderer_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension CellRendererProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRenderer` instance.
    var cell_renderer_ptr: UnsafeMutablePointer<GtkCellRenderer> { return ptr.assumingMemoryBound(to: GtkCellRenderer.self) }

    /// Passes an activate event to the cell renderer for possible processing.
    /// Some cell renderers may use events; for example, `GtkCellRendererToggle`
    /// toggles when it gets a mouse click.
    func activate(event: UnsafeMutablePointer<GdkEvent>, widget: WidgetProtocol, path: UnsafePointer<gchar>, backgroundArea background_area: Gdk.RectangleProtocol, cellArea cell_area: Gdk.RectangleProtocol, flags: CellRendererState) -> Bool {
        let rv = gtk_cell_renderer_activate(cast(cell_renderer_ptr), cast(event), cast(widget.ptr), path, cast(background_area.ptr), cast(cell_area.ptr), flags)
        return Bool(rv != 0)
    }

    /// Gets the aligned area used by `cell` inside `cell_area`. Used for finding
    /// the appropriate edit and focus rectangle.
    func getAlignedArea(widget: WidgetProtocol, flags: CellRendererState, cellArea cell_area: Gdk.RectangleProtocol, alignedArea aligned_area: Gdk.RectangleProtocol) {
        gtk_cell_renderer_get_aligned_area(cast(cell_renderer_ptr), cast(widget.ptr), flags, cast(cell_area.ptr), cast(aligned_area.ptr))
    
    }

    /// Fills in `xalign` and `yalign` with the appropriate values of `cell`.
    func getAlignment(xalign: UnsafeMutablePointer<gfloat>, yalign: UnsafeMutablePointer<gfloat>) {
        gtk_cell_renderer_get_alignment(cast(cell_renderer_ptr), cast(xalign), cast(yalign))
    
    }

    /// Fills in `width` and `height` with the appropriate size of `cell`.
    func getFixedSize(width: UnsafeMutablePointer<CInt>, height: UnsafeMutablePointer<CInt>) {
        gtk_cell_renderer_get_fixed_size(cast(cell_renderer_ptr), cast(width), cast(height))
    
    }

    /// Fills in `xpad` and `ypad` with the appropriate values of `cell`.
    func getPadding(xpad: UnsafeMutablePointer<CInt>, ypad: UnsafeMutablePointer<CInt>) {
        gtk_cell_renderer_get_padding(cast(cell_renderer_ptr), cast(xpad), cast(ypad))
    
    }

    /// Retreives a renderer’s natural size when rendered to `widget`.
    func getPreferredHeight(widget: WidgetProtocol, minimumSize minimum_size: UnsafeMutablePointer<CInt>, naturalSize natural_size: UnsafeMutablePointer<CInt>) {
        gtk_cell_renderer_get_preferred_height(cast(cell_renderer_ptr), cast(widget.ptr), cast(minimum_size), cast(natural_size))
    
    }

    /// Retreives a cell renderers’s minimum and natural height if it were rendered to
    /// `widget` with the specified `width`.
    func getPreferredHeightForWidth(widget: WidgetProtocol, width: CInt, minimumHeight minimum_height: UnsafeMutablePointer<CInt>, naturalHeight natural_height: UnsafeMutablePointer<CInt>) {
        gtk_cell_renderer_get_preferred_height_for_width(cast(cell_renderer_ptr), cast(widget.ptr), gint(width), cast(minimum_height), cast(natural_height))
    
    }

    /// Retrieves the minimum and natural size of a cell taking
    /// into account the widget’s preference for height-for-width management.
    func getPreferredSize(widget: WidgetProtocol, minimumSize minimum_size: RequisitionProtocol, naturalSize natural_size: RequisitionProtocol) {
        gtk_cell_renderer_get_preferred_size(cast(cell_renderer_ptr), cast(widget.ptr), cast(minimum_size.ptr), cast(natural_size.ptr))
    
    }

    /// Retreives a renderer’s natural size when rendered to `widget`.
    func getPreferredWidth(widget: WidgetProtocol, minimumSize minimum_size: UnsafeMutablePointer<CInt>, naturalSize natural_size: UnsafeMutablePointer<CInt>) {
        gtk_cell_renderer_get_preferred_width(cast(cell_renderer_ptr), cast(widget.ptr), cast(minimum_size), cast(natural_size))
    
    }

    /// Retreives a cell renderers’s minimum and natural width if it were rendered to
    /// `widget` with the specified `height`.
    func getPreferredWidthForHeight(widget: WidgetProtocol, height: CInt, minimumWidth minimum_width: UnsafeMutablePointer<CInt>, naturalWidth natural_width: UnsafeMutablePointer<CInt>) {
        gtk_cell_renderer_get_preferred_width_for_height(cast(cell_renderer_ptr), cast(widget.ptr), gint(height), cast(minimum_width), cast(natural_width))
    
    }

    /// Gets whether the cell renderer prefers a height-for-width layout
    /// or a width-for-height layout.
    func getRequestMode() -> GtkSizeRequestMode {
        let rv = gtk_cell_renderer_get_request_mode(cast(cell_renderer_ptr))
        return rv
    }

    /// Returns the cell renderer’s sensitivity.
    func getSensitive() -> Bool {
        let rv = gtk_cell_renderer_get_sensitive(cast(cell_renderer_ptr))
        return Bool(rv != 0)
    }

    /// Obtains the width and height needed to render the cell. Used by view
    /// widgets to determine the appropriate size for the cell_area passed to
    /// `gtk_cell_renderer_render()`.  If `cell_area` is not `nil`, fills in the
    /// x and y offsets (if set) of the cell relative to this location.
    /// 
    /// Please note that the values set in `width` and `height`, as well as those
    /// in `x_offset` and `y_offset` are inclusive of the xpad and ypad properties.
    ///
    /// **get_size is deprecated:**
    /// Use gtk_cell_renderer_get_preferred_size() instead.
    @available(*, deprecated) func getSize(widget: WidgetProtocol, cellArea cell_area: Gdk.RectangleProtocol, xOffset x_offset: UnsafeMutablePointer<CInt>, yOffset y_offset: UnsafeMutablePointer<CInt>, width: UnsafeMutablePointer<CInt>, height: UnsafeMutablePointer<CInt>) {
        gtk_cell_renderer_get_size(cast(cell_renderer_ptr), cast(widget.ptr), cast(cell_area.ptr), cast(x_offset), cast(y_offset), cast(width), cast(height))
    
    }

    /// Translates the cell renderer state to `GtkStateFlags`,
    /// based on the cell renderer and widget sensitivity, and
    /// the given `GtkCellRendererState`.
    func getState(widget: WidgetProtocol, cellState cell_state: CellRendererState) -> GtkStateFlags {
        let rv = gtk_cell_renderer_get_state(cast(cell_renderer_ptr), cast(widget.ptr), cell_state)
        return rv
    }

    /// Returns the cell renderer’s visibility.
    func getVisible() -> Bool {
        let rv = gtk_cell_renderer_get_visible(cast(cell_renderer_ptr))
        return Bool(rv != 0)
    }

    /// Invokes the virtual render function of the `GtkCellRenderer`. The three
    /// passed-in rectangles are areas in `cr`. Most renderers will draw within
    /// `cell_area`; the xalign, yalign, xpad, and ypad fields of the `GtkCellRenderer`
    /// should be honored with respect to `cell_area`. `background_area` includes the
    /// blank space around the cell, and also the area containing the tree expander;
    /// so the `background_area` rectangles for all cells tile to cover the entire
    /// `window`.
    func render(cr: cairo.ContextProtocol, widget: WidgetProtocol, backgroundArea background_area: Gdk.RectangleProtocol, cellArea cell_area: Gdk.RectangleProtocol, flags: CellRendererState) {
        gtk_cell_renderer_render(cast(cell_renderer_ptr), cast(cr.ptr), cast(widget.ptr), cast(background_area.ptr), cast(cell_area.ptr), flags)
    
    }

    /// Sets the renderer’s alignment within its available space.
    func setAlignment(xalign: gfloat, yalign: gfloat) {
        gtk_cell_renderer_set_alignment(cast(cell_renderer_ptr), xalign, yalign)
    
    }

    /// Sets the renderer size to be explicit, independent of the properties set.
    func setFixedSize(width: CInt, height: CInt) {
        gtk_cell_renderer_set_fixed_size(cast(cell_renderer_ptr), gint(width), gint(height))
    
    }

    /// Sets the renderer’s padding.
    func setPadding(xpad: CInt, ypad: CInt) {
        gtk_cell_renderer_set_padding(cast(cell_renderer_ptr), gint(xpad), gint(ypad))
    
    }

    /// Sets the cell renderer’s sensitivity.
    func set(sensitive: Bool) {
        gtk_cell_renderer_set_sensitive(cast(cell_renderer_ptr), gboolean(sensitive ? 1 : 0))
    
    }

    /// Sets the cell renderer’s visibility.
    func set(visible: Bool) {
        gtk_cell_renderer_set_visible(cast(cell_renderer_ptr), gboolean(visible ? 1 : 0))
    
    }

    /// Starts editing the contents of this `cell`, through a new `GtkCellEditable`
    /// widget created by the `GtkCellRendererClass.start_editing` virtual function.
    func startEditing(event: UnsafeMutablePointer<GdkEvent>, widget: WidgetProtocol, path: UnsafePointer<gchar>, backgroundArea background_area: Gdk.RectangleProtocol, cellArea cell_area: Gdk.RectangleProtocol, flags: CellRendererState) -> UnsafeMutablePointer<GtkCellEditable>! {
        let rv = gtk_cell_renderer_start_editing(cast(cell_renderer_ptr), cast(event), cast(widget.ptr), path, cast(background_area.ptr), cast(cell_area.ptr), flags)
        return cast(rv)
    }

    /// Informs the cell renderer that the editing is stopped.
    /// If `canceled` is `true`, the cell renderer will emit the
    /// `GtkCellRenderer::editing`-canceled signal.
    /// 
    /// This function should be called by cell renderer implementations
    /// in response to the `GtkCellEditable::editing`-done signal of
    /// `GtkCellEditable`.
    func stopEditing(canceled: Bool) {
        gtk_cell_renderer_stop_editing(cast(cell_renderer_ptr), gboolean(canceled ? 1 : 0))
    
    }
    /// Checks whether the cell renderer can do something when activated.
    var isActivatable: Bool {
        /// Checks whether the cell renderer can do something when activated.
        get {
            let rv = gtk_cell_renderer_is_activatable(cast(cell_renderer_ptr))
            return Bool(rv != 0)
        }
    }

    /// Gets whether the cell renderer prefers a height-for-width layout
    /// or a width-for-height layout.
    var requestMode: GtkSizeRequestMode {
        /// Gets whether the cell renderer prefers a height-for-width layout
        /// or a width-for-height layout.
        get {
            let rv = gtk_cell_renderer_get_request_mode(cast(cell_renderer_ptr))
            return rv
        }
    }

    var sensitive: Bool {
        /// Returns the cell renderer’s sensitivity.
        get {
            let rv = gtk_cell_renderer_get_sensitive(cast(cell_renderer_ptr))
            return Bool(rv != 0)
        }
        /// Sets the cell renderer’s sensitivity.
        nonmutating set {
            gtk_cell_renderer_set_sensitive(cast(cell_renderer_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    var visible: Bool {
        /// Returns the cell renderer’s visibility.
        get {
            let rv = gtk_cell_renderer_get_visible(cast(cell_renderer_ptr))
            return Bool(rv != 0)
        }
        /// Sets the cell renderer’s visibility.
        nonmutating set {
            gtk_cell_renderer_set_visible(cast(cell_renderer_ptr), gboolean(newValue ? 1 : 0))
        }
    }
}



// MARK: - CellRendererAccel Class

/// The `CellRendererAccelProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererAccel` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererAccel`.
/// Alternatively, use `CellRendererAccelRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkCellRendererAccel` displays a keyboard accelerator (i.e. a key
/// combination like `Control + a`). If the cell renderer is editable,
/// the accelerator can be changed by simply typing the new combination.
/// 
/// The `GtkCellRendererAccel` cell renderer was added in GTK+ 2.10.
public protocol CellRendererAccelProtocol: CellRendererTextProtocol {
    /// Untyped pointer to the underlying `GtkCellRendererAccel` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkCellRendererAccel` instance.
    var cell_renderer_accel_ptr: UnsafeMutablePointer<GtkCellRendererAccel> { get }
}

/// The `CellRendererAccelRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererAccel` instance.
/// It exposes methods that can operate on this data type through `CellRendererAccelProtocol` conformance.
/// Use `CellRendererAccelRef` only as an `unowned` reference to an existing `GtkCellRendererAccel` instance.
///
/// `GtkCellRendererAccel` displays a keyboard accelerator (i.e. a key
/// combination like `Control + a`). If the cell renderer is editable,
/// the accelerator can be changed by simply typing the new combination.
/// 
/// The `GtkCellRendererAccel` cell renderer was added in GTK+ 2.10.
public struct CellRendererAccelRef: CellRendererAccelProtocol {
    /// Untyped pointer to the underlying `GtkCellRendererAccel` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_accel_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension CellRendererAccelRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkCellRendererAccel>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `CellRendererAccelProtocol`
    init<T: CellRendererAccelProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererAccel`.
    init() {
        let rv = gtk_cell_renderer_accel_new()
        self.init(cast(rv))
    }
}

/// The `CellRendererAccel` type acts as a reference-counted owner of an underlying `GtkCellRendererAccel` instance.
/// It provides the methods that can operate on this data type through `CellRendererAccelProtocol` conformance.
/// Use `CellRendererAccel` as a strong reference or owner of a `GtkCellRendererAccel` instance.
///
/// `GtkCellRendererAccel` displays a keyboard accelerator (i.e. a key
/// combination like `Control + a`). If the cell renderer is editable,
/// the accelerator can be changed by simply typing the new combination.
/// 
/// The `GtkCellRendererAccel` cell renderer was added in GTK+ 2.10.
open class CellRendererAccel: CellRendererText, CellRendererAccelProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `CellRendererAccel` instance.
    public init(_ op: UnsafeMutablePointer<GtkCellRendererAccel>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `CellRendererAccelProtocol`
    /// Will retain `GtkCellRendererAccel`.
    public convenience init<T: CellRendererAccelProtocol>(_ other: T) {
        self.init(cast(other.cell_renderer_accel_ptr))
        g_object_ref(cast(cell_renderer_accel_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkCellRendererAccel.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkCellRendererAccel.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkCellRendererAccel.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkCellRendererAccel>(opaquePointer))
    }

    /// Creates a new `GtkCellRendererAccel`.
    public convenience init() {
        let rv = gtk_cell_renderer_accel_new()
        self.init(cast(rv))
    }


}

public enum CellRendererAccelPropertyName: String, PropertyNameProtocol {
    /// The keyval of the accelerator.
    case accelKey = "accel-key"
    /// Determines if the edited accelerators are GTK+ accelerators. If
    /// they are, consumed modifiers are suppressed, only accelerators
    /// accepted by GTK+ are allowed, and the accelerators are rendered
    /// in the same way as they are in menus.
    case accelMode = "accel-mode"
    /// The modifier mask of the accelerator.
    case accelMods = "accel-mods"
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case alignSet = "align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case alignment = "alignment"
    case attributes = "attributes"
    case background = "background"
    /// Background color as a `GdkColor`
    ///
    /// **background-gdk is deprecated:**
    /// Use #GtkCellRendererText:background-rgba instead.
    case backgroundGdk = "background-gdk"
    /// Background color as a `GdkRGBA`
    case backgroundRGBA = "background-rgba"
    case backgroundSet = "background-set"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkColor`
    ///
    /// **cell-background-gdk is deprecated:**
    /// Use #GtkCellRenderer:cell-background-rgba instead.
    case cellBackgroundGdk = "cell-background-gdk"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRGBA = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editable = "editable"
    case editableSet = "editable-set"
    case editing = "editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case ellipsize = "ellipsize"
    case ellipsizeSet = "ellipsize-set"
    case family = "family"
    case familySet = "family-set"
    case font = "font"
    case fontDesc = "font-desc"
    case foreground = "foreground"
    /// Foreground color as a `GdkColor`
    ///
    /// **foreground-gdk is deprecated:**
    /// Use #GtkCellRendererText:foreground-rgba instead.
    case foregroundGdk = "foreground-gdk"
    /// Foreground color as a `GdkRGBA`
    case foregroundRGBA = "foreground-rgba"
    case foregroundSet = "foreground-set"
    case height = "height"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    /// The hardware keycode of the accelerator. Note that the hardware keycode is
    /// only relevant if the key does not have a keyval. Normally, the keyboard
    /// configuration should assign keyvals to all keys.
    case keycode = "keycode"
    case language = "language"
    case languageSet = "language-set"
    case markup = "markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case maxWidthChars = "max-width-chars"
    case mode = "mode"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    /// 
    /// Since 3.6
    case placeholderText = "placeholder-text"
    case rise = "rise"
    case riseSet = "rise-set"
    case scale = "scale"
    case scaleSet = "scale-set"
    case sensitive = "sensitive"
    case singleParagraphMode = "single-paragraph-mode"
    case size = "size"
    case sizePoints = "size-points"
    case sizeSet = "size-set"
    case stretch = "stretch"
    case stretchSet = "stretch-set"
    case strikethrough = "strikethrough"
    case strikethroughSet = "strikethrough-set"
    case style = "style"
    case styleSet = "style-set"
    case text = "text"
    case underline = "underline"
    case underlineSet = "underline-set"
    case variant = "variant"
    case variantSet = "variant-set"
    case visible = "visible"
    case weight = "weight"
    case weightSet = "weight-set"
    case width = "width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case widthChars = "width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case wrapMode = "wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case wrapWidth = "wrap-width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererAccelProtocol {
    /// Bind a `CellRendererAccelPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererAccelPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(cell_renderer_accel_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum CellRendererAccelSignalName: String, SignalNameProtocol {
    /// Gets emitted when the user has removed the accelerator.
    case accelCleared = "accel-cleared"
    /// Gets emitted when the user has selected a new accelerator.
    case accelEdited = "accel-edited"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// This signal is emitted after `renderer` has been edited.
    /// 
    /// It is the responsibility of the application to update the model
    /// and store `new_text` at the position indicated by `path`.
    case edited = "edited"
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK+ doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const gchar     *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    /// The keyval of the accelerator.
    case notifyAccelKey = "notify::accel-key"
    /// Determines if the edited accelerators are GTK+ accelerators. If
    /// they are, consumed modifiers are suppressed, only accelerators
    /// accepted by GTK+ are allowed, and the accelerators are rendered
    /// in the same way as they are in menus.
    case notifyAccelMode = "notify::accel-mode"
    /// The modifier mask of the accelerator.
    case notifyAccelMods = "notify::accel-mods"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyAlignSet = "notify::align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case notifyAlignment = "notify::alignment"
    case notifyAttributes = "notify::attributes"
    case notifyBackground = "notify::background"
    /// Background color as a `GdkColor`
    ///
    /// **background-gdk is deprecated:**
    /// Use #GtkCellRendererText:background-rgba instead.
    case notifyBackgroundGdk = "notify::background-gdk"
    /// Background color as a `GdkRGBA`
    case notifyBackgroundRGBA = "notify::background-rgba"
    case notifyBackgroundSet = "notify::background-set"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkColor`
    ///
    /// **cell-background-gdk is deprecated:**
    /// Use #GtkCellRenderer:cell-background-rgba instead.
    case notifyCellBackgroundGdk = "notify::cell-background-gdk"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRGBA = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditable = "notify::editable"
    case notifyEditableSet = "notify::editable-set"
    case notifyEditing = "notify::editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case notifyEllipsize = "notify::ellipsize"
    case notifyEllipsizeSet = "notify::ellipsize-set"
    case notifyFamily = "notify::family"
    case notifyFamilySet = "notify::family-set"
    case notifyFont = "notify::font"
    case notifyFontDesc = "notify::font-desc"
    case notifyForeground = "notify::foreground"
    /// Foreground color as a `GdkColor`
    ///
    /// **foreground-gdk is deprecated:**
    /// Use #GtkCellRendererText:foreground-rgba instead.
    case notifyForegroundGdk = "notify::foreground-gdk"
    /// Foreground color as a `GdkRGBA`
    case notifyForegroundRGBA = "notify::foreground-rgba"
    case notifyForegroundSet = "notify::foreground-set"
    case notifyHeight = "notify::height"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    /// The hardware keycode of the accelerator. Note that the hardware keycode is
    /// only relevant if the key does not have a keyval. Normally, the keyboard
    /// configuration should assign keyvals to all keys.
    case notifyKeycode = "notify::keycode"
    case notifyLanguage = "notify::language"
    case notifyLanguageSet = "notify::language-set"
    case notifyMarkup = "notify::markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case notifyMaxWidthChars = "notify::max-width-chars"
    case notifyMode = "notify::mode"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    /// 
    /// Since 3.6
    case notifyPlaceholderText = "notify::placeholder-text"
    case notifyRise = "notify::rise"
    case notifyRiseSet = "notify::rise-set"
    case notifyScale = "notify::scale"
    case notifyScaleSet = "notify::scale-set"
    case notifySensitive = "notify::sensitive"
    case notifySingleParagraphMode = "notify::single-paragraph-mode"
    case notifySize = "notify::size"
    case notifySizePoints = "notify::size-points"
    case notifySizeSet = "notify::size-set"
    case notifyStretch = "notify::stretch"
    case notifyStretchSet = "notify::stretch-set"
    case notifyStrikethrough = "notify::strikethrough"
    case notifyStrikethroughSet = "notify::strikethrough-set"
    case notifyStyle = "notify::style"
    case notifyStyleSet = "notify::style-set"
    case notifyText = "notify::text"
    case notifyUnderline = "notify::underline"
    case notifyUnderlineSet = "notify::underline-set"
    case notifyVariant = "notify::variant"
    case notifyVariantSet = "notify::variant-set"
    case notifyVisible = "notify::visible"
    case notifyWeight = "notify::weight"
    case notifyWeightSet = "notify::weight-set"
    case notifyWidth = "notify::width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case notifyWidthChars = "notify::width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case notifyWrapMode = "notify::wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case notifyWrapWidth = "notify::wrap-width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

public extension CellRendererAccelProtocol {
    /// Connect a `CellRendererAccelSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: CellRendererAccelSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(cell_renderer_accel_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension CellRendererAccelProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererAccel` instance.
    var cell_renderer_accel_ptr: UnsafeMutablePointer<GtkCellRendererAccel> { return ptr.assumingMemoryBound(to: GtkCellRendererAccel.self) }

}



// MARK: - CellRendererCombo Class

/// The `CellRendererComboProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererCombo` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererCombo`.
/// Alternatively, use `CellRendererComboRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkCellRendererCombo` renders text in a cell like `GtkCellRendererText` from
/// which it is derived. But while `GtkCellRendererText` offers a simple entry to
/// edit the text, `GtkCellRendererCombo` offers a `GtkComboBox`
/// widget to edit the text. The values to display in the combo box are taken from
/// the tree model specified in the `GtkCellRendererCombo:model` property.
/// 
/// The combo cell renderer takes care of adding a text cell renderer to the combo
/// box and sets it to display the column specified by its
/// `GtkCellRendererCombo:text`-column property. Further properties of the combo box
/// can be set in a handler for the `GtkCellRenderer::editing`-started signal.
/// 
/// The `GtkCellRendererCombo` cell renderer was added in GTK+ 2.6.
public protocol CellRendererComboProtocol: CellRendererTextProtocol {
    /// Untyped pointer to the underlying `GtkCellRendererCombo` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkCellRendererCombo` instance.
    var cell_renderer_combo_ptr: UnsafeMutablePointer<GtkCellRendererCombo> { get }
}

/// The `CellRendererComboRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererCombo` instance.
/// It exposes methods that can operate on this data type through `CellRendererComboProtocol` conformance.
/// Use `CellRendererComboRef` only as an `unowned` reference to an existing `GtkCellRendererCombo` instance.
///
/// `GtkCellRendererCombo` renders text in a cell like `GtkCellRendererText` from
/// which it is derived. But while `GtkCellRendererText` offers a simple entry to
/// edit the text, `GtkCellRendererCombo` offers a `GtkComboBox`
/// widget to edit the text. The values to display in the combo box are taken from
/// the tree model specified in the `GtkCellRendererCombo:model` property.
/// 
/// The combo cell renderer takes care of adding a text cell renderer to the combo
/// box and sets it to display the column specified by its
/// `GtkCellRendererCombo:text`-column property. Further properties of the combo box
/// can be set in a handler for the `GtkCellRenderer::editing`-started signal.
/// 
/// The `GtkCellRendererCombo` cell renderer was added in GTK+ 2.6.
public struct CellRendererComboRef: CellRendererComboProtocol {
    /// Untyped pointer to the underlying `GtkCellRendererCombo` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_combo_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension CellRendererComboRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkCellRendererCombo>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `CellRendererComboProtocol`
    init<T: CellRendererComboProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererCombo`.
    /// Adjust how text is drawn using object properties.
    /// Object properties can be set globally (with `g_object_set()`).
    /// Also, with `GtkTreeViewColumn`, you can bind a property to a value
    /// in a `GtkTreeModel`. For example, you can bind the “text” property
    /// on the cell renderer to a string value in the model, thus rendering
    /// a different string in each row of the `GtkTreeView`.
    init() {
        let rv = gtk_cell_renderer_combo_new()
        self.init(cast(rv))
    }
}

/// The `CellRendererCombo` type acts as a reference-counted owner of an underlying `GtkCellRendererCombo` instance.
/// It provides the methods that can operate on this data type through `CellRendererComboProtocol` conformance.
/// Use `CellRendererCombo` as a strong reference or owner of a `GtkCellRendererCombo` instance.
///
/// `GtkCellRendererCombo` renders text in a cell like `GtkCellRendererText` from
/// which it is derived. But while `GtkCellRendererText` offers a simple entry to
/// edit the text, `GtkCellRendererCombo` offers a `GtkComboBox`
/// widget to edit the text. The values to display in the combo box are taken from
/// the tree model specified in the `GtkCellRendererCombo:model` property.
/// 
/// The combo cell renderer takes care of adding a text cell renderer to the combo
/// box and sets it to display the column specified by its
/// `GtkCellRendererCombo:text`-column property. Further properties of the combo box
/// can be set in a handler for the `GtkCellRenderer::editing`-started signal.
/// 
/// The `GtkCellRendererCombo` cell renderer was added in GTK+ 2.6.
open class CellRendererCombo: CellRendererText, CellRendererComboProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `CellRendererCombo` instance.
    public init(_ op: UnsafeMutablePointer<GtkCellRendererCombo>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `CellRendererComboProtocol`
    /// Will retain `GtkCellRendererCombo`.
    public convenience init<T: CellRendererComboProtocol>(_ other: T) {
        self.init(cast(other.cell_renderer_combo_ptr))
        g_object_ref(cast(cell_renderer_combo_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkCellRendererCombo.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkCellRendererCombo.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkCellRendererCombo.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkCellRendererCombo>(opaquePointer))
    }

    /// Creates a new `GtkCellRendererCombo`.
    /// Adjust how text is drawn using object properties.
    /// Object properties can be set globally (with `g_object_set()`).
    /// Also, with `GtkTreeViewColumn`, you can bind a property to a value
    /// in a `GtkTreeModel`. For example, you can bind the “text” property
    /// on the cell renderer to a string value in the model, thus rendering
    /// a different string in each row of the `GtkTreeView`.
    public convenience init() {
        let rv = gtk_cell_renderer_combo_new()
        self.init(cast(rv))
    }


}

public enum CellRendererComboPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case alignSet = "align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case alignment = "alignment"
    case attributes = "attributes"
    case background = "background"
    /// Background color as a `GdkColor`
    ///
    /// **background-gdk is deprecated:**
    /// Use #GtkCellRendererText:background-rgba instead.
    case backgroundGdk = "background-gdk"
    /// Background color as a `GdkRGBA`
    case backgroundRGBA = "background-rgba"
    case backgroundSet = "background-set"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkColor`
    ///
    /// **cell-background-gdk is deprecated:**
    /// Use #GtkCellRenderer:cell-background-rgba instead.
    case cellBackgroundGdk = "cell-background-gdk"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRGBA = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editable = "editable"
    case editableSet = "editable-set"
    case editing = "editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case ellipsize = "ellipsize"
    case ellipsizeSet = "ellipsize-set"
    case family = "family"
    case familySet = "family-set"
    case font = "font"
    case fontDesc = "font-desc"
    case foreground = "foreground"
    /// Foreground color as a `GdkColor`
    ///
    /// **foreground-gdk is deprecated:**
    /// Use #GtkCellRendererText:foreground-rgba instead.
    case foregroundGdk = "foreground-gdk"
    /// Foreground color as a `GdkRGBA`
    case foregroundRGBA = "foreground-rgba"
    case foregroundSet = "foreground-set"
    /// If `true`, the cell renderer will include an entry and allow to enter
    /// values other than the ones in the popup list.
    case hasEntry = "has-entry"
    case height = "height"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case language = "language"
    case languageSet = "language-set"
    case markup = "markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case maxWidthChars = "max-width-chars"
    case mode = "mode"
    /// Holds a tree model containing the possible values for the combo box.
    /// Use the text_column property to specify the column holding the values.
    case model = "model"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    /// 
    /// Since 3.6
    case placeholderText = "placeholder-text"
    case rise = "rise"
    case riseSet = "rise-set"
    case scale = "scale"
    case scaleSet = "scale-set"
    case sensitive = "sensitive"
    case singleParagraphMode = "single-paragraph-mode"
    case size = "size"
    case sizePoints = "size-points"
    case sizeSet = "size-set"
    case stretch = "stretch"
    case stretchSet = "stretch-set"
    case strikethrough = "strikethrough"
    case strikethroughSet = "strikethrough-set"
    case style = "style"
    case styleSet = "style-set"
    case text = "text"
    /// Specifies the model column which holds the possible values for the
    /// combo box.
    /// 
    /// Note that this refers to the model specified in the model property,
    /// not the model backing the tree view to which
    /// this cell renderer is attached.
    /// 
    /// `GtkCellRendererCombo` automatically adds a text cell renderer for
    /// this column to its combo box.
    case textColumn = "text-column"
    case underline = "underline"
    case underlineSet = "underline-set"
    case variant = "variant"
    case variantSet = "variant-set"
    case visible = "visible"
    case weight = "weight"
    case weightSet = "weight-set"
    case width = "width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case widthChars = "width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case wrapMode = "wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case wrapWidth = "wrap-width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererComboProtocol {
    /// Bind a `CellRendererComboPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererComboPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(cell_renderer_combo_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum CellRendererComboSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// This signal is emitted each time after the user selected an item in
    /// the combo box, either by using the mouse or the arrow keys.  Contrary
    /// to GtkComboBox, GtkCellRendererCombo`changed` is not emitted for
    /// changes made to a selected item in the entry.  The argument `new_iter`
    /// corresponds to the newly selected item in the combo box and it is relative
    /// to the GtkTreeModel set via the model property on GtkCellRendererCombo.
    /// 
    /// Note that as soon as you change the model displayed in the tree view,
    /// the tree view will immediately cease the editing operating.  This
    /// means that you most probably want to refrain from changing the model
    /// until the combo cell renderer emits the edited or editing_canceled signal.
    case changed = "changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// This signal is emitted after `renderer` has been edited.
    /// 
    /// It is the responsibility of the application to update the model
    /// and store `new_text` at the position indicated by `path`.
    case edited = "edited"
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK+ doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const gchar     *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyAlignSet = "notify::align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case notifyAlignment = "notify::alignment"
    case notifyAttributes = "notify::attributes"
    case notifyBackground = "notify::background"
    /// Background color as a `GdkColor`
    ///
    /// **background-gdk is deprecated:**
    /// Use #GtkCellRendererText:background-rgba instead.
    case notifyBackgroundGdk = "notify::background-gdk"
    /// Background color as a `GdkRGBA`
    case notifyBackgroundRGBA = "notify::background-rgba"
    case notifyBackgroundSet = "notify::background-set"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkColor`
    ///
    /// **cell-background-gdk is deprecated:**
    /// Use #GtkCellRenderer:cell-background-rgba instead.
    case notifyCellBackgroundGdk = "notify::cell-background-gdk"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRGBA = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditable = "notify::editable"
    case notifyEditableSet = "notify::editable-set"
    case notifyEditing = "notify::editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case notifyEllipsize = "notify::ellipsize"
    case notifyEllipsizeSet = "notify::ellipsize-set"
    case notifyFamily = "notify::family"
    case notifyFamilySet = "notify::family-set"
    case notifyFont = "notify::font"
    case notifyFontDesc = "notify::font-desc"
    case notifyForeground = "notify::foreground"
    /// Foreground color as a `GdkColor`
    ///
    /// **foreground-gdk is deprecated:**
    /// Use #GtkCellRendererText:foreground-rgba instead.
    case notifyForegroundGdk = "notify::foreground-gdk"
    /// Foreground color as a `GdkRGBA`
    case notifyForegroundRGBA = "notify::foreground-rgba"
    case notifyForegroundSet = "notify::foreground-set"
    /// If `true`, the cell renderer will include an entry and allow to enter
    /// values other than the ones in the popup list.
    case notifyHasEntry = "notify::has-entry"
    case notifyHeight = "notify::height"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyLanguage = "notify::language"
    case notifyLanguageSet = "notify::language-set"
    case notifyMarkup = "notify::markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case notifyMaxWidthChars = "notify::max-width-chars"
    case notifyMode = "notify::mode"
    /// Holds a tree model containing the possible values for the combo box.
    /// Use the text_column property to specify the column holding the values.
    case notifyModel = "notify::model"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    /// 
    /// Since 3.6
    case notifyPlaceholderText = "notify::placeholder-text"
    case notifyRise = "notify::rise"
    case notifyRiseSet = "notify::rise-set"
    case notifyScale = "notify::scale"
    case notifyScaleSet = "notify::scale-set"
    case notifySensitive = "notify::sensitive"
    case notifySingleParagraphMode = "notify::single-paragraph-mode"
    case notifySize = "notify::size"
    case notifySizePoints = "notify::size-points"
    case notifySizeSet = "notify::size-set"
    case notifyStretch = "notify::stretch"
    case notifyStretchSet = "notify::stretch-set"
    case notifyStrikethrough = "notify::strikethrough"
    case notifyStrikethroughSet = "notify::strikethrough-set"
    case notifyStyle = "notify::style"
    case notifyStyleSet = "notify::style-set"
    case notifyText = "notify::text"
    /// Specifies the model column which holds the possible values for the
    /// combo box.
    /// 
    /// Note that this refers to the model specified in the model property,
    /// not the model backing the tree view to which
    /// this cell renderer is attached.
    /// 
    /// `GtkCellRendererCombo` automatically adds a text cell renderer for
    /// this column to its combo box.
    case notifyTextColumn = "notify::text-column"
    case notifyUnderline = "notify::underline"
    case notifyUnderlineSet = "notify::underline-set"
    case notifyVariant = "notify::variant"
    case notifyVariantSet = "notify::variant-set"
    case notifyVisible = "notify::visible"
    case notifyWeight = "notify::weight"
    case notifyWeightSet = "notify::weight-set"
    case notifyWidth = "notify::width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case notifyWidthChars = "notify::width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case notifyWrapMode = "notify::wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case notifyWrapWidth = "notify::wrap-width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

public extension CellRendererComboProtocol {
    /// Connect a `CellRendererComboSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: CellRendererComboSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(cell_renderer_combo_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension CellRendererComboProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererCombo` instance.
    var cell_renderer_combo_ptr: UnsafeMutablePointer<GtkCellRendererCombo> { return ptr.assumingMemoryBound(to: GtkCellRendererCombo.self) }

}



// MARK: - CellRendererPixbuf Class

/// The `CellRendererPixbufProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererPixbuf` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererPixbuf`.
/// Alternatively, use `CellRendererPixbufRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkCellRendererPixbuf` can be used to render an image in a cell. It allows
/// to render either a given `GdkPixbuf` (set via the
/// `GtkCellRendererPixbuf:pixbuf` property) or a named icon (set via the
/// `GtkCellRendererPixbuf:icon`-name property).
/// 
/// To support the tree view, `GtkCellRendererPixbuf` also supports rendering two
/// alternative pixbufs, when the `GtkCellRenderer:is`-expander property is `true`.
/// If the `GtkCellRenderer:is`-expanded property is `true` and the
/// `GtkCellRendererPixbuf:pixbuf`-expander-open property is set to a pixbuf, it
/// renders that pixbuf, if the `GtkCellRenderer:is`-expanded property is `false`
/// and the `GtkCellRendererPixbuf:pixbuf`-expander-closed property is set to a
/// pixbuf, it renders that one.
public protocol CellRendererPixbufProtocol: CellRendererProtocol {
    /// Untyped pointer to the underlying `GtkCellRendererPixbuf` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkCellRendererPixbuf` instance.
    var cell_renderer_pixbuf_ptr: UnsafeMutablePointer<GtkCellRendererPixbuf> { get }
}

/// The `CellRendererPixbufRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererPixbuf` instance.
/// It exposes methods that can operate on this data type through `CellRendererPixbufProtocol` conformance.
/// Use `CellRendererPixbufRef` only as an `unowned` reference to an existing `GtkCellRendererPixbuf` instance.
///
/// A `GtkCellRendererPixbuf` can be used to render an image in a cell. It allows
/// to render either a given `GdkPixbuf` (set via the
/// `GtkCellRendererPixbuf:pixbuf` property) or a named icon (set via the
/// `GtkCellRendererPixbuf:icon`-name property).
/// 
/// To support the tree view, `GtkCellRendererPixbuf` also supports rendering two
/// alternative pixbufs, when the `GtkCellRenderer:is`-expander property is `true`.
/// If the `GtkCellRenderer:is`-expanded property is `true` and the
/// `GtkCellRendererPixbuf:pixbuf`-expander-open property is set to a pixbuf, it
/// renders that pixbuf, if the `GtkCellRenderer:is`-expanded property is `false`
/// and the `GtkCellRendererPixbuf:pixbuf`-expander-closed property is set to a
/// pixbuf, it renders that one.
public struct CellRendererPixbufRef: CellRendererPixbufProtocol {
    /// Untyped pointer to the underlying `GtkCellRendererPixbuf` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_pixbuf_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension CellRendererPixbufRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkCellRendererPixbuf>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `CellRendererPixbufProtocol`
    init<T: CellRendererPixbufProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererPixbuf`. Adjust rendering
    /// parameters using object properties. Object properties can be set
    /// globally (with `g_object_set()`). Also, with `GtkTreeViewColumn`, you
    /// can bind a property to a value in a `GtkTreeModel`. For example, you
    /// can bind the “pixbuf” property on the cell renderer to a pixbuf value
    /// in the model, thus rendering a different image in each row of the
    /// `GtkTreeView`.
    init() {
        let rv = gtk_cell_renderer_pixbuf_new()
        self.init(cast(rv))
    }
}

/// The `CellRendererPixbuf` type acts as a reference-counted owner of an underlying `GtkCellRendererPixbuf` instance.
/// It provides the methods that can operate on this data type through `CellRendererPixbufProtocol` conformance.
/// Use `CellRendererPixbuf` as a strong reference or owner of a `GtkCellRendererPixbuf` instance.
///
/// A `GtkCellRendererPixbuf` can be used to render an image in a cell. It allows
/// to render either a given `GdkPixbuf` (set via the
/// `GtkCellRendererPixbuf:pixbuf` property) or a named icon (set via the
/// `GtkCellRendererPixbuf:icon`-name property).
/// 
/// To support the tree view, `GtkCellRendererPixbuf` also supports rendering two
/// alternative pixbufs, when the `GtkCellRenderer:is`-expander property is `true`.
/// If the `GtkCellRenderer:is`-expanded property is `true` and the
/// `GtkCellRendererPixbuf:pixbuf`-expander-open property is set to a pixbuf, it
/// renders that pixbuf, if the `GtkCellRenderer:is`-expanded property is `false`
/// and the `GtkCellRendererPixbuf:pixbuf`-expander-closed property is set to a
/// pixbuf, it renders that one.
open class CellRendererPixbuf: CellRenderer, CellRendererPixbufProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `CellRendererPixbuf` instance.
    public init(_ op: UnsafeMutablePointer<GtkCellRendererPixbuf>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `CellRendererPixbufProtocol`
    /// Will retain `GtkCellRendererPixbuf`.
    public convenience init<T: CellRendererPixbufProtocol>(_ other: T) {
        self.init(cast(other.cell_renderer_pixbuf_ptr))
        g_object_ref(cast(cell_renderer_pixbuf_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkCellRendererPixbuf.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkCellRendererPixbuf.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkCellRendererPixbuf.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkCellRendererPixbuf>(opaquePointer))
    }

    /// Creates a new `GtkCellRendererPixbuf`. Adjust rendering
    /// parameters using object properties. Object properties can be set
    /// globally (with `g_object_set()`). Also, with `GtkTreeViewColumn`, you
    /// can bind a property to a value in a `GtkTreeModel`. For example, you
    /// can bind the “pixbuf” property on the cell renderer to a pixbuf value
    /// in the model, thus rendering a different image in each row of the
    /// `GtkTreeView`.
    public convenience init() {
        let rv = gtk_cell_renderer_pixbuf_new()
        self.init(cast(rv))
    }


}

public enum CellRendererPixbufPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkColor`
    ///
    /// **cell-background-gdk is deprecated:**
    /// Use #GtkCellRenderer:cell-background-rgba instead.
    case cellBackgroundGdk = "cell-background-gdk"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRGBA = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editing = "editing"
    /// Specifies whether the rendered pixbuf should be colorized
    /// according to the `GtkCellRendererState`.
    ///
    /// **follow-state is deprecated:**
    /// Cell renderers always follow state.
    case followState = "follow-state"
    /// The GIcon representing the icon to display.
    /// If the icon theme is changed, the image will be updated
    /// automatically.
    case gicon = "gicon"
    case height = "height"
    /// The name of the themed icon to display.
    /// This property only has an effect if not overridden by "stock_id"
    /// or "pixbuf" properties.
    case iconName = "icon-name"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case mode = "mode"
    case pixbuf = "pixbuf"
    case pixbufExpanderClosed = "pixbuf-expander-closed"
    case pixbufExpanderOpen = "pixbuf-expander-open"
    case sensitive = "sensitive"
    case stockDetail = "stock-detail"

    ///
    /// **stock-id is deprecated:**
    /// Use #GtkCellRendererPixbuf:icon-name instead.
    case stockID = "stock-id"
    /// The `GtkIconSize` value that specifies the size of the rendered icon.
    case stockSize = "stock-size"
    case surface = "surface"
    case visible = "visible"
    case width = "width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererPixbufProtocol {
    /// Bind a `CellRendererPixbufPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererPixbufPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(cell_renderer_pixbuf_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum CellRendererPixbufSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK+ doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const gchar     *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkColor`
    ///
    /// **cell-background-gdk is deprecated:**
    /// Use #GtkCellRenderer:cell-background-rgba instead.
    case notifyCellBackgroundGdk = "notify::cell-background-gdk"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRGBA = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditing = "notify::editing"
    /// Specifies whether the rendered pixbuf should be colorized
    /// according to the `GtkCellRendererState`.
    ///
    /// **follow-state is deprecated:**
    /// Cell renderers always follow state.
    case notifyFollowState = "notify::follow-state"
    /// The GIcon representing the icon to display.
    /// If the icon theme is changed, the image will be updated
    /// automatically.
    case notifyIcon = "notify::gicon"
    case notifyHeight = "notify::height"
    /// The name of the themed icon to display.
    /// This property only has an effect if not overridden by "stock_id"
    /// or "pixbuf" properties.
    case notifyIconName = "notify::icon-name"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyMode = "notify::mode"
    case notifyPixbuf = "notify::pixbuf"
    case notifyPixbufExpanderClosed = "notify::pixbuf-expander-closed"
    case notifyPixbufExpanderOpen = "notify::pixbuf-expander-open"
    case notifySensitive = "notify::sensitive"
    case notifyStockDetail = "notify::stock-detail"

    ///
    /// **stock-id is deprecated:**
    /// Use #GtkCellRendererPixbuf:icon-name instead.
    case notifyStockID = "notify::stock-id"
    /// The `GtkIconSize` value that specifies the size of the rendered icon.
    case notifyStockSize = "notify::stock-size"
    case notifySurface = "notify::surface"
    case notifyVisible = "notify::visible"
    case notifyWidth = "notify::width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

public extension CellRendererPixbufProtocol {
    /// Connect a `CellRendererPixbufSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: CellRendererPixbufSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(cell_renderer_pixbuf_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension CellRendererPixbufProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererPixbuf` instance.
    var cell_renderer_pixbuf_ptr: UnsafeMutablePointer<GtkCellRendererPixbuf> { return ptr.assumingMemoryBound(to: GtkCellRendererPixbuf.self) }

}



// MARK: - CellRendererProgress Class

/// The `CellRendererProgressProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererProgress` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererProgress`.
/// Alternatively, use `CellRendererProgressRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkCellRendererProgress` renders a numeric value as a progress par in a cell.
/// Additionally, it can display a text on top of the progress bar.
/// 
/// The `GtkCellRendererProgress` cell renderer was added in GTK+ 2.6.
public protocol CellRendererProgressProtocol: CellRendererProtocol, OrientableProtocol {
    /// Untyped pointer to the underlying `GtkCellRendererProgress` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkCellRendererProgress` instance.
    var cell_renderer_progress_ptr: UnsafeMutablePointer<GtkCellRendererProgress> { get }
}

/// The `CellRendererProgressRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererProgress` instance.
/// It exposes methods that can operate on this data type through `CellRendererProgressProtocol` conformance.
/// Use `CellRendererProgressRef` only as an `unowned` reference to an existing `GtkCellRendererProgress` instance.
///
/// `GtkCellRendererProgress` renders a numeric value as a progress par in a cell.
/// Additionally, it can display a text on top of the progress bar.
/// 
/// The `GtkCellRendererProgress` cell renderer was added in GTK+ 2.6.
public struct CellRendererProgressRef: CellRendererProgressProtocol {
    /// Untyped pointer to the underlying `GtkCellRendererProgress` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_progress_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension CellRendererProgressRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkCellRendererProgress>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `CellRendererProgressProtocol`
    init<T: CellRendererProgressProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererProgress`.
    init() {
        let rv = gtk_cell_renderer_progress_new()
        self.init(cast(rv))
    }
}

/// The `CellRendererProgress` type acts as a reference-counted owner of an underlying `GtkCellRendererProgress` instance.
/// It provides the methods that can operate on this data type through `CellRendererProgressProtocol` conformance.
/// Use `CellRendererProgress` as a strong reference or owner of a `GtkCellRendererProgress` instance.
///
/// `GtkCellRendererProgress` renders a numeric value as a progress par in a cell.
/// Additionally, it can display a text on top of the progress bar.
/// 
/// The `GtkCellRendererProgress` cell renderer was added in GTK+ 2.6.
open class CellRendererProgress: CellRenderer, CellRendererProgressProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `CellRendererProgress` instance.
    public init(_ op: UnsafeMutablePointer<GtkCellRendererProgress>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `CellRendererProgressProtocol`
    /// Will retain `GtkCellRendererProgress`.
    public convenience init<T: CellRendererProgressProtocol>(_ other: T) {
        self.init(cast(other.cell_renderer_progress_ptr))
        g_object_ref(cast(cell_renderer_progress_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkCellRendererProgress.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkCellRendererProgress.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkCellRendererProgress.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkCellRendererProgress>(opaquePointer))
    }

    /// Creates a new `GtkCellRendererProgress`.
    public convenience init() {
        let rv = gtk_cell_renderer_progress_new()
        self.init(cast(rv))
    }


}

public enum CellRendererProgressPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkColor`
    ///
    /// **cell-background-gdk is deprecated:**
    /// Use #GtkCellRenderer:cell-background-rgba instead.
    case cellBackgroundGdk = "cell-background-gdk"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRGBA = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editing = "editing"
    case height = "height"
    case inverted = "inverted"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case mode = "mode"
    /// Setting this to a non-negative value causes the cell renderer to
    /// enter "activity mode", where a block bounces back and forth to
    /// indicate that some progress is made, without specifying exactly how
    /// much.
    /// 
    /// Each increment of the property causes the block to move by a little
    /// bit.
    /// 
    /// To indicate that the activity has not started yet, set the property
    /// to zero. To indicate completion, set the property to `G_MAXINT`.
    case pulse = "pulse"
    case sensitive = "sensitive"
    /// The "text" property determines the label which will be drawn
    /// over the progress bar. Setting this property to `nil` causes the default
    /// label to be displayed. Setting this property to an empty string causes
    /// no label to be displayed.
    case text = "text"
    /// The "text-xalign" property controls the horizontal alignment of the
    /// text in the progress bar.  Valid values range from 0 (left) to 1
    /// (right).  Reserved for RTL layouts.
    case textXalign = "text-xalign"
    /// The "text-yalign" property controls the vertical alignment of the
    /// text in the progress bar.  Valid values range from 0 (top) to 1
    /// (bottom).
    case textYalign = "text-yalign"
    /// The "value" property determines the percentage to which the
    /// progress bar will be "filled in".
    case value = "value"
    case visible = "visible"
    case width = "width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererProgressProtocol {
    /// Bind a `CellRendererProgressPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererProgressPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(cell_renderer_progress_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum CellRendererProgressSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK+ doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const gchar     *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkColor`
    ///
    /// **cell-background-gdk is deprecated:**
    /// Use #GtkCellRenderer:cell-background-rgba instead.
    case notifyCellBackgroundGdk = "notify::cell-background-gdk"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRGBA = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditing = "notify::editing"
    case notifyHeight = "notify::height"
    case notifyInverted = "notify::inverted"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyMode = "notify::mode"
    /// Setting this to a non-negative value causes the cell renderer to
    /// enter "activity mode", where a block bounces back and forth to
    /// indicate that some progress is made, without specifying exactly how
    /// much.
    /// 
    /// Each increment of the property causes the block to move by a little
    /// bit.
    /// 
    /// To indicate that the activity has not started yet, set the property
    /// to zero. To indicate completion, set the property to `G_MAXINT`.
    case notifyPulse = "notify::pulse"
    case notifySensitive = "notify::sensitive"
    /// The "text" property determines the label which will be drawn
    /// over the progress bar. Setting this property to `nil` causes the default
    /// label to be displayed. Setting this property to an empty string causes
    /// no label to be displayed.
    case notifyText = "notify::text"
    /// The "text-xalign" property controls the horizontal alignment of the
    /// text in the progress bar.  Valid values range from 0 (left) to 1
    /// (right).  Reserved for RTL layouts.
    case notifyTextXalign = "notify::text-xalign"
    /// The "text-yalign" property controls the vertical alignment of the
    /// text in the progress bar.  Valid values range from 0 (top) to 1
    /// (bottom).
    case notifyTextYalign = "notify::text-yalign"
    /// The "value" property determines the percentage to which the
    /// progress bar will be "filled in".
    case notifyValue = "notify::value"
    case notifyVisible = "notify::visible"
    case notifyWidth = "notify::width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

public extension CellRendererProgressProtocol {
    /// Connect a `CellRendererProgressSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: CellRendererProgressSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(cell_renderer_progress_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension CellRendererProgressProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererProgress` instance.
    var cell_renderer_progress_ptr: UnsafeMutablePointer<GtkCellRendererProgress> { return ptr.assumingMemoryBound(to: GtkCellRendererProgress.self) }

}



// MARK: - CellRendererSpin Class

/// The `CellRendererSpinProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererSpin` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererSpin`.
/// Alternatively, use `CellRendererSpinRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkCellRendererSpin` renders text in a cell like `GtkCellRendererText` from
/// which it is derived. But while `GtkCellRendererText` offers a simple entry to
/// edit the text, `GtkCellRendererSpin` offers a `GtkSpinButton` widget. Of course,
/// that means that the text has to be parseable as a floating point number.
/// 
/// The range of the spinbutton is taken from the adjustment property of the
/// cell renderer, which can be set explicitly or mapped to a column in the
/// tree model, like all properties of cell renders. `GtkCellRendererSpin`
/// also has properties for the `GtkCellRendererSpin:climb`-rate and the number
/// of `GtkCellRendererSpin:digits` to display. Other `GtkSpinButton` properties
/// can be set in a handler for the `GtkCellRenderer::editing`-started signal.
/// 
/// The `GtkCellRendererSpin` cell renderer was added in GTK+ 2.10.
public protocol CellRendererSpinProtocol: CellRendererTextProtocol {
    /// Untyped pointer to the underlying `GtkCellRendererSpin` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkCellRendererSpin` instance.
    var cell_renderer_spin_ptr: UnsafeMutablePointer<GtkCellRendererSpin> { get }
}

/// The `CellRendererSpinRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererSpin` instance.
/// It exposes methods that can operate on this data type through `CellRendererSpinProtocol` conformance.
/// Use `CellRendererSpinRef` only as an `unowned` reference to an existing `GtkCellRendererSpin` instance.
///
/// `GtkCellRendererSpin` renders text in a cell like `GtkCellRendererText` from
/// which it is derived. But while `GtkCellRendererText` offers a simple entry to
/// edit the text, `GtkCellRendererSpin` offers a `GtkSpinButton` widget. Of course,
/// that means that the text has to be parseable as a floating point number.
/// 
/// The range of the spinbutton is taken from the adjustment property of the
/// cell renderer, which can be set explicitly or mapped to a column in the
/// tree model, like all properties of cell renders. `GtkCellRendererSpin`
/// also has properties for the `GtkCellRendererSpin:climb`-rate and the number
/// of `GtkCellRendererSpin:digits` to display. Other `GtkSpinButton` properties
/// can be set in a handler for the `GtkCellRenderer::editing`-started signal.
/// 
/// The `GtkCellRendererSpin` cell renderer was added in GTK+ 2.10.
public struct CellRendererSpinRef: CellRendererSpinProtocol {
    /// Untyped pointer to the underlying `GtkCellRendererSpin` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_spin_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension CellRendererSpinRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkCellRendererSpin>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `CellRendererSpinProtocol`
    init<T: CellRendererSpinProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererSpin`.
    init() {
        let rv = gtk_cell_renderer_spin_new()
        self.init(cast(rv))
    }
}

/// The `CellRendererSpin` type acts as a reference-counted owner of an underlying `GtkCellRendererSpin` instance.
/// It provides the methods that can operate on this data type through `CellRendererSpinProtocol` conformance.
/// Use `CellRendererSpin` as a strong reference or owner of a `GtkCellRendererSpin` instance.
///
/// `GtkCellRendererSpin` renders text in a cell like `GtkCellRendererText` from
/// which it is derived. But while `GtkCellRendererText` offers a simple entry to
/// edit the text, `GtkCellRendererSpin` offers a `GtkSpinButton` widget. Of course,
/// that means that the text has to be parseable as a floating point number.
/// 
/// The range of the spinbutton is taken from the adjustment property of the
/// cell renderer, which can be set explicitly or mapped to a column in the
/// tree model, like all properties of cell renders. `GtkCellRendererSpin`
/// also has properties for the `GtkCellRendererSpin:climb`-rate and the number
/// of `GtkCellRendererSpin:digits` to display. Other `GtkSpinButton` properties
/// can be set in a handler for the `GtkCellRenderer::editing`-started signal.
/// 
/// The `GtkCellRendererSpin` cell renderer was added in GTK+ 2.10.
open class CellRendererSpin: CellRendererText, CellRendererSpinProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `CellRendererSpin` instance.
    public init(_ op: UnsafeMutablePointer<GtkCellRendererSpin>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `CellRendererSpinProtocol`
    /// Will retain `GtkCellRendererSpin`.
    public convenience init<T: CellRendererSpinProtocol>(_ other: T) {
        self.init(cast(other.cell_renderer_spin_ptr))
        g_object_ref(cast(cell_renderer_spin_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkCellRendererSpin.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkCellRendererSpin.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkCellRendererSpin.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkCellRendererSpin>(opaquePointer))
    }

    /// Creates a new `GtkCellRendererSpin`.
    public convenience init() {
        let rv = gtk_cell_renderer_spin_new()
        self.init(cast(rv))
    }


}

public enum CellRendererSpinPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    /// The adjustment that holds the value of the spinbutton.
    /// This must be non-`nil` for the cell renderer to be editable.
    case adjustment = "adjustment"
    case alignSet = "align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case alignment = "alignment"
    case attributes = "attributes"
    case background = "background"
    /// Background color as a `GdkColor`
    ///
    /// **background-gdk is deprecated:**
    /// Use #GtkCellRendererText:background-rgba instead.
    case backgroundGdk = "background-gdk"
    /// Background color as a `GdkRGBA`
    case backgroundRGBA = "background-rgba"
    case backgroundSet = "background-set"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkColor`
    ///
    /// **cell-background-gdk is deprecated:**
    /// Use #GtkCellRenderer:cell-background-rgba instead.
    case cellBackgroundGdk = "cell-background-gdk"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRGBA = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    /// The acceleration rate when you hold down a button.
    case climbRate = "climb-rate"
    /// The number of decimal places to display.
    case digits = "digits"
    case editable = "editable"
    case editableSet = "editable-set"
    case editing = "editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case ellipsize = "ellipsize"
    case ellipsizeSet = "ellipsize-set"
    case family = "family"
    case familySet = "family-set"
    case font = "font"
    case fontDesc = "font-desc"
    case foreground = "foreground"
    /// Foreground color as a `GdkColor`
    ///
    /// **foreground-gdk is deprecated:**
    /// Use #GtkCellRendererText:foreground-rgba instead.
    case foregroundGdk = "foreground-gdk"
    /// Foreground color as a `GdkRGBA`
    case foregroundRGBA = "foreground-rgba"
    case foregroundSet = "foreground-set"
    case height = "height"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case language = "language"
    case languageSet = "language-set"
    case markup = "markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case maxWidthChars = "max-width-chars"
    case mode = "mode"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    /// 
    /// Since 3.6
    case placeholderText = "placeholder-text"
    case rise = "rise"
    case riseSet = "rise-set"
    case scale = "scale"
    case scaleSet = "scale-set"
    case sensitive = "sensitive"
    case singleParagraphMode = "single-paragraph-mode"
    case size = "size"
    case sizePoints = "size-points"
    case sizeSet = "size-set"
    case stretch = "stretch"
    case stretchSet = "stretch-set"
    case strikethrough = "strikethrough"
    case strikethroughSet = "strikethrough-set"
    case style = "style"
    case styleSet = "style-set"
    case text = "text"
    case underline = "underline"
    case underlineSet = "underline-set"
    case variant = "variant"
    case variantSet = "variant-set"
    case visible = "visible"
    case weight = "weight"
    case weightSet = "weight-set"
    case width = "width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case widthChars = "width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case wrapMode = "wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case wrapWidth = "wrap-width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererSpinProtocol {
    /// Bind a `CellRendererSpinPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererSpinPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(cell_renderer_spin_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum CellRendererSpinSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// This signal is emitted after `renderer` has been edited.
    /// 
    /// It is the responsibility of the application to update the model
    /// and store `new_text` at the position indicated by `path`.
    case edited = "edited"
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK+ doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const gchar     *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    /// The adjustment that holds the value of the spinbutton.
    /// This must be non-`nil` for the cell renderer to be editable.
    case notifyAdjustment = "notify::adjustment"
    case notifyAlignSet = "notify::align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case notifyAlignment = "notify::alignment"
    case notifyAttributes = "notify::attributes"
    case notifyBackground = "notify::background"
    /// Background color as a `GdkColor`
    ///
    /// **background-gdk is deprecated:**
    /// Use #GtkCellRendererText:background-rgba instead.
    case notifyBackgroundGdk = "notify::background-gdk"
    /// Background color as a `GdkRGBA`
    case notifyBackgroundRGBA = "notify::background-rgba"
    case notifyBackgroundSet = "notify::background-set"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkColor`
    ///
    /// **cell-background-gdk is deprecated:**
    /// Use #GtkCellRenderer:cell-background-rgba instead.
    case notifyCellBackgroundGdk = "notify::cell-background-gdk"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRGBA = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    /// The acceleration rate when you hold down a button.
    case notifyClimbRate = "notify::climb-rate"
    /// The number of decimal places to display.
    case notifyDigits = "notify::digits"
    case notifyEditable = "notify::editable"
    case notifyEditableSet = "notify::editable-set"
    case notifyEditing = "notify::editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case notifyEllipsize = "notify::ellipsize"
    case notifyEllipsizeSet = "notify::ellipsize-set"
    case notifyFamily = "notify::family"
    case notifyFamilySet = "notify::family-set"
    case notifyFont = "notify::font"
    case notifyFontDesc = "notify::font-desc"
    case notifyForeground = "notify::foreground"
    /// Foreground color as a `GdkColor`
    ///
    /// **foreground-gdk is deprecated:**
    /// Use #GtkCellRendererText:foreground-rgba instead.
    case notifyForegroundGdk = "notify::foreground-gdk"
    /// Foreground color as a `GdkRGBA`
    case notifyForegroundRGBA = "notify::foreground-rgba"
    case notifyForegroundSet = "notify::foreground-set"
    case notifyHeight = "notify::height"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyLanguage = "notify::language"
    case notifyLanguageSet = "notify::language-set"
    case notifyMarkup = "notify::markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case notifyMaxWidthChars = "notify::max-width-chars"
    case notifyMode = "notify::mode"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    /// 
    /// Since 3.6
    case notifyPlaceholderText = "notify::placeholder-text"
    case notifyRise = "notify::rise"
    case notifyRiseSet = "notify::rise-set"
    case notifyScale = "notify::scale"
    case notifyScaleSet = "notify::scale-set"
    case notifySensitive = "notify::sensitive"
    case notifySingleParagraphMode = "notify::single-paragraph-mode"
    case notifySize = "notify::size"
    case notifySizePoints = "notify::size-points"
    case notifySizeSet = "notify::size-set"
    case notifyStretch = "notify::stretch"
    case notifyStretchSet = "notify::stretch-set"
    case notifyStrikethrough = "notify::strikethrough"
    case notifyStrikethroughSet = "notify::strikethrough-set"
    case notifyStyle = "notify::style"
    case notifyStyleSet = "notify::style-set"
    case notifyText = "notify::text"
    case notifyUnderline = "notify::underline"
    case notifyUnderlineSet = "notify::underline-set"
    case notifyVariant = "notify::variant"
    case notifyVariantSet = "notify::variant-set"
    case notifyVisible = "notify::visible"
    case notifyWeight = "notify::weight"
    case notifyWeightSet = "notify::weight-set"
    case notifyWidth = "notify::width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case notifyWidthChars = "notify::width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case notifyWrapMode = "notify::wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case notifyWrapWidth = "notify::wrap-width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

public extension CellRendererSpinProtocol {
    /// Connect a `CellRendererSpinSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: CellRendererSpinSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(cell_renderer_spin_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension CellRendererSpinProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererSpin` instance.
    var cell_renderer_spin_ptr: UnsafeMutablePointer<GtkCellRendererSpin> { return ptr.assumingMemoryBound(to: GtkCellRendererSpin.self) }

}



// MARK: - CellRendererSpinner Class

/// The `CellRendererSpinnerProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererSpinner` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererSpinner`.
/// Alternatively, use `CellRendererSpinnerRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// GtkCellRendererSpinner renders a spinning animation in a cell, very
/// similar to `GtkSpinner`. It can often be used as an alternative
/// to a `GtkCellRendererProgress` for displaying indefinite activity,
/// instead of actual progress.
/// 
/// To start the animation in a cell, set the `GtkCellRendererSpinner:active`
/// property to `true` and increment the `GtkCellRendererSpinner:pulse` property
/// at regular intervals. The usual way to set the cell renderer properties
/// for each cell is to bind them to columns in your tree model using e.g.
/// `gtk_tree_view_column_add_attribute()`.
public protocol CellRendererSpinnerProtocol: CellRendererProtocol {
    /// Untyped pointer to the underlying `GtkCellRendererSpinner` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkCellRendererSpinner` instance.
    var cell_renderer_spinner_ptr: UnsafeMutablePointer<GtkCellRendererSpinner> { get }
}

/// The `CellRendererSpinnerRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererSpinner` instance.
/// It exposes methods that can operate on this data type through `CellRendererSpinnerProtocol` conformance.
/// Use `CellRendererSpinnerRef` only as an `unowned` reference to an existing `GtkCellRendererSpinner` instance.
///
/// GtkCellRendererSpinner renders a spinning animation in a cell, very
/// similar to `GtkSpinner`. It can often be used as an alternative
/// to a `GtkCellRendererProgress` for displaying indefinite activity,
/// instead of actual progress.
/// 
/// To start the animation in a cell, set the `GtkCellRendererSpinner:active`
/// property to `true` and increment the `GtkCellRendererSpinner:pulse` property
/// at regular intervals. The usual way to set the cell renderer properties
/// for each cell is to bind them to columns in your tree model using e.g.
/// `gtk_tree_view_column_add_attribute()`.
public struct CellRendererSpinnerRef: CellRendererSpinnerProtocol {
    /// Untyped pointer to the underlying `GtkCellRendererSpinner` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_spinner_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension CellRendererSpinnerRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkCellRendererSpinner>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `CellRendererSpinnerProtocol`
    init<T: CellRendererSpinnerProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Returns a new cell renderer which will show a spinner to indicate
    /// activity.
    init() {
        let rv = gtk_cell_renderer_spinner_new()
        self.init(cast(rv))
    }
}

/// The `CellRendererSpinner` type acts as a reference-counted owner of an underlying `GtkCellRendererSpinner` instance.
/// It provides the methods that can operate on this data type through `CellRendererSpinnerProtocol` conformance.
/// Use `CellRendererSpinner` as a strong reference or owner of a `GtkCellRendererSpinner` instance.
///
/// GtkCellRendererSpinner renders a spinning animation in a cell, very
/// similar to `GtkSpinner`. It can often be used as an alternative
/// to a `GtkCellRendererProgress` for displaying indefinite activity,
/// instead of actual progress.
/// 
/// To start the animation in a cell, set the `GtkCellRendererSpinner:active`
/// property to `true` and increment the `GtkCellRendererSpinner:pulse` property
/// at regular intervals. The usual way to set the cell renderer properties
/// for each cell is to bind them to columns in your tree model using e.g.
/// `gtk_tree_view_column_add_attribute()`.
open class CellRendererSpinner: CellRenderer, CellRendererSpinnerProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `CellRendererSpinner` instance.
    public init(_ op: UnsafeMutablePointer<GtkCellRendererSpinner>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `CellRendererSpinnerProtocol`
    /// Will retain `GtkCellRendererSpinner`.
    public convenience init<T: CellRendererSpinnerProtocol>(_ other: T) {
        self.init(cast(other.cell_renderer_spinner_ptr))
        g_object_ref(cast(cell_renderer_spinner_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkCellRendererSpinner.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkCellRendererSpinner.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkCellRendererSpinner.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkCellRendererSpinner>(opaquePointer))
    }

    /// Returns a new cell renderer which will show a spinner to indicate
    /// activity.
    public convenience init() {
        let rv = gtk_cell_renderer_spinner_new()
        self.init(cast(rv))
    }


}

public enum CellRendererSpinnerPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case active = "active"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkColor`
    ///
    /// **cell-background-gdk is deprecated:**
    /// Use #GtkCellRenderer:cell-background-rgba instead.
    case cellBackgroundGdk = "cell-background-gdk"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRGBA = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editing = "editing"
    case height = "height"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case mode = "mode"
    /// Pulse of the spinner. Increment this value to draw the next frame of the
    /// spinner animation. Usually, you would update this value in a timeout.
    /// 
    /// By default, the `GtkSpinner` widget draws one full cycle of the animation,
    /// consisting of 12 frames, in 750 milliseconds.
    case pulse = "pulse"
    case sensitive = "sensitive"
    /// The `GtkIconSize` value that specifies the size of the rendered spinner.
    case size = "size"
    case visible = "visible"
    case width = "width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererSpinnerProtocol {
    /// Bind a `CellRendererSpinnerPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererSpinnerPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(cell_renderer_spinner_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum CellRendererSpinnerSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK+ doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const gchar     *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyActive = "notify::active"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkColor`
    ///
    /// **cell-background-gdk is deprecated:**
    /// Use #GtkCellRenderer:cell-background-rgba instead.
    case notifyCellBackgroundGdk = "notify::cell-background-gdk"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRGBA = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditing = "notify::editing"
    case notifyHeight = "notify::height"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyMode = "notify::mode"
    /// Pulse of the spinner. Increment this value to draw the next frame of the
    /// spinner animation. Usually, you would update this value in a timeout.
    /// 
    /// By default, the `GtkSpinner` widget draws one full cycle of the animation,
    /// consisting of 12 frames, in 750 milliseconds.
    case notifyPulse = "notify::pulse"
    case notifySensitive = "notify::sensitive"
    /// The `GtkIconSize` value that specifies the size of the rendered spinner.
    case notifySize = "notify::size"
    case notifyVisible = "notify::visible"
    case notifyWidth = "notify::width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

public extension CellRendererSpinnerProtocol {
    /// Connect a `CellRendererSpinnerSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: CellRendererSpinnerSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(cell_renderer_spinner_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension CellRendererSpinnerProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererSpinner` instance.
    var cell_renderer_spinner_ptr: UnsafeMutablePointer<GtkCellRendererSpinner> { return ptr.assumingMemoryBound(to: GtkCellRendererSpinner.self) }

}



// MARK: - CellRendererText Class

/// The `CellRendererTextProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererText` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererText`.
/// Alternatively, use `CellRendererTextRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkCellRendererText` renders a given text in its cell, using the font, color and
/// style information provided by its properties. The text will be ellipsized if it is
/// too long and the `GtkCellRendererText:ellipsize` property allows it.
/// 
/// If the `GtkCellRenderer:mode` is `GTK_CELL_RENDERER_MODE_EDITABLE`,
/// the `GtkCellRendererText` allows to edit its text using an entry.
public protocol CellRendererTextProtocol: CellRendererProtocol {
    /// Untyped pointer to the underlying `GtkCellRendererText` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkCellRendererText` instance.
    var cell_renderer_text_ptr: UnsafeMutablePointer<GtkCellRendererText> { get }
}

/// The `CellRendererTextRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererText` instance.
/// It exposes methods that can operate on this data type through `CellRendererTextProtocol` conformance.
/// Use `CellRendererTextRef` only as an `unowned` reference to an existing `GtkCellRendererText` instance.
///
/// A `GtkCellRendererText` renders a given text in its cell, using the font, color and
/// style information provided by its properties. The text will be ellipsized if it is
/// too long and the `GtkCellRendererText:ellipsize` property allows it.
/// 
/// If the `GtkCellRenderer:mode` is `GTK_CELL_RENDERER_MODE_EDITABLE`,
/// the `GtkCellRendererText` allows to edit its text using an entry.
public struct CellRendererTextRef: CellRendererTextProtocol {
    /// Untyped pointer to the underlying `GtkCellRendererText` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_text_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension CellRendererTextRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkCellRendererText>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `CellRendererTextProtocol`
    init<T: CellRendererTextProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererText`. Adjust how text is drawn using
    /// object properties. Object properties can be
    /// set globally (with `g_object_set()`). Also, with `GtkTreeViewColumn`,
    /// you can bind a property to a value in a `GtkTreeModel`. For example,
    /// you can bind the “text” property on the cell renderer to a string
    /// value in the model, thus rendering a different string in each row
    /// of the `GtkTreeView`
    init() {
        let rv = gtk_cell_renderer_text_new()
        self.init(cast(rv))
    }
}

/// The `CellRendererText` type acts as a reference-counted owner of an underlying `GtkCellRendererText` instance.
/// It provides the methods that can operate on this data type through `CellRendererTextProtocol` conformance.
/// Use `CellRendererText` as a strong reference or owner of a `GtkCellRendererText` instance.
///
/// A `GtkCellRendererText` renders a given text in its cell, using the font, color and
/// style information provided by its properties. The text will be ellipsized if it is
/// too long and the `GtkCellRendererText:ellipsize` property allows it.
/// 
/// If the `GtkCellRenderer:mode` is `GTK_CELL_RENDERER_MODE_EDITABLE`,
/// the `GtkCellRendererText` allows to edit its text using an entry.
open class CellRendererText: CellRenderer, CellRendererTextProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `CellRendererText` instance.
    public init(_ op: UnsafeMutablePointer<GtkCellRendererText>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `CellRendererTextProtocol`
    /// Will retain `GtkCellRendererText`.
    public convenience init<T: CellRendererTextProtocol>(_ other: T) {
        self.init(cast(other.cell_renderer_text_ptr))
        g_object_ref(cast(cell_renderer_text_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkCellRendererText.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkCellRendererText.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkCellRendererText.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkCellRendererText>(opaquePointer))
    }

    /// Creates a new `GtkCellRendererText`. Adjust how text is drawn using
    /// object properties. Object properties can be
    /// set globally (with `g_object_set()`). Also, with `GtkTreeViewColumn`,
    /// you can bind a property to a value in a `GtkTreeModel`. For example,
    /// you can bind the “text” property on the cell renderer to a string
    /// value in the model, thus rendering a different string in each row
    /// of the `GtkTreeView`
    public convenience init() {
        let rv = gtk_cell_renderer_text_new()
        self.init(cast(rv))
    }


}

public enum CellRendererTextPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case alignSet = "align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case alignment = "alignment"
    case attributes = "attributes"
    case background = "background"
    /// Background color as a `GdkColor`
    ///
    /// **background-gdk is deprecated:**
    /// Use #GtkCellRendererText:background-rgba instead.
    case backgroundGdk = "background-gdk"
    /// Background color as a `GdkRGBA`
    case backgroundRGBA = "background-rgba"
    case backgroundSet = "background-set"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkColor`
    ///
    /// **cell-background-gdk is deprecated:**
    /// Use #GtkCellRenderer:cell-background-rgba instead.
    case cellBackgroundGdk = "cell-background-gdk"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRGBA = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editable = "editable"
    case editableSet = "editable-set"
    case editing = "editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case ellipsize = "ellipsize"
    case ellipsizeSet = "ellipsize-set"
    case family = "family"
    case familySet = "family-set"
    case font = "font"
    case fontDesc = "font-desc"
    case foreground = "foreground"
    /// Foreground color as a `GdkColor`
    ///
    /// **foreground-gdk is deprecated:**
    /// Use #GtkCellRendererText:foreground-rgba instead.
    case foregroundGdk = "foreground-gdk"
    /// Foreground color as a `GdkRGBA`
    case foregroundRGBA = "foreground-rgba"
    case foregroundSet = "foreground-set"
    case height = "height"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case language = "language"
    case languageSet = "language-set"
    case markup = "markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case maxWidthChars = "max-width-chars"
    case mode = "mode"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    /// 
    /// Since 3.6
    case placeholderText = "placeholder-text"
    case rise = "rise"
    case riseSet = "rise-set"
    case scale = "scale"
    case scaleSet = "scale-set"
    case sensitive = "sensitive"
    case singleParagraphMode = "single-paragraph-mode"
    case size = "size"
    case sizePoints = "size-points"
    case sizeSet = "size-set"
    case stretch = "stretch"
    case stretchSet = "stretch-set"
    case strikethrough = "strikethrough"
    case strikethroughSet = "strikethrough-set"
    case style = "style"
    case styleSet = "style-set"
    case text = "text"
    case underline = "underline"
    case underlineSet = "underline-set"
    case variant = "variant"
    case variantSet = "variant-set"
    case visible = "visible"
    case weight = "weight"
    case weightSet = "weight-set"
    case width = "width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case widthChars = "width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case wrapMode = "wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case wrapWidth = "wrap-width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererTextProtocol {
    /// Bind a `CellRendererTextPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererTextPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(cell_renderer_text_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum CellRendererTextSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// This signal is emitted after `renderer` has been edited.
    /// 
    /// It is the responsibility of the application to update the model
    /// and store `new_text` at the position indicated by `path`.
    case edited = "edited"
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK+ doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const gchar     *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyAlignSet = "notify::align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case notifyAlignment = "notify::alignment"
    case notifyAttributes = "notify::attributes"
    case notifyBackground = "notify::background"
    /// Background color as a `GdkColor`
    ///
    /// **background-gdk is deprecated:**
    /// Use #GtkCellRendererText:background-rgba instead.
    case notifyBackgroundGdk = "notify::background-gdk"
    /// Background color as a `GdkRGBA`
    case notifyBackgroundRGBA = "notify::background-rgba"
    case notifyBackgroundSet = "notify::background-set"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkColor`
    ///
    /// **cell-background-gdk is deprecated:**
    /// Use #GtkCellRenderer:cell-background-rgba instead.
    case notifyCellBackgroundGdk = "notify::cell-background-gdk"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRGBA = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditable = "notify::editable"
    case notifyEditableSet = "notify::editable-set"
    case notifyEditing = "notify::editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case notifyEllipsize = "notify::ellipsize"
    case notifyEllipsizeSet = "notify::ellipsize-set"
    case notifyFamily = "notify::family"
    case notifyFamilySet = "notify::family-set"
    case notifyFont = "notify::font"
    case notifyFontDesc = "notify::font-desc"
    case notifyForeground = "notify::foreground"
    /// Foreground color as a `GdkColor`
    ///
    /// **foreground-gdk is deprecated:**
    /// Use #GtkCellRendererText:foreground-rgba instead.
    case notifyForegroundGdk = "notify::foreground-gdk"
    /// Foreground color as a `GdkRGBA`
    case notifyForegroundRGBA = "notify::foreground-rgba"
    case notifyForegroundSet = "notify::foreground-set"
    case notifyHeight = "notify::height"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyLanguage = "notify::language"
    case notifyLanguageSet = "notify::language-set"
    case notifyMarkup = "notify::markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case notifyMaxWidthChars = "notify::max-width-chars"
    case notifyMode = "notify::mode"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    /// 
    /// Since 3.6
    case notifyPlaceholderText = "notify::placeholder-text"
    case notifyRise = "notify::rise"
    case notifyRiseSet = "notify::rise-set"
    case notifyScale = "notify::scale"
    case notifyScaleSet = "notify::scale-set"
    case notifySensitive = "notify::sensitive"
    case notifySingleParagraphMode = "notify::single-paragraph-mode"
    case notifySize = "notify::size"
    case notifySizePoints = "notify::size-points"
    case notifySizeSet = "notify::size-set"
    case notifyStretch = "notify::stretch"
    case notifyStretchSet = "notify::stretch-set"
    case notifyStrikethrough = "notify::strikethrough"
    case notifyStrikethroughSet = "notify::strikethrough-set"
    case notifyStyle = "notify::style"
    case notifyStyleSet = "notify::style-set"
    case notifyText = "notify::text"
    case notifyUnderline = "notify::underline"
    case notifyUnderlineSet = "notify::underline-set"
    case notifyVariant = "notify::variant"
    case notifyVariantSet = "notify::variant-set"
    case notifyVisible = "notify::visible"
    case notifyWeight = "notify::weight"
    case notifyWeightSet = "notify::weight-set"
    case notifyWidth = "notify::width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case notifyWidthChars = "notify::width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case notifyWrapMode = "notify::wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case notifyWrapWidth = "notify::wrap-width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

public extension CellRendererTextProtocol {
    /// Connect a `CellRendererTextSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: CellRendererTextSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(cell_renderer_text_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension CellRendererTextProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererText` instance.
    var cell_renderer_text_ptr: UnsafeMutablePointer<GtkCellRendererText> { return ptr.assumingMemoryBound(to: GtkCellRendererText.self) }

    /// Sets the height of a renderer to explicitly be determined by the “font” and
    /// “y_pad” property set on it.  Further changes in these properties do not
    /// affect the height, so they must be accompanied by a subsequent call to this
    /// function.  Using this function is unflexible, and should really only be used
    /// if calculating the size of a cell is too slow (ie, a massive number of cells
    /// displayed).  If `number_of_rows` is -1, then the fixed height is unset, and
    /// the height is determined by the properties again.
    func setFixedHeightFromFont(numberOfRows number_of_rows: CInt) {
        gtk_cell_renderer_text_set_fixed_height_from_font(cast(cell_renderer_text_ptr), gint(number_of_rows))
    
    }
}



// MARK: - CellRendererToggle Class

/// The `CellRendererToggleProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererToggle` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererToggle`.
/// Alternatively, use `CellRendererToggleRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkCellRendererToggle` renders a toggle button in a cell. The
/// button is drawn as a radio or a checkbutton, depending on the
/// `GtkCellRendererToggle:radio` property.
/// When activated, it emits the `GtkCellRendererToggle::toggled` signal.
public protocol CellRendererToggleProtocol: CellRendererProtocol {
    /// Untyped pointer to the underlying `GtkCellRendererToggle` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkCellRendererToggle` instance.
    var cell_renderer_toggle_ptr: UnsafeMutablePointer<GtkCellRendererToggle> { get }
}

/// The `CellRendererToggleRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererToggle` instance.
/// It exposes methods that can operate on this data type through `CellRendererToggleProtocol` conformance.
/// Use `CellRendererToggleRef` only as an `unowned` reference to an existing `GtkCellRendererToggle` instance.
///
/// `GtkCellRendererToggle` renders a toggle button in a cell. The
/// button is drawn as a radio or a checkbutton, depending on the
/// `GtkCellRendererToggle:radio` property.
/// When activated, it emits the `GtkCellRendererToggle::toggled` signal.
public struct CellRendererToggleRef: CellRendererToggleProtocol {
    /// Untyped pointer to the underlying `GtkCellRendererToggle` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_toggle_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension CellRendererToggleRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkCellRendererToggle>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `CellRendererToggleProtocol`
    init<T: CellRendererToggleProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererToggle`. Adjust rendering
    /// parameters using object properties. Object properties can be set
    /// globally (with `g_object_set()`). Also, with `GtkTreeViewColumn`, you
    /// can bind a property to a value in a `GtkTreeModel`. For example, you
    /// can bind the “active” property on the cell renderer to a boolean value
    /// in the model, thus causing the check button to reflect the state of
    /// the model.
    init() {
        let rv = gtk_cell_renderer_toggle_new()
        self.init(cast(rv))
    }
}

/// The `CellRendererToggle` type acts as a reference-counted owner of an underlying `GtkCellRendererToggle` instance.
/// It provides the methods that can operate on this data type through `CellRendererToggleProtocol` conformance.
/// Use `CellRendererToggle` as a strong reference or owner of a `GtkCellRendererToggle` instance.
///
/// `GtkCellRendererToggle` renders a toggle button in a cell. The
/// button is drawn as a radio or a checkbutton, depending on the
/// `GtkCellRendererToggle:radio` property.
/// When activated, it emits the `GtkCellRendererToggle::toggled` signal.
open class CellRendererToggle: CellRenderer, CellRendererToggleProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `CellRendererToggle` instance.
    public init(_ op: UnsafeMutablePointer<GtkCellRendererToggle>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `CellRendererToggleProtocol`
    /// Will retain `GtkCellRendererToggle`.
    public convenience init<T: CellRendererToggleProtocol>(_ other: T) {
        self.init(cast(other.cell_renderer_toggle_ptr))
        g_object_ref(cast(cell_renderer_toggle_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkCellRendererToggle.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkCellRendererToggle.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkCellRendererToggle.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkCellRendererToggle>(opaquePointer))
    }

    /// Creates a new `GtkCellRendererToggle`. Adjust rendering
    /// parameters using object properties. Object properties can be set
    /// globally (with `g_object_set()`). Also, with `GtkTreeViewColumn`, you
    /// can bind a property to a value in a `GtkTreeModel`. For example, you
    /// can bind the “active” property on the cell renderer to a boolean value
    /// in the model, thus causing the check button to reflect the state of
    /// the model.
    public convenience init() {
        let rv = gtk_cell_renderer_toggle_new()
        self.init(cast(rv))
    }


}

public enum CellRendererTogglePropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case activatable = "activatable"
    case active = "active"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkColor`
    ///
    /// **cell-background-gdk is deprecated:**
    /// Use #GtkCellRenderer:cell-background-rgba instead.
    case cellBackgroundGdk = "cell-background-gdk"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRGBA = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editing = "editing"
    case height = "height"
    case inconsistent = "inconsistent"
    case indicatorSize = "indicator-size"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case mode = "mode"
    case radio = "radio"
    case sensitive = "sensitive"
    case visible = "visible"
    case width = "width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererToggleProtocol {
    /// Bind a `CellRendererTogglePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererTogglePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(cell_renderer_toggle_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum CellRendererToggleSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK+ doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const gchar     *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `toggled` signal is emitted when the cell is toggled.
    /// 
    /// It is the responsibility of the application to update the model
    /// with the correct value to store at `path`.  Often this is simply the
    /// opposite of the value currently stored at `path`.
    case toggled = "toggled"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyActivatable = "notify::activatable"
    case notifyActive = "notify::active"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkColor`
    ///
    /// **cell-background-gdk is deprecated:**
    /// Use #GtkCellRenderer:cell-background-rgba instead.
    case notifyCellBackgroundGdk = "notify::cell-background-gdk"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRGBA = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditing = "notify::editing"
    case notifyHeight = "notify::height"
    case notifyInconsistent = "notify::inconsistent"
    case notifyIndicatorSize = "notify::indicator-size"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyMode = "notify::mode"
    case notifyRadio = "notify::radio"
    case notifySensitive = "notify::sensitive"
    case notifyVisible = "notify::visible"
    case notifyWidth = "notify::width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

public extension CellRendererToggleProtocol {
    /// Connect a `CellRendererToggleSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: CellRendererToggleSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(cell_renderer_toggle_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension CellRendererToggleProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererToggle` instance.
    var cell_renderer_toggle_ptr: UnsafeMutablePointer<GtkCellRendererToggle> { return ptr.assumingMemoryBound(to: GtkCellRendererToggle.self) }

    /// Returns whether the cell renderer is activatable. See
    /// `gtk_cell_renderer_toggle_set_activatable()`.
    func getActivatable() -> Bool {
        let rv = gtk_cell_renderer_toggle_get_activatable(cast(cell_renderer_toggle_ptr))
        return Bool(rv != 0)
    }

    /// Returns whether the cell renderer is active. See
    /// `gtk_cell_renderer_toggle_set_active()`.
    func getActive() -> Bool {
        let rv = gtk_cell_renderer_toggle_get_active(cast(cell_renderer_toggle_ptr))
        return Bool(rv != 0)
    }

    /// Returns whether we’re rendering radio toggles rather than checkboxes.
    func getRadio() -> Bool {
        let rv = gtk_cell_renderer_toggle_get_radio(cast(cell_renderer_toggle_ptr))
        return Bool(rv != 0)
    }

    /// Makes the cell renderer activatable.
    func setActivatable(setting: Bool) {
        gtk_cell_renderer_toggle_set_activatable(cast(cell_renderer_toggle_ptr), gboolean(setting ? 1 : 0))
    
    }

    /// Activates or deactivates a cell renderer.
    func setActive(setting: Bool) {
        gtk_cell_renderer_toggle_set_active(cast(cell_renderer_toggle_ptr), gboolean(setting ? 1 : 0))
    
    }

    /// If `radio` is `true`, the cell renderer renders a radio toggle
    /// (i.e. a toggle in a group of mutually-exclusive toggles).
    /// If `false`, it renders a check toggle (a standalone boolean option).
    /// This can be set globally for the cell renderer, or changed just
    /// before rendering each cell in the model (for `GtkTreeView`, you set
    /// up a per-row setting using `GtkTreeViewColumn` to associate model
    /// columns with cell renderer properties).
    func set(radio: Bool) {
        gtk_cell_renderer_toggle_set_radio(cast(cell_renderer_toggle_ptr), gboolean(radio ? 1 : 0))
    
    }
    var activatable: Bool {
        /// Returns whether the cell renderer is activatable. See
        /// `gtk_cell_renderer_toggle_set_activatable()`.
        get {
            let rv = gtk_cell_renderer_toggle_get_activatable(cast(cell_renderer_toggle_ptr))
            return Bool(rv != 0)
        }
        /// Makes the cell renderer activatable.
        nonmutating set {
            gtk_cell_renderer_toggle_set_activatable(cast(cell_renderer_toggle_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    var active: Bool {
        /// Returns whether the cell renderer is active. See
        /// `gtk_cell_renderer_toggle_set_active()`.
        get {
            let rv = gtk_cell_renderer_toggle_get_active(cast(cell_renderer_toggle_ptr))
            return Bool(rv != 0)
        }
        /// Activates or deactivates a cell renderer.
        nonmutating set {
            gtk_cell_renderer_toggle_set_active(cast(cell_renderer_toggle_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    var radio: Bool {
        /// Returns whether we’re rendering radio toggles rather than checkboxes.
        get {
            let rv = gtk_cell_renderer_toggle_get_radio(cast(cell_renderer_toggle_ptr))
            return Bool(rv != 0)
        }
        /// If `radio` is `true`, the cell renderer renders a radio toggle
        /// (i.e. a toggle in a group of mutually-exclusive toggles).
        /// If `false`, it renders a check toggle (a standalone boolean option).
        /// This can be set globally for the cell renderer, or changed just
        /// before rendering each cell in the model (for `GtkTreeView`, you set
        /// up a per-row setting using `GtkTreeViewColumn` to associate model
        /// columns with cell renderer properties).
        nonmutating set {
            gtk_cell_renderer_toggle_set_radio(cast(cell_renderer_toggle_ptr), gboolean(newValue ? 1 : 0))
        }
    }
}



// MARK: - CellView Class

/// The `CellViewProtocol` protocol exposes the methods and properties of an underlying `GtkCellView` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellView`.
/// Alternatively, use `CellViewRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkCellView` displays a single row of a `GtkTreeModel` using a `GtkCellArea`
/// and `GtkCellAreaContext`. A `GtkCellAreaContext` can be provided to the
/// `GtkCellView` at construction time in order to keep the cellview in context
/// of a group of cell views, this ensures that the renderers displayed will
/// be properly aligned with eachother (like the aligned cells in the menus
/// of `GtkComboBox`).
/// 
/// `GtkCellView` is `GtkOrientable` in order to decide in which orientation
/// the underlying `GtkCellAreaContext` should be allocated. Taking the `GtkComboBox`
/// menu as an example, cellviews should be oriented horizontally if the menus are
/// listed top-to-bottom and thus all share the same width but may have separate
/// individual heights (left-to-right menus should be allocated vertically since
/// they all share the same height but may have variable widths).
/// 
/// # CSS nodes
/// 
/// GtkCellView has a single CSS node with name cellview.
public protocol CellViewProtocol: WidgetProtocol, CellLayoutProtocol, OrientableProtocol {
    /// Untyped pointer to the underlying `GtkCellView` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkCellView` instance.
    var cell_view_ptr: UnsafeMutablePointer<GtkCellView> { get }
}

/// The `CellViewRef` type acts as a lightweight Swift reference to an underlying `GtkCellView` instance.
/// It exposes methods that can operate on this data type through `CellViewProtocol` conformance.
/// Use `CellViewRef` only as an `unowned` reference to an existing `GtkCellView` instance.
///
/// A `GtkCellView` displays a single row of a `GtkTreeModel` using a `GtkCellArea`
/// and `GtkCellAreaContext`. A `GtkCellAreaContext` can be provided to the
/// `GtkCellView` at construction time in order to keep the cellview in context
/// of a group of cell views, this ensures that the renderers displayed will
/// be properly aligned with eachother (like the aligned cells in the menus
/// of `GtkComboBox`).
/// 
/// `GtkCellView` is `GtkOrientable` in order to decide in which orientation
/// the underlying `GtkCellAreaContext` should be allocated. Taking the `GtkComboBox`
/// menu as an example, cellviews should be oriented horizontally if the menus are
/// listed top-to-bottom and thus all share the same width but may have separate
/// individual heights (left-to-right menus should be allocated vertically since
/// they all share the same height but may have variable widths).
/// 
/// # CSS nodes
/// 
/// GtkCellView has a single CSS node with name cellview.
public struct CellViewRef: CellViewProtocol {
    /// Untyped pointer to the underlying `GtkCellView` instance.
    /// For type-safe access, use the generated, typed pointer `cell_view_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension CellViewRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkCellView>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `CellViewProtocol`
    init<T: CellViewProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellView` widget.
    init() {
        let rv = gtk_cell_view_new()
        self.init(cast(rv))
    }

    /// Creates a new `GtkCellView` widget with a specific `GtkCellArea`
    /// to layout cells and a specific `GtkCellAreaContext`.
    /// 
    /// Specifying the same context for a handfull of cells lets
    /// the underlying area synchronize the geometry for those cells,
    /// in this way alignments with cellviews for other rows are
    /// possible.
    init(context area: CellAreaProtocol, context: CellAreaContextProtocol) {
        let rv = gtk_cell_view_new_with_context(cast(area.ptr), cast(context.ptr))
        self.init(cast(rv))
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `markup`. The text can be
    /// marked up with the [Pango text markup language](#PangoMarkupFormat).
    init(markup: UnsafePointer<gchar>) {
        let rv = gtk_cell_view_new_with_markup(markup)
        self.init(cast(rv))
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererPixbuf`
    /// to it, and makes it show `pixbuf`.
    init(pixbuf: PixbufProtocol) {
        let rv = gtk_cell_view_new_with_pixbuf(cast(pixbuf.ptr))
        self.init(cast(rv))
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `text`.
    init(text: UnsafePointer<gchar>) {
        let rv = gtk_cell_view_new_with_text(text)
        self.init(cast(rv))
    }
    /// Creates a new `GtkCellView` widget with a specific `GtkCellArea`
    /// to layout cells and a specific `GtkCellAreaContext`.
    /// 
    /// Specifying the same context for a handfull of cells lets
    /// the underlying area synchronize the geometry for those cells,
    /// in this way alignments with cellviews for other rows are
    /// possible.
    static func newWith(context area: CellAreaProtocol, context: CellAreaContextProtocol) -> CellViewRef! {
        let rv = gtk_cell_view_new_with_context(cast(area.ptr), cast(context.ptr))
        return rv.map { CellViewRef(cast($0)) }
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `markup`. The text can be
    /// marked up with the [Pango text markup language](#PangoMarkupFormat).
    static func newWith(markup: UnsafePointer<gchar>) -> CellViewRef! {
        let rv = gtk_cell_view_new_with_markup(markup)
        return rv.map { CellViewRef(cast($0)) }
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererPixbuf`
    /// to it, and makes it show `pixbuf`.
    static func newWith(pixbuf: PixbufProtocol) -> CellViewRef! {
        let rv = gtk_cell_view_new_with_pixbuf(cast(pixbuf.ptr))
        return rv.map { CellViewRef(cast($0)) }
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `text`.
    static func newWith(text: UnsafePointer<gchar>) -> CellViewRef! {
        let rv = gtk_cell_view_new_with_text(text)
        return rv.map { CellViewRef(cast($0)) }
    }
}

/// The `CellView` type acts as a reference-counted owner of an underlying `GtkCellView` instance.
/// It provides the methods that can operate on this data type through `CellViewProtocol` conformance.
/// Use `CellView` as a strong reference or owner of a `GtkCellView` instance.
///
/// A `GtkCellView` displays a single row of a `GtkTreeModel` using a `GtkCellArea`
/// and `GtkCellAreaContext`. A `GtkCellAreaContext` can be provided to the
/// `GtkCellView` at construction time in order to keep the cellview in context
/// of a group of cell views, this ensures that the renderers displayed will
/// be properly aligned with eachother (like the aligned cells in the menus
/// of `GtkComboBox`).
/// 
/// `GtkCellView` is `GtkOrientable` in order to decide in which orientation
/// the underlying `GtkCellAreaContext` should be allocated. Taking the `GtkComboBox`
/// menu as an example, cellviews should be oriented horizontally if the menus are
/// listed top-to-bottom and thus all share the same width but may have separate
/// individual heights (left-to-right menus should be allocated vertically since
/// they all share the same height but may have variable widths).
/// 
/// # CSS nodes
/// 
/// GtkCellView has a single CSS node with name cellview.
open class CellView: Widget, CellViewProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `CellView` instance.
    public init(_ op: UnsafeMutablePointer<GtkCellView>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `CellViewProtocol`
    /// Will retain `GtkCellView`.
    public convenience init<T: CellViewProtocol>(_ other: T) {
        self.init(cast(other.cell_view_ptr))
        g_object_ref(cast(cell_view_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkCellView.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkCellView.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkCellView.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkCellView>(opaquePointer))
    }

    /// Creates a new `GtkCellView` widget.
    public convenience init() {
        let rv = gtk_cell_view_new()
        self.init(cast(rv))
    }

    /// Creates a new `GtkCellView` widget with a specific `GtkCellArea`
    /// to layout cells and a specific `GtkCellAreaContext`.
    /// 
    /// Specifying the same context for a handfull of cells lets
    /// the underlying area synchronize the geometry for those cells,
    /// in this way alignments with cellviews for other rows are
    /// possible.
    public convenience init(context area: CellAreaProtocol, context: CellAreaContextProtocol) {
        let rv = gtk_cell_view_new_with_context(cast(area.ptr), cast(context.ptr))
        self.init(cast(rv))
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `markup`. The text can be
    /// marked up with the [Pango text markup language](#PangoMarkupFormat).
    public convenience init(markup: UnsafePointer<gchar>) {
        let rv = gtk_cell_view_new_with_markup(markup)
        self.init(cast(rv))
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererPixbuf`
    /// to it, and makes it show `pixbuf`.
    public convenience init(pixbuf: PixbufProtocol) {
        let rv = gtk_cell_view_new_with_pixbuf(cast(pixbuf.ptr))
        self.init(cast(rv))
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `text`.
    public convenience init(text: UnsafePointer<gchar>) {
        let rv = gtk_cell_view_new_with_text(text)
        self.init(cast(rv))
    }

    /// Creates a new `GtkCellView` widget with a specific `GtkCellArea`
    /// to layout cells and a specific `GtkCellAreaContext`.
    /// 
    /// Specifying the same context for a handfull of cells lets
    /// the underlying area synchronize the geometry for those cells,
    /// in this way alignments with cellviews for other rows are
    /// possible.
    public static func newWith(context area: CellAreaProtocol, context: CellAreaContextProtocol) -> CellView! {
        let rv = gtk_cell_view_new_with_context(cast(area.ptr), cast(context.ptr))
        return rv.map { CellView(cast($0)) }
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `markup`. The text can be
    /// marked up with the [Pango text markup language](#PangoMarkupFormat).
    public static func newWith(markup: UnsafePointer<gchar>) -> CellView! {
        let rv = gtk_cell_view_new_with_markup(markup)
        return rv.map { CellView(cast($0)) }
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererPixbuf`
    /// to it, and makes it show `pixbuf`.
    public static func newWith(pixbuf: PixbufProtocol) -> CellView! {
        let rv = gtk_cell_view_new_with_pixbuf(cast(pixbuf.ptr))
        return rv.map { CellView(cast($0)) }
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `text`.
    public static func newWith(text: UnsafePointer<gchar>) -> CellView! {
        let rv = gtk_cell_view_new_with_text(text)
        return rv.map { CellView(cast($0)) }
    }

}

public enum CellViewPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case appPaintable = "app-paintable"
    case background = "background"
    /// The background color as a `GdkColor`
    ///
    /// **background-gdk is deprecated:**
    /// Use #GtkCellView:background-rgba instead.
    case backgroundGdk = "background-gdk"
    /// The background color as a `GdkRGBA`
    case backgroundRGBA = "background-rgba"
    case backgroundSet = "background-set"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    /// The `GtkCellArea` rendering cells
    /// 
    /// If no area is specified when creating the cell view with `gtk_cell_view_new_with_context()`
    /// a horizontally oriented `GtkCellAreaBox` will be used.
    /// 
    /// since 3.0
    case cellArea = "cell-area"
    /// The `GtkCellAreaContext` used to compute the geometry of the cell view.
    /// 
    /// A group of cell views can be assigned the same context in order to
    /// ensure the sizes and cell alignments match across all the views with
    /// the same context.
    /// 
    /// `GtkComboBox` menus uses this to assign the same context to all cell views
    /// in the menu items for a single menu (each submenu creates its own
    /// context since the size of each submenu does not depend on parent
    /// or sibling menus).
    /// 
    /// since 3.0
    case cellAreaContext = "cell-area-context"
    case compositeChild = "composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    /// Whether all cells should be draw as sensitive for this view regardless
    /// of the actual cell properties (used to make menus with submenus appear
    /// sensitive when the items in submenus might be insensitive).
    /// 
    /// since 3.0
    case drawSensitive = "draw-sensitive"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the view should request enough space to always fit
    /// the size of every row in the model (used by the combo box to
    /// ensure the combo box size doesnt change when different items
    /// are selected).
    /// 
    /// since 3.0
    case fitModel = "fit-model"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    case isFocus = "is-focus"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    /// The model for cell view
    /// 
    /// since 2.10
    case model = "model"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
}

public extension CellViewProtocol {
    /// Bind a `CellViewPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellViewPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(cell_view_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum CellViewSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The `button`-press-event signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button`-release-event signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    /// The `child`-notify signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The `composited`-changed signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure`-event signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete`-event signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy`-event signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag`-begin signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag`-data-delete signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag`-data-get signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag`-data-received signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag`-drop signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag`-drop signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag`-data-received handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag`-end signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag`-begin.
    case dragEnd = "drag-end"
    /// The `drag`-failed signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag`-leave signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag`-motion, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag`-leave signal is also emitted before the
    /// `drag`-drop signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag`-motion signal handler.
    case dragLeave = "drag-leave"
    /// The `drag`-motion signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag`-data-received
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag`-leave and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enter`-notify-event will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key`-press-event) and finally a generic
    /// `GtkWidget::event`-after signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event`-after will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `focus`-in-event signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus`-out-event signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab`-notify signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy`-changed signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key`-press-event signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key`-release-event signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `leave`-notify-event will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map`-event will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map`-event signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion`-notify-event signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent`-set signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The `property`-notify-event signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// The `screen`-changed signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll`-event signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `selection`-clear-event signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection`-request-event signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-changed signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style`-set signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style`-updated signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style`-updated signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap`-event signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility`-notify-event will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    /// The `window`-state-event will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBackground = "notify::background"
    /// The background color as a `GdkColor`
    ///
    /// **background-gdk is deprecated:**
    /// Use #GtkCellView:background-rgba instead.
    case notifyBackgroundGdk = "notify::background-gdk"
    /// The background color as a `GdkRGBA`
    case notifyBackgroundRGBA = "notify::background-rgba"
    case notifyBackgroundSet = "notify::background-set"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    /// The `GtkCellArea` rendering cells
    /// 
    /// If no area is specified when creating the cell view with `gtk_cell_view_new_with_context()`
    /// a horizontally oriented `GtkCellAreaBox` will be used.
    /// 
    /// since 3.0
    case notifyCellArea = "notify::cell-area"
    /// The `GtkCellAreaContext` used to compute the geometry of the cell view.
    /// 
    /// A group of cell views can be assigned the same context in order to
    /// ensure the sizes and cell alignments match across all the views with
    /// the same context.
    /// 
    /// `GtkComboBox` menus uses this to assign the same context to all cell views
    /// in the menu items for a single menu (each submenu creates its own
    /// context since the size of each submenu does not depend on parent
    /// or sibling menus).
    /// 
    /// since 3.0
    case notifyCellAreaContext = "notify::cell-area-context"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    /// Whether all cells should be draw as sensitive for this view regardless
    /// of the actual cell properties (used to make menus with submenus appear
    /// sensitive when the items in submenus might be insensitive).
    /// 
    /// since 3.0
    case notifyDrawSensitive = "notify::draw-sensitive"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the view should request enough space to always fit
    /// the size of every row in the model (used by the combo box to
    /// ensure the combo box size doesnt change when different items
    /// are selected).
    /// 
    /// since 3.0
    case notifyFitModel = "notify::fit-model"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    case notifyIsFocus = "notify::is-focus"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    /// The model for cell view
    /// 
    /// since 2.10
    case notifyModel = "notify::model"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
}

public extension CellViewProtocol {
    /// Connect a `CellViewSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: CellViewSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(cell_view_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension CellViewProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellView` instance.
    var cell_view_ptr: UnsafeMutablePointer<GtkCellView> { return ptr.assumingMemoryBound(to: GtkCellView.self) }

    /// Returns a `GtkTreePath` referring to the currently
    /// displayed row. If no row is currently displayed,
    /// `nil` is returned.
    func getDisplayedRow() -> UnsafeMutablePointer<GtkTreePath>! {
        let rv = gtk_cell_view_get_displayed_row(cast(cell_view_ptr))
        return cast(rv)
    }

    /// Gets whether `cell_view` is configured to draw all of its
    /// cells in a sensitive state.
    func getDrawSensitive() -> Bool {
        let rv = gtk_cell_view_get_draw_sensitive(cast(cell_view_ptr))
        return Bool(rv != 0)
    }

    /// Gets whether `cell_view` is configured to request space
    /// to fit the entire `GtkTreeModel`.
    func getFitModel() -> Bool {
        let rv = gtk_cell_view_get_fit_model(cast(cell_view_ptr))
        return Bool(rv != 0)
    }

    /// Returns the model for `cell_view`. If no model is used `nil` is
    /// returned.
    func getModel() -> UnsafeMutablePointer<GtkTreeModel>! {
        let rv = gtk_cell_view_get_model(cast(cell_view_ptr))
        return cast(rv)
    }

    /// Sets `requisition` to the size needed by `cell_view` to display
    /// the model row pointed to by `path`.
    ///
    /// **get_size_of_row is deprecated:**
    /// Combo box formerly used this to calculate the
    /// sizes for cellviews, now you can achieve this by either using
    /// the #GtkCellView:fit-model property or by setting the currently
    /// displayed row of the #GtkCellView and using gtk_widget_get_preferred_size().
    @available(*, deprecated) func getSizeOfRow(path: TreePathProtocol, requisition: RequisitionProtocol) -> Bool {
        let rv = gtk_cell_view_get_size_of_row(cast(cell_view_ptr), cast(path.ptr), cast(requisition.ptr))
        return Bool(rv != 0)
    }

    /// Sets the background color of `view`.
    ///
    /// **set_background_color is deprecated:**
    /// Use gtk_cell_view_set_background_rgba() instead.
    @available(*, deprecated) func setBackground(color: Gdk.ColorProtocol) {
        gtk_cell_view_set_background_color(cast(cell_view_ptr), cast(color.ptr))
    
    }

    /// Sets the background color of `cell_view`.
    func setBackground(rgba: RGBAProtocol) {
        gtk_cell_view_set_background_rgba(cast(cell_view_ptr), cast(rgba.ptr))
    
    }

    /// Sets the row of the model that is currently displayed
    /// by the `GtkCellView`. If the path is unset, then the
    /// contents of the cellview “stick” at their last value;
    /// this is not normally a desired result, but may be
    /// a needed intermediate state if say, the model for
    /// the `GtkCellView` becomes temporarily empty.
    func setDisplayedRow(path: TreePathProtocol) {
        gtk_cell_view_set_displayed_row(cast(cell_view_ptr), cast(path.ptr))
    
    }

    /// Sets whether `cell_view` should draw all of its
    /// cells in a sensitive state, this is used by `GtkComboBox` menus
    /// to ensure that rows with insensitive cells that contain
    /// children appear sensitive in the parent menu item.
    func set(drawSensitive draw_sensitive: Bool) {
        gtk_cell_view_set_draw_sensitive(cast(cell_view_ptr), gboolean(draw_sensitive ? 1 : 0))
    
    }

    /// Sets whether `cell_view` should request space to fit the entire `GtkTreeModel`.
    /// 
    /// This is used by `GtkComboBox` to ensure that the cell view displayed on
    /// the combo box’s button always gets enough space and does not resize
    /// when selection changes.
    func set(fitModel fit_model: Bool) {
        gtk_cell_view_set_fit_model(cast(cell_view_ptr), gboolean(fit_model ? 1 : 0))
    
    }

    /// Sets the model for `cell_view`.  If `cell_view` already has a model
    /// set, it will remove it before setting the new model.  If `model` is
    /// `nil`, then it will unset the old model.
    func set(model: TreeModelProtocol) {
        gtk_cell_view_set_model(cast(cell_view_ptr), cast(model.ptr))
    
    }
    /// Returns a `GtkTreePath` referring to the currently
    /// displayed row. If no row is currently displayed,
    /// `nil` is returned.
    var displayedRow: UnsafeMutablePointer<GtkTreePath>! {
        /// Returns a `GtkTreePath` referring to the currently
        /// displayed row. If no row is currently displayed,
        /// `nil` is returned.
        get {
            let rv = gtk_cell_view_get_displayed_row(cast(cell_view_ptr))
            return cast(rv)
        }
        /// Sets the row of the model that is currently displayed
        /// by the `GtkCellView`. If the path is unset, then the
        /// contents of the cellview “stick” at their last value;
        /// this is not normally a desired result, but may be
        /// a needed intermediate state if say, the model for
        /// the `GtkCellView` becomes temporarily empty.
        nonmutating set {
            gtk_cell_view_set_displayed_row(cast(cell_view_ptr), cast(newValue))
        }
    }

    /// Gets whether `cell_view` is configured to draw all of its
    /// cells in a sensitive state.
    var drawSensitive: Bool {
        /// Gets whether `cell_view` is configured to draw all of its
        /// cells in a sensitive state.
        get {
            let rv = gtk_cell_view_get_draw_sensitive(cast(cell_view_ptr))
            return Bool(rv != 0)
        }
        /// Sets whether `cell_view` should draw all of its
        /// cells in a sensitive state, this is used by `GtkComboBox` menus
        /// to ensure that rows with insensitive cells that contain
        /// children appear sensitive in the parent menu item.
        nonmutating set {
            gtk_cell_view_set_draw_sensitive(cast(cell_view_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Gets whether `cell_view` is configured to request space
    /// to fit the entire `GtkTreeModel`.
    var fitModel: Bool {
        /// Gets whether `cell_view` is configured to request space
        /// to fit the entire `GtkTreeModel`.
        get {
            let rv = gtk_cell_view_get_fit_model(cast(cell_view_ptr))
            return Bool(rv != 0)
        }
        /// Sets whether `cell_view` should request space to fit the entire `GtkTreeModel`.
        /// 
        /// This is used by `GtkComboBox` to ensure that the cell view displayed on
        /// the combo box’s button always gets enough space and does not resize
        /// when selection changes.
        nonmutating set {
            gtk_cell_view_set_fit_model(cast(cell_view_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// The model for cell view
    /// 
    /// since 2.10
    var model: UnsafeMutablePointer<GtkTreeModel>! {
        /// Returns the model for `cell_view`. If no model is used `nil` is
        /// returned.
        get {
            let rv = gtk_cell_view_get_model(cast(cell_view_ptr))
            return cast(rv)
        }
        /// Sets the model for `cell_view`.  If `cell_view` already has a model
        /// set, it will remove it before setting the new model.  If `model` is
        /// `nil`, then it will unset the old model.
        nonmutating set {
            gtk_cell_view_set_model(cast(cell_view_ptr), cast(newValue))
        }
    }
}



// MARK: - CheckButton Class

/// The `CheckButtonProtocol` protocol exposes the methods and properties of an underlying `GtkCheckButton` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CheckButton`.
/// Alternatively, use `CheckButtonRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkCheckButton` places a discrete `GtkToggleButton` next to a widget,
/// (usually a `GtkLabel`). See the section on `GtkToggleButton` widgets for
/// more information about toggle/check buttons.
/// 
/// The important signal ( `GtkToggleButton::toggled` ) is also inherited from
/// `GtkToggleButton`.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// checkbutton
/// ├── check
/// ╰── <child>
/// ```
/// 
/// A GtkCheckButton with indicator (see `gtk_toggle_button_set_mode()`) has a
/// main CSS node with name checkbutton and a subnode with name check.
/// 
/// (plain Language Example):
/// ```plain
/// button.check
/// ├── check
/// ╰── <child>
/// ```
/// 
/// A GtkCheckButton without indicator changes the name of its main node
/// to button and adds a .check style class to it. The subnode is invisible
/// in this case.
public protocol CheckButtonProtocol: ToggleButtonProtocol {
    /// Untyped pointer to the underlying `GtkCheckButton` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkCheckButton` instance.
    var check_button_ptr: UnsafeMutablePointer<GtkCheckButton> { get }
}

/// The `CheckButtonRef` type acts as a lightweight Swift reference to an underlying `GtkCheckButton` instance.
/// It exposes methods that can operate on this data type through `CheckButtonProtocol` conformance.
/// Use `CheckButtonRef` only as an `unowned` reference to an existing `GtkCheckButton` instance.
///
/// A `GtkCheckButton` places a discrete `GtkToggleButton` next to a widget,
/// (usually a `GtkLabel`). See the section on `GtkToggleButton` widgets for
/// more information about toggle/check buttons.
/// 
/// The important signal ( `GtkToggleButton::toggled` ) is also inherited from
/// `GtkToggleButton`.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// checkbutton
/// ├── check
/// ╰── <child>
/// ```
/// 
/// A GtkCheckButton with indicator (see `gtk_toggle_button_set_mode()`) has a
/// main CSS node with name checkbutton and a subnode with name check.
/// 
/// (plain Language Example):
/// ```plain
/// button.check
/// ├── check
/// ╰── <child>
/// ```
/// 
/// A GtkCheckButton without indicator changes the name of its main node
/// to button and adds a .check style class to it. The subnode is invisible
/// in this case.
public struct CheckButtonRef: CheckButtonProtocol {
    /// Untyped pointer to the underlying `GtkCheckButton` instance.
    /// For type-safe access, use the generated, typed pointer `check_button_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension CheckButtonRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkCheckButton>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `CheckButtonProtocol`
    init<T: CheckButtonProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCheckButton`.
    init() {
        let rv = gtk_check_button_new()
        self.init(cast(rv))
    }

    /// Creates a new `GtkCheckButton` with a `GtkLabel` to the right of it.
    init(label: UnsafePointer<gchar>) {
        let rv = gtk_check_button_new_with_label(label)
        self.init(cast(rv))
    }

    /// Creates a new `GtkCheckButton` containing a label. The label
    /// will be created using `gtk_label_new_with_mnemonic()`, so underscores
    /// in `label` indicate the mnemonic for the check button.
    init(mnemonic label: UnsafePointer<gchar>) {
        let rv = gtk_check_button_new_with_mnemonic(label)
        self.init(cast(rv))
    }
    /// Creates a new `GtkCheckButton` with a `GtkLabel` to the right of it.
    static func checkButtonNewWith(label: UnsafePointer<gchar>) -> CheckButtonRef! {
        let rv = gtk_check_button_new_with_label(label)
        return rv.map { CheckButtonRef(cast($0)) }
    }

    /// Creates a new `GtkCheckButton` containing a label. The label
    /// will be created using `gtk_label_new_with_mnemonic()`, so underscores
    /// in `label` indicate the mnemonic for the check button.
    static func checkButtonNewWith(mnemonic label: UnsafePointer<gchar>) -> CheckButtonRef! {
        let rv = gtk_check_button_new_with_mnemonic(label)
        return rv.map { CheckButtonRef(cast($0)) }
    }
}

/// The `CheckButton` type acts as a reference-counted owner of an underlying `GtkCheckButton` instance.
/// It provides the methods that can operate on this data type through `CheckButtonProtocol` conformance.
/// Use `CheckButton` as a strong reference or owner of a `GtkCheckButton` instance.
///
/// A `GtkCheckButton` places a discrete `GtkToggleButton` next to a widget,
/// (usually a `GtkLabel`). See the section on `GtkToggleButton` widgets for
/// more information about toggle/check buttons.
/// 
/// The important signal ( `GtkToggleButton::toggled` ) is also inherited from
/// `GtkToggleButton`.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// checkbutton
/// ├── check
/// ╰── <child>
/// ```
/// 
/// A GtkCheckButton with indicator (see `gtk_toggle_button_set_mode()`) has a
/// main CSS node with name checkbutton and a subnode with name check.
/// 
/// (plain Language Example):
/// ```plain
/// button.check
/// ├── check
/// ╰── <child>
/// ```
/// 
/// A GtkCheckButton without indicator changes the name of its main node
/// to button and adds a .check style class to it. The subnode is invisible
/// in this case.
open class CheckButton: ToggleButton, CheckButtonProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `CheckButton` instance.
    public init(_ op: UnsafeMutablePointer<GtkCheckButton>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `CheckButtonProtocol`
    /// Will retain `GtkCheckButton`.
    public convenience init<T: CheckButtonProtocol>(_ other: T) {
        self.init(cast(other.check_button_ptr))
        g_object_ref(cast(check_button_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkCheckButton.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkCheckButton.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkCheckButton.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkCheckButton>(opaquePointer))
    }

    /// Creates a new `GtkCheckButton`.
    public convenience init() {
        let rv = gtk_check_button_new()
        self.init(cast(rv))
    }

    /// Creates a new `GtkCheckButton` with a `GtkLabel` to the right of it.
    public convenience init(label: UnsafePointer<gchar>) {
        let rv = gtk_check_button_new_with_label(label)
        self.init(cast(rv))
    }

    /// Creates a new `GtkCheckButton` containing a label. The label
    /// will be created using `gtk_label_new_with_mnemonic()`, so underscores
    /// in `label` indicate the mnemonic for the check button.
    public convenience init(mnemonic label: UnsafePointer<gchar>) {
        let rv = gtk_check_button_new_with_mnemonic(label)
        self.init(cast(rv))
    }

    /// Creates a new `GtkCheckButton` with a `GtkLabel` to the right of it.
    public static func checkButtonNewWith(label: UnsafePointer<gchar>) -> CheckButton! {
        let rv = gtk_check_button_new_with_label(label)
        return rv.map { CheckButton(cast($0)) }
    }

    /// Creates a new `GtkCheckButton` containing a label. The label
    /// will be created using `gtk_label_new_with_mnemonic()`, so underscores
    /// in `label` indicate the mnemonic for the check button.
    public static func checkButtonNewWith(mnemonic label: UnsafePointer<gchar>) -> CheckButton! {
        let rv = gtk_check_button_new_with_mnemonic(label)
        return rv.map { CheckButton(cast($0)) }
    }

}

public enum CheckButtonPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case active = "active"
    /// If `true`, the button will ignore the `GtkSettings:gtk`-button-images
    /// setting and always show the image, if available.
    /// 
    /// Use this property if the button would be useless or hard to use
    /// without the image.
    case alwaysShowImage = "always-show-image"
    case appPaintable = "app-paintable"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case compositeChild = "composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case drawIndicator = "draw-indicator"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The child widget to appear next to the button text.
    case image = "image"
    /// The position of the image relative to the text inside the button.
    case imagePosition = "image-position"
    case inconsistent = "inconsistent"
    case isFocus = "is-focus"
    case label = "label"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case relief = "relief"
    case resizeMode = "resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"

    ///
    /// **use-stock is deprecated:**
    /// This method is deprecated.
    case useStock = "use-stock"
    case useUnderline = "use-underline"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
    /// If the child of the button is a `GtkMisc` or `GtkAlignment`, this property
    /// can be used to control its horizontal alignment. 0.0 is left aligned,
    /// 1.0 is right aligned.
    ///
    /// **xalign is deprecated:**
    /// Access the child widget directly if you need to control
    /// its alignment.
    case xalign = "xalign"
    /// If the child of the button is a `GtkMisc` or `GtkAlignment`, this property
    /// can be used to control its vertical alignment. 0.0 is top aligned,
    /// 1.0 is bottom aligned.
    ///
    /// **yalign is deprecated:**
    /// Access the child widget directly if you need to control
    /// its alignment.
    case yalign = "yalign"
}

public extension CheckButtonProtocol {
    /// Bind a `CheckButtonPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CheckButtonPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(check_button_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum CheckButtonSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    /// The `activate` signal on GtkButton is an action signal and
    /// emitting it causes the button to animate press then release.
    /// Applications should never connect to this signal, but use the
    /// `GtkButton::clicked` signal.
    case activate = "activate"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    case add = "add"
    /// The `button`-press-event signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button`-release-event signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child`-notify signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// Emitted when the button has been activated (pressed and released).
    case clicked = "clicked"
    /// The `composited`-changed signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure`-event signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete`-event signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy`-event signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag`-begin signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag`-data-delete signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag`-data-get signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag`-data-received signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag`-drop signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag`-drop signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag`-data-received handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag`-end signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag`-begin.
    case dragEnd = "drag-end"
    /// The `drag`-failed signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag`-leave signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag`-motion, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag`-leave signal is also emitted before the
    /// `drag`-drop signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag`-motion signal handler.
    case dragLeave = "drag-leave"
    /// The `drag`-motion signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag`-data-received
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag`-leave and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// Emitted when the pointer enters the button.
    ///
    /// **enter is deprecated:**
    /// Use the #GtkWidget::enter-notify-event signal.
    case enter = "enter"
    /// The `enter`-notify-event will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key`-press-event) and finally a generic
    /// `GtkWidget::event`-after signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event`-after will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `focus`-in-event signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus`-out-event signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab`-notify signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy`-changed signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key`-press-event signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key`-release-event signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when the pointer leaves the button.
    ///
    /// **leave is deprecated:**
    /// Use the #GtkWidget::leave-notify-event signal.
    case leave = "leave"
    /// The `leave`-notify-event will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map`-event will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map`-event signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion`-notify-event signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent`-set signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// Emitted when the button is pressed.
    ///
    /// **pressed is deprecated:**
    /// Use the #GtkWidget::button-press-event signal.
    case pressed = "pressed"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The `property`-notify-event signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when the button is released.
    ///
    /// **released is deprecated:**
    /// Use the #GtkWidget::button-release-event signal.
    case released = "released"
    case remove = "remove"
    /// The `screen`-changed signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll`-event signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `selection`-clear-event signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection`-request-event signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-changed signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style`-set signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style`-updated signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style`-updated signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    /// Should be connected if you wish to perform an action whenever the
    /// `GtkToggleButton`'s state is changed.
    case toggled = "toggled"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap`-event signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility`-notify-event will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    /// The `window`-state-event will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyActive = "notify::active"
    /// If `true`, the button will ignore the `GtkSettings:gtk`-button-images
    /// setting and always show the image, if available.
    /// 
    /// Use this property if the button would be useless or hard to use
    /// without the image.
    case notifyAlwaysShowImage = "notify::always-show-image"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyDrawIndicator = "notify::draw-indicator"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The child widget to appear next to the button text.
    case notifyImage = "notify::image"
    /// The position of the image relative to the text inside the button.
    case notifyImagePosition = "notify::image-position"
    case notifyInconsistent = "notify::inconsistent"
    case notifyIsFocus = "notify::is-focus"
    case notifyLabel = "notify::label"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyRelief = "notify::relief"
    case notifyResizeMode = "notify::resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"

    ///
    /// **use-stock is deprecated:**
    /// This method is deprecated.
    case notifyUseStock = "notify::use-stock"
    case notifyUseUnderline = "notify::use-underline"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
    /// If the child of the button is a `GtkMisc` or `GtkAlignment`, this property
    /// can be used to control its horizontal alignment. 0.0 is left aligned,
    /// 1.0 is right aligned.
    ///
    /// **xalign is deprecated:**
    /// Access the child widget directly if you need to control
    /// its alignment.
    case notifyXalign = "notify::xalign"
    /// If the child of the button is a `GtkMisc` or `GtkAlignment`, this property
    /// can be used to control its vertical alignment. 0.0 is top aligned,
    /// 1.0 is bottom aligned.
    ///
    /// **yalign is deprecated:**
    /// Access the child widget directly if you need to control
    /// its alignment.
    case notifyYalign = "notify::yalign"
}

public extension CheckButtonProtocol {
    /// Connect a `CheckButtonSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: CheckButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(check_button_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension CheckButtonProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCheckButton` instance.
    var check_button_ptr: UnsafeMutablePointer<GtkCheckButton> { return ptr.assumingMemoryBound(to: GtkCheckButton.self) }

}



// MARK: - CheckMenuItem Class

/// The `CheckMenuItemProtocol` protocol exposes the methods and properties of an underlying `GtkCheckMenuItem` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CheckMenuItem`.
/// Alternatively, use `CheckMenuItemRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkCheckMenuItem` is a menu item that maintains the state of a boolean
/// value in addition to a `GtkMenuItem` usual role in activating application
/// code.
/// 
/// A check box indicating the state of the boolean value is displayed
/// at the left side of the `GtkMenuItem`.  Activating the `GtkMenuItem`
/// toggles the value.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// menuitem
/// ├── check.left
/// ╰── <child>
/// ```
/// 
/// GtkCheckMenuItem has a main CSS node with name menuitem, and a subnode
/// with name check, which gets the .left or .right style class.
public protocol CheckMenuItemProtocol: MenuItemProtocol {
    /// Untyped pointer to the underlying `GtkCheckMenuItem` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkCheckMenuItem` instance.
    var check_menu_item_ptr: UnsafeMutablePointer<GtkCheckMenuItem> { get }
}

/// The `CheckMenuItemRef` type acts as a lightweight Swift reference to an underlying `GtkCheckMenuItem` instance.
/// It exposes methods that can operate on this data type through `CheckMenuItemProtocol` conformance.
/// Use `CheckMenuItemRef` only as an `unowned` reference to an existing `GtkCheckMenuItem` instance.
///
/// A `GtkCheckMenuItem` is a menu item that maintains the state of a boolean
/// value in addition to a `GtkMenuItem` usual role in activating application
/// code.
/// 
/// A check box indicating the state of the boolean value is displayed
/// at the left side of the `GtkMenuItem`.  Activating the `GtkMenuItem`
/// toggles the value.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// menuitem
/// ├── check.left
/// ╰── <child>
/// ```
/// 
/// GtkCheckMenuItem has a main CSS node with name menuitem, and a subnode
/// with name check, which gets the .left or .right style class.
public struct CheckMenuItemRef: CheckMenuItemProtocol {
    /// Untyped pointer to the underlying `GtkCheckMenuItem` instance.
    /// For type-safe access, use the generated, typed pointer `check_menu_item_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension CheckMenuItemRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkCheckMenuItem>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `CheckMenuItemProtocol`
    init<T: CheckMenuItemProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckMenuItemProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckMenuItemProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckMenuItemProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckMenuItemProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckMenuItemProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCheckMenuItem`.
    init() {
        let rv = gtk_check_menu_item_new()
        self.init(cast(rv))
    }

    /// Creates a new `GtkCheckMenuItem` with a label.
    init(label: UnsafePointer<gchar>) {
        let rv = gtk_check_menu_item_new_with_label(label)
        self.init(cast(rv))
    }

    /// Creates a new `GtkCheckMenuItem` containing a label. The label
    /// will be created using `gtk_label_new_with_mnemonic()`, so underscores
    /// in `label` indicate the mnemonic for the menu item.
    init(mnemonic label: UnsafePointer<gchar>) {
        let rv = gtk_check_menu_item_new_with_mnemonic(label)
        self.init(cast(rv))
    }
    /// Creates a new `GtkCheckMenuItem` with a label.
    static func checkMenuItemNewWith(label: UnsafePointer<gchar>) -> CheckMenuItemRef! {
        let rv = gtk_check_menu_item_new_with_label(label)
        return rv.map { CheckMenuItemRef(cast($0)) }
    }

    /// Creates a new `GtkCheckMenuItem` containing a label. The label
    /// will be created using `gtk_label_new_with_mnemonic()`, so underscores
    /// in `label` indicate the mnemonic for the menu item.
    static func checkMenuItemNewWith(mnemonic label: UnsafePointer<gchar>) -> CheckMenuItemRef! {
        let rv = gtk_check_menu_item_new_with_mnemonic(label)
        return rv.map { CheckMenuItemRef(cast($0)) }
    }
}

/// The `CheckMenuItem` type acts as a reference-counted owner of an underlying `GtkCheckMenuItem` instance.
/// It provides the methods that can operate on this data type through `CheckMenuItemProtocol` conformance.
/// Use `CheckMenuItem` as a strong reference or owner of a `GtkCheckMenuItem` instance.
///
/// A `GtkCheckMenuItem` is a menu item that maintains the state of a boolean
/// value in addition to a `GtkMenuItem` usual role in activating application
/// code.
/// 
/// A check box indicating the state of the boolean value is displayed
/// at the left side of the `GtkMenuItem`.  Activating the `GtkMenuItem`
/// toggles the value.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// menuitem
/// ├── check.left
/// ╰── <child>
/// ```
/// 
/// GtkCheckMenuItem has a main CSS node with name menuitem, and a subnode
/// with name check, which gets the .left or .right style class.
open class CheckMenuItem: MenuItem, CheckMenuItemProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `CheckMenuItem` instance.
    public init(_ op: UnsafeMutablePointer<GtkCheckMenuItem>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `CheckMenuItemProtocol`
    /// Will retain `GtkCheckMenuItem`.
    public convenience init<T: CheckMenuItemProtocol>(_ other: T) {
        self.init(cast(other.check_menu_item_ptr))
        g_object_ref(cast(check_menu_item_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckMenuItemProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkCheckMenuItem.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckMenuItemProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkCheckMenuItem.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckMenuItemProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkCheckMenuItem.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckMenuItemProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkCheckMenuItem>(opaquePointer))
    }

    /// Creates a new `GtkCheckMenuItem`.
    public convenience init() {
        let rv = gtk_check_menu_item_new()
        self.init(cast(rv))
    }

    /// Creates a new `GtkCheckMenuItem` with a label.
    public convenience init(label: UnsafePointer<gchar>) {
        let rv = gtk_check_menu_item_new_with_label(label)
        self.init(cast(rv))
    }

    /// Creates a new `GtkCheckMenuItem` containing a label. The label
    /// will be created using `gtk_label_new_with_mnemonic()`, so underscores
    /// in `label` indicate the mnemonic for the menu item.
    public convenience init(mnemonic label: UnsafePointer<gchar>) {
        let rv = gtk_check_menu_item_new_with_mnemonic(label)
        self.init(cast(rv))
    }

    /// Creates a new `GtkCheckMenuItem` with a label.
    public static func checkMenuItemNewWith(label: UnsafePointer<gchar>) -> CheckMenuItem! {
        let rv = gtk_check_menu_item_new_with_label(label)
        return rv.map { CheckMenuItem(cast($0)) }
    }

    /// Creates a new `GtkCheckMenuItem` containing a label. The label
    /// will be created using `gtk_label_new_with_mnemonic()`, so underscores
    /// in `label` indicate the mnemonic for the menu item.
    public static func checkMenuItemNewWith(mnemonic label: UnsafePointer<gchar>) -> CheckMenuItem! {
        let rv = gtk_check_menu_item_new_with_mnemonic(label)
        return rv.map { CheckMenuItem(cast($0)) }
    }

}

public enum CheckMenuItemPropertyName: String, PropertyNameProtocol {
    /// Sets the accelerator path of the menu item, through which runtime
    /// changes of the menu item's accelerator caused by the user can be
    /// identified and saved to persistant storage.
    case accelPath = "accel-path"
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case active = "active"
    case appPaintable = "app-paintable"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case compositeChild = "composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case drawAsRadio = "draw-as-radio"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    case inconsistent = "inconsistent"
    case isFocus = "is-focus"
    /// The text for the child label.
    case label = "label"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case resizeMode = "resize-mode"
    /// Sets whether the menu item appears justified
    /// at the right side of a menu bar.
    case rightJustified = "right-justified"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    /// The submenu attached to the menu item, or `nil` if it has none.
    case submenu = "submenu"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// `true` if underlines in the text indicate mnemonics.
    case useUnderline = "use-underline"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
}

public extension CheckMenuItemProtocol {
    /// Bind a `CheckMenuItemPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CheckMenuItemPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(check_menu_item_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum CheckMenuItemSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    /// Emitted when the item is activated.
    case activate = "activate"
    /// Emitted when the item is activated, but also if the menu item has a
    /// submenu. For normal applications, the relevant signal is
    /// `GtkMenuItem::activate`.
    case activateItem = "activate-item"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    case add = "add"
    /// The `button`-press-event signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button`-release-event signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child`-notify signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The `composited`-changed signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure`-event signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete`-event signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    case deselect = "deselect"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy`-event signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag`-begin signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag`-data-delete signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag`-data-get signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag`-data-received signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag`-drop signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag`-drop signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag`-data-received handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag`-end signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag`-begin.
    case dragEnd = "drag-end"
    /// The `drag`-failed signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag`-leave signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag`-motion, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag`-leave signal is also emitted before the
    /// `drag`-drop signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag`-motion signal handler.
    case dragLeave = "drag-leave"
    /// The `drag`-motion signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag`-data-received
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag`-leave and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enter`-notify-event will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key`-press-event) and finally a generic
    /// `GtkWidget::event`-after signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event`-after will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `focus`-in-event signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus`-out-event signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab`-notify signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy`-changed signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key`-press-event signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key`-release-event signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `leave`-notify-event will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map`-event will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map`-event signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion`-notify-event signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent`-set signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The `property`-notify-event signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// The `screen`-changed signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll`-event signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    case select = "select"
    /// The `selection`-clear-event signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection`-request-event signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-changed signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style`-set signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style`-updated signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style`-updated signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    case toggleSizeAllocate = "toggle-size-allocate"
    case toggleSizeRequest = "toggle-size-request"
    /// This signal is emitted when the state of the check box is changed.
    /// 
    /// A signal handler can use `gtk_check_menu_item_get_active()`
    /// to discover the new state.
    case toggled = "toggled"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap`-event signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility`-notify-event will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    /// The `window`-state-event will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    /// Sets the accelerator path of the menu item, through which runtime
    /// changes of the menu item's accelerator caused by the user can be
    /// identified and saved to persistant storage.
    case notifyAccelPath = "notify::accel-path"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyActive = "notify::active"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyDrawAsRadio = "notify::draw-as-radio"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    case notifyInconsistent = "notify::inconsistent"
    case notifyIsFocus = "notify::is-focus"
    /// The text for the child label.
    case notifyLabel = "notify::label"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizeMode = "notify::resize-mode"
    /// Sets whether the menu item appears justified
    /// at the right side of a menu bar.
    case notifyRightJustified = "notify::right-justified"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    /// The submenu attached to the menu item, or `nil` if it has none.
    case notifySubmenu = "notify::submenu"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// `true` if underlines in the text indicate mnemonics.
    case notifyUseUnderline = "notify::use-underline"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
}

public extension CheckMenuItemProtocol {
    /// Connect a `CheckMenuItemSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: CheckMenuItemSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(check_menu_item_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension CheckMenuItemProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCheckMenuItem` instance.
    var check_menu_item_ptr: UnsafeMutablePointer<GtkCheckMenuItem> { return ptr.assumingMemoryBound(to: GtkCheckMenuItem.self) }

    /// Returns whether the check menu item is active. See
    /// gtk_check_menu_item_set_active ().
    func getActive() -> Bool {
        let rv = gtk_check_menu_item_get_active(cast(check_menu_item_ptr))
        return Bool(rv != 0)
    }

    /// Returns whether `check_menu_item` looks like a `GtkRadioMenuItem`
    func getDrawAsRadio() -> Bool {
        let rv = gtk_check_menu_item_get_draw_as_radio(cast(check_menu_item_ptr))
        return Bool(rv != 0)
    }

    /// Retrieves the value set by `gtk_check_menu_item_set_inconsistent()`.
    func getInconsistent() -> Bool {
        let rv = gtk_check_menu_item_get_inconsistent(cast(check_menu_item_ptr))
        return Bool(rv != 0)
    }

    /// Sets the active state of the menu item’s check box.
    func setActive(isActive is_active: Bool) {
        gtk_check_menu_item_set_active(cast(check_menu_item_ptr), gboolean(is_active ? 1 : 0))
    
    }

    /// Sets whether `check_menu_item` is drawn like a `GtkRadioMenuItem`
    func set(drawAsRadio draw_as_radio: Bool) {
        gtk_check_menu_item_set_draw_as_radio(cast(check_menu_item_ptr), gboolean(draw_as_radio ? 1 : 0))
    
    }

    /// If the user has selected a range of elements (such as some text or
    /// spreadsheet cells) that are affected by a boolean setting, and the
    /// current values in that range are inconsistent, you may want to
    /// display the check in an “in between” state. This function turns on
    /// “in between” display.  Normally you would turn off the inconsistent
    /// state again if the user explicitly selects a setting. This has to be
    /// done manually, `gtk_check_menu_item_set_inconsistent()` only affects
    /// visual appearance, it doesn’t affect the semantics of the widget.
    func setInconsistent(setting: Bool) {
        gtk_check_menu_item_set_inconsistent(cast(check_menu_item_ptr), gboolean(setting ? 1 : 0))
    
    }

    /// Emits the `GtkCheckMenuItem::toggled` signal.
    func toggled() {
        gtk_check_menu_item_toggled(cast(check_menu_item_ptr))
    
    }
    var active: Bool {
        /// Returns whether the check menu item is active. See
        /// gtk_check_menu_item_set_active ().
        get {
            let rv = gtk_check_menu_item_get_active(cast(check_menu_item_ptr))
            return Bool(rv != 0)
        }
        /// Sets the active state of the menu item’s check box.
        nonmutating set {
            gtk_check_menu_item_set_active(cast(check_menu_item_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Returns whether `check_menu_item` looks like a `GtkRadioMenuItem`
    var drawAsRadio: Bool {
        /// Returns whether `check_menu_item` looks like a `GtkRadioMenuItem`
        get {
            let rv = gtk_check_menu_item_get_draw_as_radio(cast(check_menu_item_ptr))
            return Bool(rv != 0)
        }
        /// Sets whether `check_menu_item` is drawn like a `GtkRadioMenuItem`
        nonmutating set {
            gtk_check_menu_item_set_draw_as_radio(cast(check_menu_item_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    var inconsistent: Bool {
        /// Retrieves the value set by `gtk_check_menu_item_set_inconsistent()`.
        get {
            let rv = gtk_check_menu_item_get_inconsistent(cast(check_menu_item_ptr))
            return Bool(rv != 0)
        }
        /// If the user has selected a range of elements (such as some text or
        /// spreadsheet cells) that are affected by a boolean setting, and the
        /// current values in that range are inconsistent, you may want to
        /// display the check in an “in between” state. This function turns on
        /// “in between” display.  Normally you would turn off the inconsistent
        /// state again if the user explicitly selects a setting. This has to be
        /// done manually, `gtk_check_menu_item_set_inconsistent()` only affects
        /// visual appearance, it doesn’t affect the semantics of the widget.
        nonmutating set {
            gtk_check_menu_item_set_inconsistent(cast(check_menu_item_ptr), gboolean(newValue ? 1 : 0))
        }
    }
}



// MARK: - CheckMenuItemAccessible Class

/// The `CheckMenuItemAccessibleProtocol` protocol exposes the methods and properties of an underlying `GtkCheckMenuItemAccessible` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CheckMenuItemAccessible`.
/// Alternatively, use `CheckMenuItemAccessibleRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///

public protocol CheckMenuItemAccessibleProtocol: MenuItemAccessibleProtocol {
    /// Untyped pointer to the underlying `GtkCheckMenuItemAccessible` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkCheckMenuItemAccessible` instance.
    var check_menu_item_accessible_ptr: UnsafeMutablePointer<GtkCheckMenuItemAccessible> { get }
}

/// The `CheckMenuItemAccessibleRef` type acts as a lightweight Swift reference to an underlying `GtkCheckMenuItemAccessible` instance.
/// It exposes methods that can operate on this data type through `CheckMenuItemAccessibleProtocol` conformance.
/// Use `CheckMenuItemAccessibleRef` only as an `unowned` reference to an existing `GtkCheckMenuItemAccessible` instance.
///

public struct CheckMenuItemAccessibleRef: CheckMenuItemAccessibleProtocol {
    /// Untyped pointer to the underlying `GtkCheckMenuItemAccessible` instance.
    /// For type-safe access, use the generated, typed pointer `check_menu_item_accessible_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension CheckMenuItemAccessibleRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkCheckMenuItemAccessible>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `CheckMenuItemAccessibleProtocol`
    init<T: CheckMenuItemAccessibleProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckMenuItemAccessibleProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckMenuItemAccessibleProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckMenuItemAccessibleProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckMenuItemAccessibleProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckMenuItemAccessibleProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `CheckMenuItemAccessible` type acts as a reference-counted owner of an underlying `GtkCheckMenuItemAccessible` instance.
/// It provides the methods that can operate on this data type through `CheckMenuItemAccessibleProtocol` conformance.
/// Use `CheckMenuItemAccessible` as a strong reference or owner of a `GtkCheckMenuItemAccessible` instance.
///

open class CheckMenuItemAccessible: MenuItemAccessible, CheckMenuItemAccessibleProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `CheckMenuItemAccessible` instance.
    public init(_ op: UnsafeMutablePointer<GtkCheckMenuItemAccessible>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `CheckMenuItemAccessibleProtocol`
    /// Will retain `GtkCheckMenuItemAccessible`.
    public convenience init<T: CheckMenuItemAccessibleProtocol>(_ other: T) {
        self.init(cast(other.check_menu_item_accessible_ptr))
        g_object_ref(cast(check_menu_item_accessible_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckMenuItemAccessibleProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkCheckMenuItemAccessible.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckMenuItemAccessibleProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkCheckMenuItemAccessible.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckMenuItemAccessibleProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkCheckMenuItemAccessible.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckMenuItemAccessibleProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkCheckMenuItemAccessible>(opaquePointer))
    }



}

public enum CheckMenuItemAccessiblePropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case widget = "widget"
}

public extension CheckMenuItemAccessibleProtocol {
    /// Bind a `CheckMenuItemAccessiblePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CheckMenuItemAccessiblePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(check_menu_item_accessible_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum CheckMenuItemAccessibleSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyWidget = "notify::widget"
}

public extension CheckMenuItemAccessibleProtocol {
    /// Connect a `CheckMenuItemAccessibleSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: CheckMenuItemAccessibleSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(check_menu_item_accessible_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension CheckMenuItemAccessibleProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCheckMenuItemAccessible` instance.
    var check_menu_item_accessible_ptr: UnsafeMutablePointer<GtkCheckMenuItemAccessible> { return ptr.assumingMemoryBound(to: GtkCheckMenuItemAccessible.self) }

}



// MARK: - Clipboard Class

/// The `ClipboardProtocol` protocol exposes the methods and properties of an underlying `GtkClipboard` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Clipboard`.
/// Alternatively, use `ClipboardRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///

public protocol ClipboardProtocol: GLibObject.ObjectProtocol {
    /// Untyped pointer to the underlying `GtkClipboard` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkClipboard` instance.
    var clipboard_ptr: UnsafeMutablePointer<GtkClipboard> { get }
}

/// The `ClipboardRef` type acts as a lightweight Swift reference to an underlying `GtkClipboard` instance.
/// It exposes methods that can operate on this data type through `ClipboardProtocol` conformance.
/// Use `ClipboardRef` only as an `unowned` reference to an existing `GtkClipboard` instance.
///

public struct ClipboardRef: ClipboardProtocol {
    /// Untyped pointer to the underlying `GtkClipboard` instance.
    /// For type-safe access, use the generated, typed pointer `clipboard_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension ClipboardRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkClipboard>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `ClipboardProtocol`
    init<T: ClipboardProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClipboardProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClipboardProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClipboardProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClipboardProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClipboardProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        static func clipboardGet(selection: Gdk.Atom) -> ClipboardRef! {
        let rv = gtk_clipboard_get(cast(selection.ptr))
        return rv.map { ClipboardRef(cast($0)) }
    }

    /// Returns the default clipboard object for use with cut/copy/paste menu items
    /// and keyboard shortcuts.
    static func getDefault(display: DisplayProtocol) -> ClipboardRef! {
        let rv: UnsafeMutablePointer<GtkClipboard>? = nil // gtk_clipboard_get_default(cast(display.ptr))
        return rv.map { ClipboardRef(cast($0)) }
    }

    static func getFor(display: DisplayProtocol, selection: Gdk.Atom) -> ClipboardRef! {
        let rv = gtk_clipboard_get_for_display(cast(display.ptr), cast(selection.ptr))
        return rv.map { ClipboardRef(cast($0)) }
    }
}

/// The `Clipboard` type acts as a reference-counted owner of an underlying `GtkClipboard` instance.
/// It provides the methods that can operate on this data type through `ClipboardProtocol` conformance.
/// Use `Clipboard` as a strong reference or owner of a `GtkClipboard` instance.
///

open class Clipboard: GLibObject.Object, ClipboardProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `Clipboard` instance.
    public init(_ op: UnsafeMutablePointer<GtkClipboard>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `ClipboardProtocol`
    /// Will retain `GtkClipboard`.
    public convenience init<T: ClipboardProtocol>(_ other: T) {
        self.init(cast(other.clipboard_ptr))
        g_object_ref(cast(clipboard_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClipboardProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkClipboard.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClipboardProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkClipboard.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClipboardProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkClipboard.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClipboardProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkClipboard>(opaquePointer))
    }


    public static func clipboardGet(selection: Gdk.Atom) -> Clipboard! {
        let rv = gtk_clipboard_get(cast(selection.ptr))
        return rv.map { Clipboard(cast($0)) }
    }

    /// Returns the default clipboard object for use with cut/copy/paste menu items
    /// and keyboard shortcuts.
    public static func getDefault(display: DisplayProtocol) -> Clipboard! {
        let rv: UnsafeMutablePointer<GtkClipboard>? = nil // gtk_clipboard_get_default(cast(display.ptr))
        return rv.map { Clipboard(cast($0)) }
    }

    public static func getFor(display: DisplayProtocol, selection: Gdk.Atom) -> Clipboard! {
        let rv = gtk_clipboard_get_for_display(cast(display.ptr), cast(selection.ptr))
        return rv.map { Clipboard(cast($0)) }
    }

}

// MARK: - no Clipboard properties

public enum ClipboardSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case ownerChange = "owner-change"

}

public extension ClipboardProtocol {
    /// Connect a `ClipboardSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: ClipboardSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(clipboard_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension ClipboardProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkClipboard` instance.
    var clipboard_ptr: UnsafeMutablePointer<GtkClipboard> { return ptr.assumingMemoryBound(to: GtkClipboard.self) }

    func clear() {
        gtk_clipboard_clear(cast(clipboard_ptr))
    
    }

    func getDisplay() -> UnsafeMutablePointer<GdkDisplay>! {
        let rv = gtk_clipboard_get_display(cast(clipboard_ptr))
        return cast(rv)
    }

    func getOwner() -> UnsafeMutablePointer<GObject>! {
        let rv = gtk_clipboard_get_owner(cast(clipboard_ptr))
        return cast(rv)
    }

    func getSelection() -> GdkAtom! {
        let rv: GdkAtom! = nil
        return rv
    }

    func requestContents(target: Gdk.Atom, callback: @escaping ClipboardReceivedFunc, userData user_data: UnsafeMutableRawPointer) {
        gtk_clipboard_request_contents(cast(clipboard_ptr), cast(target.ptr), callback, cast(user_data))
    
    }

    func requestImage(callback: @escaping ClipboardImageReceivedFunc, userData user_data: UnsafeMutableRawPointer) {
        gtk_clipboard_request_image(cast(clipboard_ptr), callback, cast(user_data))
    
    }

    func requestRichText(buffer: TextBufferProtocol, callback: @escaping ClipboardRichTextReceivedFunc, userData user_data: UnsafeMutableRawPointer) {
        gtk_clipboard_request_rich_text(cast(clipboard_ptr), cast(buffer.ptr), callback, cast(user_data))
    
    }

    func requestTargets(callback: @escaping ClipboardTargetsReceivedFunc, userData user_data: UnsafeMutableRawPointer) {
        gtk_clipboard_request_targets(cast(clipboard_ptr), callback, cast(user_data))
    
    }

    func requestText(callback: @escaping ClipboardTextReceivedFunc, userData user_data: UnsafeMutableRawPointer) {
        gtk_clipboard_request_text(cast(clipboard_ptr), callback, cast(user_data))
    
    }

    func requestURIs(callback: @escaping ClipboardURIReceivedFunc, userData user_data: UnsafeMutableRawPointer) {
        gtk_clipboard_request_uris(cast(clipboard_ptr), callback, cast(user_data))
    
    }

    func setCanStore(targets: UnsafePointer<GtkTargetEntry>, nTargets n_targets: CInt) {
        gtk_clipboard_set_can_store(cast(clipboard_ptr), cast(targets), gint(n_targets))
    
    }

    func setImage(pixbuf: PixbufProtocol) {
        gtk_clipboard_set_image(cast(clipboard_ptr), cast(pixbuf.ptr))
    
    }

    func set(text: UnsafePointer<gchar>, len: CInt) {
        gtk_clipboard_set_text(cast(clipboard_ptr), text, gint(len))
    
    }

    func setWithData(targets: UnsafePointer<GtkTargetEntry>, nTargets n_targets: CUnsignedInt, getFunc get_func: @escaping ClipboardGetFunc, clearFunc clear_func: @escaping ClipboardClearFunc, userData user_data: UnsafeMutableRawPointer) -> Bool {
        let rv = gtk_clipboard_set_with_data(cast(clipboard_ptr), cast(targets), guint(n_targets), get_func, clear_func, cast(user_data))
        return Bool(rv != 0)
    }

    func setWithOwner(targets: UnsafePointer<GtkTargetEntry>, nTargets n_targets: CUnsignedInt, getFunc get_func: @escaping ClipboardGetFunc, clearFunc clear_func: @escaping ClipboardClearFunc, owner: GLibObject.ObjectProtocol) -> Bool {
        let rv = gtk_clipboard_set_with_owner(cast(clipboard_ptr), cast(targets), guint(n_targets), get_func, clear_func, cast(owner.ptr))
        return Bool(rv != 0)
    }

    func store() {
        gtk_clipboard_store(cast(clipboard_ptr))
    
    }

    func waitForContents(target: Gdk.Atom) -> UnsafeMutablePointer<GtkSelectionData>! {
        let rv = gtk_clipboard_wait_for_contents(cast(clipboard_ptr), cast(target.ptr))
        return cast(rv)
    }

    func waitForImage() -> UnsafeMutablePointer<GdkPixbuf>! {
        let rv = gtk_clipboard_wait_for_image(cast(clipboard_ptr))
        return cast(rv)
    }

    func waitForRichText(buffer: TextBufferProtocol, format: AtomProtocol, length: UnsafeMutablePointer<Int>) -> UnsafeMutablePointer<UInt8>! {
        let rv = gtk_clipboard_wait_for_rich_text(cast(clipboard_ptr), cast(buffer.ptr), cast(format.ptr), cast(length))
        return cast(rv)
    }

    /// Returns a list of targets that are present on the clipboard, or `nil`
    /// if there aren’t any targets available. The returned list must be
    /// freed with `g_free()`.
    /// This function waits for the data to be received using the main
    /// loop, so events, timeouts, etc, may be dispatched during the wait.
    func waitFor(targets: UnsafeMutablePointer<UnsafeMutablePointer<GdkAtom>>, nTargets n_targets: UnsafeMutablePointer<CInt>) -> Bool {
        let rv = gtk_clipboard_wait_for_targets(cast(clipboard_ptr), cast(targets), cast(n_targets))
        return Bool(rv != 0)
    }

    func waitForText() -> String! {
        let rv = gtk_clipboard_wait_for_text(cast(clipboard_ptr))
        return rv.map { String(cString: UnsafePointer<CChar>($0)) }
    }

    func waitForURIs() -> UnsafeMutablePointer<UnsafeMutablePointer<gchar>>! {
        let rv = gtk_clipboard_wait_for_uris(cast(clipboard_ptr))
        return cast(rv)
    }

    func waitIsImageAvailable() -> Bool {
        let rv = gtk_clipboard_wait_is_image_available(cast(clipboard_ptr))
        return Bool(rv != 0)
    }

    func waitIsRichTextAvailable(buffer: TextBufferProtocol) -> Bool {
        let rv = gtk_clipboard_wait_is_rich_text_available(cast(clipboard_ptr), cast(buffer.ptr))
        return Bool(rv != 0)
    }

    func waitIsTargetAvailable(target: Gdk.Atom) -> Bool {
        let rv = gtk_clipboard_wait_is_target_available(cast(clipboard_ptr), cast(target.ptr))
        return Bool(rv != 0)
    }

    func waitIsTextAvailable() -> Bool {
        let rv = gtk_clipboard_wait_is_text_available(cast(clipboard_ptr))
        return Bool(rv != 0)
    }

    func waitIsURIsAvailable() -> Bool {
        let rv = gtk_clipboard_wait_is_uris_available(cast(clipboard_ptr))
        return Bool(rv != 0)
    }
    var display: UnsafeMutablePointer<GdkDisplay>! {
        get {
            let rv = gtk_clipboard_get_display(cast(clipboard_ptr))
            return cast(rv)
        }
    }

    var owner: UnsafeMutablePointer<GObject>! {
        get {
            let rv = gtk_clipboard_get_owner(cast(clipboard_ptr))
            return cast(rv)
        }
    }

    var selection: GdkAtom! {
        get {
            let rv: GdkAtom! = nil
            return rv
        }
    }
}



// MARK: - ColorButton Class

/// The `ColorButtonProtocol` protocol exposes the methods and properties of an underlying `GtkColorButton` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ColorButton`.
/// Alternatively, use `ColorButtonRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// The `GtkColorButton` is a button which displays the currently selected
/// color and allows to open a color selection dialog to change the color.
/// It is suitable widget for selecting a color in a preference dialog.
/// 
/// # CSS nodes
/// 
/// GtkColorButton has a single CSS node with name button. To differentiate
/// it from a plain `GtkButton`, it gets the .color style class.
public protocol ColorButtonProtocol: ButtonProtocol, ColorChooserProtocol {
    /// Untyped pointer to the underlying `GtkColorButton` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkColorButton` instance.
    var color_button_ptr: UnsafeMutablePointer<GtkColorButton> { get }
}

/// The `ColorButtonRef` type acts as a lightweight Swift reference to an underlying `GtkColorButton` instance.
/// It exposes methods that can operate on this data type through `ColorButtonProtocol` conformance.
/// Use `ColorButtonRef` only as an `unowned` reference to an existing `GtkColorButton` instance.
///
/// The `GtkColorButton` is a button which displays the currently selected
/// color and allows to open a color selection dialog to change the color.
/// It is suitable widget for selecting a color in a preference dialog.
/// 
/// # CSS nodes
/// 
/// GtkColorButton has a single CSS node with name button. To differentiate
/// it from a plain `GtkButton`, it gets the .color style class.
public struct ColorButtonRef: ColorButtonProtocol {
    /// Untyped pointer to the underlying `GtkColorButton` instance.
    /// For type-safe access, use the generated, typed pointer `color_button_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension ColorButtonRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkColorButton>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `ColorButtonProtocol`
    init<T: ColorButtonProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new color button.
    /// 
    /// This returns a widget in the form of a small button containing
    /// a swatch representing the current selected color. When the button
    /// is clicked, a color-selection dialog will open, allowing the user
    /// to select a color. The swatch will be updated to reflect the new
    /// color when the user finishes.
    init() {
        let rv = gtk_color_button_new()
        self.init(cast(rv))
    }

    /// Creates a new color button.
    ///
    /// **new_with_color is deprecated:**
    /// Use gtk_color_button_new_with_rgba() instead.
    @available(*, deprecated) init(color: Gdk.ColorProtocol) {
        let rv = gtk_color_button_new_with_color(cast(color.ptr))
        self.init(cast(rv))
    }

    /// Creates a new color button.
    init(rgba: RGBAProtocol) {
        let rv = gtk_color_button_new_with_rgba(cast(rgba.ptr))
        self.init(cast(rv))
    }
    /// Creates a new color button.
    ///
    /// **new_with_color is deprecated:**
    /// Use gtk_color_button_new_with_rgba() instead.
    @available(*, deprecated) static func newWith(color: Gdk.ColorProtocol) -> ColorButtonRef! {
        let rv = gtk_color_button_new_with_color(cast(color.ptr))
        return rv.map { ColorButtonRef(cast($0)) }
    }

    /// Creates a new color button.
    static func newWith(rgba: RGBAProtocol) -> ColorButtonRef! {
        let rv = gtk_color_button_new_with_rgba(cast(rgba.ptr))
        return rv.map { ColorButtonRef(cast($0)) }
    }
}

/// The `ColorButton` type acts as a reference-counted owner of an underlying `GtkColorButton` instance.
/// It provides the methods that can operate on this data type through `ColorButtonProtocol` conformance.
/// Use `ColorButton` as a strong reference or owner of a `GtkColorButton` instance.
///
/// The `GtkColorButton` is a button which displays the currently selected
/// color and allows to open a color selection dialog to change the color.
/// It is suitable widget for selecting a color in a preference dialog.
/// 
/// # CSS nodes
/// 
/// GtkColorButton has a single CSS node with name button. To differentiate
/// it from a plain `GtkButton`, it gets the .color style class.
open class ColorButton: Button, ColorButtonProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `ColorButton` instance.
    public init(_ op: UnsafeMutablePointer<GtkColorButton>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `ColorButtonProtocol`
    /// Will retain `GtkColorButton`.
    public convenience init<T: ColorButtonProtocol>(_ other: T) {
        self.init(cast(other.color_button_ptr))
        g_object_ref(cast(color_button_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkColorButton.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkColorButton.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkColorButton.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkColorButton>(opaquePointer))
    }

    /// Creates a new color button.
    /// 
    /// This returns a widget in the form of a small button containing
    /// a swatch representing the current selected color. When the button
    /// is clicked, a color-selection dialog will open, allowing the user
    /// to select a color. The swatch will be updated to reflect the new
    /// color when the user finishes.
    public convenience init() {
        let rv = gtk_color_button_new()
        self.init(cast(rv))
    }

    /// Creates a new color button.
    ///
    /// **new_with_color is deprecated:**
    /// Use gtk_color_button_new_with_rgba() instead.
    @available(*, deprecated) public convenience init(color: Gdk.ColorProtocol) {
        let rv = gtk_color_button_new_with_color(cast(color.ptr))
        self.init(cast(rv))
    }

    /// Creates a new color button.
    public convenience init(rgba: RGBAProtocol) {
        let rv = gtk_color_button_new_with_rgba(cast(rgba.ptr))
        self.init(cast(rv))
    }

    /// Creates a new color button.
    ///
    /// **new_with_color is deprecated:**
    /// Use gtk_color_button_new_with_rgba() instead.
    @available(*, deprecated) public static func newWith(color: Gdk.ColorProtocol) -> ColorButton! {
        let rv = gtk_color_button_new_with_color(cast(color.ptr))
        return rv.map { ColorButton(cast($0)) }
    }

    /// Creates a new color button.
    public static func newWith(rgba: RGBAProtocol) -> ColorButton! {
        let rv = gtk_color_button_new_with_rgba(cast(rgba.ptr))
        return rv.map { ColorButton(cast($0)) }
    }

}

public enum ColorButtonPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    /// The selected opacity value (0 fully transparent, 65535 fully opaque).
    case alpha = "alpha"
    /// If `true`, the button will ignore the `GtkSettings:gtk`-button-images
    /// setting and always show the image, if available.
    /// 
    /// Use this property if the button would be useless or hard to use
    /// without the image.
    case alwaysShowImage = "always-show-image"
    case appPaintable = "app-paintable"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    /// The selected color.
    ///
    /// **color is deprecated:**
    /// Use #GtkColorButton:rgba instead.
    case color = "color"
    case compositeChild = "composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The child widget to appear next to the button text.
    case image = "image"
    /// The position of the image relative to the text inside the button.
    case imagePosition = "image-position"
    case isFocus = "is-focus"
    case label = "label"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case relief = "relief"
    case resizeMode = "resize-mode"
    /// The RGBA color.
    case rgba = "rgba"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// Set this property to `true` to skip the palette
    /// in the dialog and go directly to the color editor.
    /// 
    /// This property should be used in cases where the palette
    /// in the editor would be redundant, such as when the color
    /// button is already part of a palette.
    case showEditor = "show-editor"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    /// The title of the color selection dialog
    case title = "title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// If this property is set to `true`, the color swatch on the button is
    /// rendered against a checkerboard background to show its opacity and
    /// the opacity slider is displayed in the color selection dialog.
    case useAlpha = "use-alpha"

    ///
    /// **use-stock is deprecated:**
    /// This method is deprecated.
    case useStock = "use-stock"
    case useUnderline = "use-underline"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
    /// If the child of the button is a `GtkMisc` or `GtkAlignment`, this property
    /// can be used to control its horizontal alignment. 0.0 is left aligned,
    /// 1.0 is right aligned.
    ///
    /// **xalign is deprecated:**
    /// Access the child widget directly if you need to control
    /// its alignment.
    case xalign = "xalign"
    /// If the child of the button is a `GtkMisc` or `GtkAlignment`, this property
    /// can be used to control its vertical alignment. 0.0 is top aligned,
    /// 1.0 is bottom aligned.
    ///
    /// **yalign is deprecated:**
    /// Access the child widget directly if you need to control
    /// its alignment.
    case yalign = "yalign"
}

public extension ColorButtonProtocol {
    /// Bind a `ColorButtonPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ColorButtonPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(color_button_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum ColorButtonSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    /// The `activate` signal on GtkButton is an action signal and
    /// emitting it causes the button to animate press then release.
    /// Applications should never connect to this signal, but use the
    /// `GtkButton::clicked` signal.
    case activate = "activate"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    case add = "add"
    /// The `button`-press-event signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button`-release-event signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child`-notify signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// Emitted when the button has been activated (pressed and released).
    case clicked = "clicked"
    /// The `color`-set signal is emitted when the user selects a color.
    /// When handling this signal, use `gtk_color_button_get_rgba()` to
    /// find out which color was just selected.
    /// 
    /// Note that this signal is only emitted when the user
    /// changes the color. If you need to react to programmatic color changes
    /// as well, use the notify`color` signal.
    case colorSet = "color-set"
    /// The `composited`-changed signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure`-event signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete`-event signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy`-event signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag`-begin signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag`-data-delete signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag`-data-get signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag`-data-received signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag`-drop signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag`-drop signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag`-data-received handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag`-end signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag`-begin.
    case dragEnd = "drag-end"
    /// The `drag`-failed signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag`-leave signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag`-motion, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag`-leave signal is also emitted before the
    /// `drag`-drop signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag`-motion signal handler.
    case dragLeave = "drag-leave"
    /// The `drag`-motion signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag`-data-received
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag`-leave and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// Emitted when the pointer enters the button.
    ///
    /// **enter is deprecated:**
    /// Use the #GtkWidget::enter-notify-event signal.
    case enter = "enter"
    /// The `enter`-notify-event will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key`-press-event) and finally a generic
    /// `GtkWidget::event`-after signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event`-after will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `focus`-in-event signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus`-out-event signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab`-notify signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy`-changed signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key`-press-event signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key`-release-event signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when the pointer leaves the button.
    ///
    /// **leave is deprecated:**
    /// Use the #GtkWidget::leave-notify-event signal.
    case leave = "leave"
    /// The `leave`-notify-event will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map`-event will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map`-event signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion`-notify-event signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent`-set signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// Emitted when the button is pressed.
    ///
    /// **pressed is deprecated:**
    /// Use the #GtkWidget::button-press-event signal.
    case pressed = "pressed"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The `property`-notify-event signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when the button is released.
    ///
    /// **released is deprecated:**
    /// Use the #GtkWidget::button-release-event signal.
    case released = "released"
    case remove = "remove"
    /// The `screen`-changed signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll`-event signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `selection`-clear-event signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection`-request-event signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-changed signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style`-set signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style`-updated signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style`-updated signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap`-event signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility`-notify-event will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    /// The `window`-state-event will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    /// The selected opacity value (0 fully transparent, 65535 fully opaque).
    case notifyAlpha = "notify::alpha"
    /// If `true`, the button will ignore the `GtkSettings:gtk`-button-images
    /// setting and always show the image, if available.
    /// 
    /// Use this property if the button would be useless or hard to use
    /// without the image.
    case notifyAlwaysShowImage = "notify::always-show-image"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    /// The selected color.
    ///
    /// **color is deprecated:**
    /// Use #GtkColorButton:rgba instead.
    case notifyColor = "notify::color"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The child widget to appear next to the button text.
    case notifyImage = "notify::image"
    /// The position of the image relative to the text inside the button.
    case notifyImagePosition = "notify::image-position"
    case notifyIsFocus = "notify::is-focus"
    case notifyLabel = "notify::label"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyRelief = "notify::relief"
    case notifyResizeMode = "notify::resize-mode"
    /// The RGBA color.
    case notifyRGBA = "notify::rgba"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// Set this property to `true` to skip the palette
    /// in the dialog and go directly to the color editor.
    /// 
    /// This property should be used in cases where the palette
    /// in the editor would be redundant, such as when the color
    /// button is already part of a palette.
    case notifyShowEditor = "notify::show-editor"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    /// The title of the color selection dialog
    case notifyTitle = "notify::title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// If this property is set to `true`, the color swatch on the button is
    /// rendered against a checkerboard background to show its opacity and
    /// the opacity slider is displayed in the color selection dialog.
    case notifyUseAlpha = "notify::use-alpha"

    ///
    /// **use-stock is deprecated:**
    /// This method is deprecated.
    case notifyUseStock = "notify::use-stock"
    case notifyUseUnderline = "notify::use-underline"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
    /// If the child of the button is a `GtkMisc` or `GtkAlignment`, this property
    /// can be used to control its horizontal alignment. 0.0 is left aligned,
    /// 1.0 is right aligned.
    ///
    /// **xalign is deprecated:**
    /// Access the child widget directly if you need to control
    /// its alignment.
    case notifyXalign = "notify::xalign"
    /// If the child of the button is a `GtkMisc` or `GtkAlignment`, this property
    /// can be used to control its vertical alignment. 0.0 is top aligned,
    /// 1.0 is bottom aligned.
    ///
    /// **yalign is deprecated:**
    /// Access the child widget directly if you need to control
    /// its alignment.
    case notifyYalign = "notify::yalign"
}

public extension ColorButtonProtocol {
    /// Connect a `ColorButtonSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: ColorButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(color_button_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension ColorButtonProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkColorButton` instance.
    var color_button_ptr: UnsafeMutablePointer<GtkColorButton> { return ptr.assumingMemoryBound(to: GtkColorButton.self) }

    /// Returns the current alpha value.
    ///
    /// **get_alpha is deprecated:**
    /// Use gtk_color_chooser_get_rgba() instead.
    @available(*, deprecated) func getAlpha() -> UInt16 {
        let rv = gtk_color_button_get_alpha(cast(color_button_ptr))
        return UInt16(rv)
    }

    /// Sets `color` to be the current color in the `GtkColorButton` widget.
    ///
    /// **get_color is deprecated:**
    /// Use gtk_color_chooser_get_rgba() instead.
    @available(*, deprecated) func get(color: Gdk.ColorProtocol) {
        gtk_color_button_get_color(cast(color_button_ptr), cast(color.ptr))
    
    }

    /// Sets `rgba` to be the current color in the `GtkColorButton` widget.
    ///
    /// **get_rgba is deprecated:**
    /// Use gtk_color_chooser_get_rgba() instead.
    @available(*, deprecated) func get(rgba: RGBAProtocol) {
        gtk_color_button_get_rgba(cast(color_button_ptr), cast(rgba.ptr))
    
    }

    /// Gets the title of the color selection dialog.
    func getTitle() -> String! {
        let rv = gtk_color_button_get_title(cast(color_button_ptr))
        return rv.map { String(cString: UnsafePointer<CChar>($0)) }
    }

    /// Does the color selection dialog use the alpha channel ?
    ///
    /// **get_use_alpha is deprecated:**
    /// Use gtk_color_chooser_get_use_alpha() instead.
    @available(*, deprecated) func getUseAlpha() -> Bool {
        let rv = gtk_color_button_get_use_alpha(cast(color_button_ptr))
        return Bool(rv != 0)
    }

    /// Sets the current opacity to be `alpha`.
    ///
    /// **set_alpha is deprecated:**
    /// Use gtk_color_chooser_set_rgba() instead.
    @available(*, deprecated) func set(alpha: UInt16) {
        gtk_color_button_set_alpha(cast(color_button_ptr), guint16(alpha))
    
    }

    /// Sets the current color to be `color`.
    ///
    /// **set_color is deprecated:**
    /// Use gtk_color_chooser_set_rgba() instead.
    @available(*, deprecated) func set(color: Gdk.ColorProtocol) {
        gtk_color_button_set_color(cast(color_button_ptr), cast(color.ptr))
    
    }

    /// Sets the current color to be `rgba`.
    ///
    /// **set_rgba is deprecated:**
    /// Use gtk_color_chooser_set_rgba() instead.
    @available(*, deprecated) func set(rgba: RGBAProtocol) {
        gtk_color_button_set_rgba(cast(color_button_ptr), cast(rgba.ptr))
    
    }

    /// Sets the title for the color selection dialog.
    func set(title: UnsafePointer<gchar>) {
        gtk_color_button_set_title(cast(color_button_ptr), title)
    
    }

    /// Sets whether or not the color button should use the alpha channel.
    ///
    /// **set_use_alpha is deprecated:**
    /// Use gtk_color_chooser_set_use_alpha() instead.
    @available(*, deprecated) func set(useAlpha use_alpha: Bool) {
        gtk_color_button_set_use_alpha(cast(color_button_ptr), gboolean(use_alpha ? 1 : 0))
    
    }
    /// The selected opacity value (0 fully transparent, 65535 fully opaque).
    var alpha: UInt16 {
        /// Returns the current alpha value.
        ///
        /// **get_alpha is deprecated:**
        /// Use gtk_color_chooser_get_rgba() instead.
        @available(*, deprecated) get {
            let rv = gtk_color_button_get_alpha(cast(color_button_ptr))
            return UInt16(rv)
        }
        /// Sets the current opacity to be `alpha`.
        ///
        /// **set_alpha is deprecated:**
        /// Use gtk_color_chooser_set_rgba() instead.
        @available(*, deprecated) nonmutating set {
            gtk_color_button_set_alpha(cast(color_button_ptr), guint16(newValue))
        }
    }

    /// The title of the color selection dialog
    var title: String! {
        /// Gets the title of the color selection dialog.
        get {
            let rv = gtk_color_button_get_title(cast(color_button_ptr))
            return rv.map { String(cString: UnsafePointer<CChar>($0)) }
        }
        /// Sets the title for the color selection dialog.
        nonmutating set {
            gtk_color_button_set_title(cast(color_button_ptr), newValue)
        }
    }

    /// Does the color selection dialog use the alpha channel ?
    ///
    /// **get_use_alpha is deprecated:**
    /// Use gtk_color_chooser_get_use_alpha() instead.
    var useAlpha: Bool {
        /// Does the color selection dialog use the alpha channel ?
        ///
        /// **get_use_alpha is deprecated:**
        /// Use gtk_color_chooser_get_use_alpha() instead.
        @available(*, deprecated) get {
            let rv = gtk_color_button_get_use_alpha(cast(color_button_ptr))
            return Bool(rv != 0)
        }
        /// Sets whether or not the color button should use the alpha channel.
        ///
        /// **set_use_alpha is deprecated:**
        /// Use gtk_color_chooser_set_use_alpha() instead.
        @available(*, deprecated) nonmutating set {
            gtk_color_button_set_use_alpha(cast(color_button_ptr), gboolean(newValue ? 1 : 0))
        }
    }
}



// MARK: - ColorChooserDialog Class

/// The `ColorChooserDialogProtocol` protocol exposes the methods and properties of an underlying `GtkColorChooserDialog` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ColorChooserDialog`.
/// Alternatively, use `ColorChooserDialogRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// The `GtkColorChooserDialog` widget is a dialog for choosing
/// a color. It implements the `GtkColorChooser` interface.
public protocol ColorChooserDialogProtocol: DialogProtocol, ColorChooserProtocol {
    /// Untyped pointer to the underlying `GtkColorChooserDialog` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkColorChooserDialog` instance.
    var color_chooser_dialog_ptr: UnsafeMutablePointer<GtkColorChooserDialog> { get }
}

/// The `ColorChooserDialogRef` type acts as a lightweight Swift reference to an underlying `GtkColorChooserDialog` instance.
/// It exposes methods that can operate on this data type through `ColorChooserDialogProtocol` conformance.
/// Use `ColorChooserDialogRef` only as an `unowned` reference to an existing `GtkColorChooserDialog` instance.
///
/// The `GtkColorChooserDialog` widget is a dialog for choosing
/// a color. It implements the `GtkColorChooser` interface.
public struct ColorChooserDialogRef: ColorChooserDialogProtocol {
    /// Untyped pointer to the underlying `GtkColorChooserDialog` instance.
    /// For type-safe access, use the generated, typed pointer `color_chooser_dialog_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension ColorChooserDialogRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkColorChooserDialog>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `ColorChooserDialogProtocol`
    init<T: ColorChooserDialogProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkColorChooserDialog`.
    init( title: UnsafePointer<gchar>, parent: WindowProtocol) {
        let rv = gtk_color_chooser_dialog_new(title, cast(parent.ptr))
        self.init(cast(rv))
    }
}

/// The `ColorChooserDialog` type acts as a reference-counted owner of an underlying `GtkColorChooserDialog` instance.
/// It provides the methods that can operate on this data type through `ColorChooserDialogProtocol` conformance.
/// Use `ColorChooserDialog` as a strong reference or owner of a `GtkColorChooserDialog` instance.
///
/// The `GtkColorChooserDialog` widget is a dialog for choosing
/// a color. It implements the `GtkColorChooser` interface.
open class ColorChooserDialog: Dialog, ColorChooserDialogProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `ColorChooserDialog` instance.
    public init(_ op: UnsafeMutablePointer<GtkColorChooserDialog>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `ColorChooserDialogProtocol`
    /// Will retain `GtkColorChooserDialog`.
    public convenience init<T: ColorChooserDialogProtocol>(_ other: T) {
        self.init(cast(other.color_chooser_dialog_ptr))
        g_object_ref(cast(color_chooser_dialog_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkColorChooserDialog.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkColorChooserDialog.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkColorChooserDialog.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkColorChooserDialog>(opaquePointer))
    }

    /// Creates a new `GtkColorChooserDialog`.
    public convenience init( title: UnsafePointer<gchar>, parent: WindowProtocol) {
        let rv = gtk_color_chooser_dialog_new(title, cast(parent.ptr))
        self.init(cast(rv))
    }


}

public enum ColorChooserDialogPropertyName: String, PropertyNameProtocol {
    /// Whether the window should receive the input focus.
    case acceptFocus = "accept-focus"
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case appPaintable = "app-paintable"
    /// The `GtkApplication` associated with the window.
    /// 
    /// The application will be kept alive for at least as long as it
    /// has any windows associated with it (see `g_application_hold()`
    /// for a way to keep it alive without windows).
    /// 
    /// Normally, the connection between the application and the window
    /// will remain until the window is destroyed, but you can explicitly
    /// remove it by setting the :application property to `nil`.
    case application = "application"
    /// The widget to which this window is attached.
    /// See `gtk_window_set_attached_to()`.
    /// 
    /// Examples of places where specifying this relation is useful are
    /// for instance a `GtkMenu` created by a `GtkComboBox`, a completion
    /// popup window created by `GtkEntry` or a typeahead search entry
    /// created by `GtkTreeView`.
    case attachedTo = "attached-to"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case compositeChild = "composite-child"
    /// Whether the window should be decorated by the window manager.
    case decorated = "decorated"
    case defaultHeight = "default-height"
    case defaultWidth = "default-width"
    /// Whether the window frame should have a close button.
    case deletable = "deletable"
    case destroyWithParent = "destroy-with-parent"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// Whether the window should receive the input focus when mapped.
    case focusOnMap = "focus-on-map"
    /// Whether 'focus rectangles' are currently visible in this window.
    /// 
    /// This property is maintained by GTK+ based on user input
    /// and should not be set by applications.
    case focusVisible = "focus-visible"
    /// The window gravity of the window. See `gtk_window_move()` and `GdkGravity` for
    /// more details about window gravity.
    case gravity = "gravity"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Whether the window has a corner resize grip.
    /// 
    /// Note that the resize grip is only shown if the window is
    /// actually resizable and not maximized. Use
    /// `GtkWindow:resize`-grip-visible to find out if the resize
    /// grip is currently shown.
    ///
    /// **has-resize-grip is deprecated:**
    /// Resize grips have been removed.
    case hasResizeGrip = "has-resize-grip"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case hasToplevelFocus = "has-toplevel-focus"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// Whether the titlebar should be hidden during maximization.
    case hideTitlebarWhenMaximized = "hide-titlebar-when-maximized"
    case icon = "icon"
    /// The :icon-name property specifies the name of the themed icon to
    /// use as the window icon. See `GtkIconTheme` for more details.
    case iconName = "icon-name"
    case isActive = "is-active"
    case isFocus = "is-focus"
    case isMaximized = "is-maximized"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    /// Whether mnemonics are currently visible in this window.
    /// 
    /// This property is maintained by GTK+ based on user input,
    /// and should not be set by applications.
    case mnemonicsVisible = "mnemonics-visible"
    case modal = "modal"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case resizable = "resizable"
    /// Whether a corner resize grip is currently shown.
    ///
    /// **resize-grip-visible is deprecated:**
    /// Resize grips have been removed.
    case resizeGripVisible = "resize-grip-visible"
    case resizeMode = "resize-mode"
    case role = "role"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case screen = "screen"
    case sensitive = "sensitive"
    case showEditor = "show-editor"
    case skipPagerHint = "skip-pager-hint"
    case skipTaskbarHint = "skip-taskbar-hint"
    /// The :startup-id is a write-only property for setting window's
    /// startup notification identifier. See `gtk_window_set_startup_id()`
    /// for more details.
    case startupID = "startup-id"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    case title = "title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// The transient parent of the window. See `gtk_window_set_transient_for()` for
    /// more details about transient windows.
    case transientFor = "transient-for"
    case type = "type"
    case typeHint = "type-hint"
    case urgencyHint = "urgency-hint"
    /// `true` if the dialog uses a `GtkHeaderBar` for action buttons
    /// instead of the action-area.
    /// 
    /// For technical reasons, this property is declared as an integer
    /// property, but you should only set it to `true` or `false`.
    case useHeaderBar = "use-header-bar"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
    case windowPosition = "window-position"
}

public extension ColorChooserDialogProtocol {
    /// Bind a `ColorChooserDialogPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ColorChooserDialogPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(color_chooser_dialog_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum ColorChooserDialogSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    /// The `activate`-default signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user activates the default widget
    /// of `window`.
    case activateDefault = "activate-default"
    /// The `activate`-focus signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user activates the currently
    /// focused widget of `window`.
    case activateFocus = "activate-focus"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    case add = "add"
    /// The `button`-press-event signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button`-release-event signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child`-notify signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The `close` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user uses a keybinding to close
    /// the dialog.
    /// 
    /// The default binding for this signal is the Escape key.
    case close = "close"
    /// The `composited`-changed signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure`-event signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete`-event signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy`-event signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag`-begin signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag`-data-delete signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag`-data-get signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag`-data-received signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag`-drop signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag`-drop signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag`-data-received handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag`-end signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag`-begin.
    case dragEnd = "drag-end"
    /// The `drag`-failed signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag`-leave signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag`-motion, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag`-leave signal is also emitted before the
    /// `drag`-drop signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag`-motion signal handler.
    case dragLeave = "drag-leave"
    /// The `drag`-motion signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag`-data-received
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag`-leave and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enable`-debugging signal is a [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user enables or disables interactive
    /// debugging. When `toggle` is `true`, interactive debugging is toggled
    /// on or off, when it is `false`, the debugger will be pointed at the
    /// widget under the pointer.
    /// 
    /// The default bindings for this signal are Ctrl-Shift-I
    /// and Ctrl-Shift-D.
    case enableDebugging = "enable-debugging"
    /// The `enter`-notify-event will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key`-press-event) and finally a generic
    /// `GtkWidget::event`-after signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event`-after will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `focus`-in-event signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus`-out-event signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab`-notify signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy`-changed signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key`-press-event signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key`-release-event signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `keys`-changed signal gets emitted when the set of accelerators
    /// or mnemonics that are associated with `window` changes.
    case keysChanged = "keys-changed"
    /// The `leave`-notify-event will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map`-event will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map`-event signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion`-notify-event signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent`-set signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The `property`-notify-event signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// Emitted when an action widget is clicked, the dialog receives a
    /// delete event, or the application programmer calls `gtk_dialog_response()`.
    /// On a delete event, the response ID is `GTK_RESPONSE_DELETE_EVENT`.
    /// Otherwise, it depends on which action widget was clicked.
    case response = "response"
    /// The `screen`-changed signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll`-event signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `selection`-clear-event signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection`-request-event signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocus = "set-focus"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-changed signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style`-set signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style`-updated signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style`-updated signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap`-event signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility`-notify-event will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    /// The `window`-state-event will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    /// Whether the window should receive the input focus.
    case notifyAcceptFocus = "notify::accept-focus"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyAppPaintable = "notify::app-paintable"
    /// The `GtkApplication` associated with the window.
    /// 
    /// The application will be kept alive for at least as long as it
    /// has any windows associated with it (see `g_application_hold()`
    /// for a way to keep it alive without windows).
    /// 
    /// Normally, the connection between the application and the window
    /// will remain until the window is destroyed, but you can explicitly
    /// remove it by setting the :application property to `nil`.
    case notifyApplication = "notify::application"
    /// The widget to which this window is attached.
    /// See `gtk_window_set_attached_to()`.
    /// 
    /// Examples of places where specifying this relation is useful are
    /// for instance a `GtkMenu` created by a `GtkComboBox`, a completion
    /// popup window created by `GtkEntry` or a typeahead search entry
    /// created by `GtkTreeView`.
    case notifyAttachedTo = "notify::attached-to"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the window should be decorated by the window manager.
    case notifyDecorated = "notify::decorated"
    case notifyDefaultHeight = "notify::default-height"
    case notifyDefaultWidth = "notify::default-width"
    /// Whether the window frame should have a close button.
    case notifyDeletable = "notify::deletable"
    case notifyDestroyWithParent = "notify::destroy-with-parent"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether the window should receive the input focus when mapped.
    case notifyFocusOnMap = "notify::focus-on-map"
    /// Whether 'focus rectangles' are currently visible in this window.
    /// 
    /// This property is maintained by GTK+ based on user input
    /// and should not be set by applications.
    case notifyFocusVisible = "notify::focus-visible"
    /// The window gravity of the window. See `gtk_window_move()` and `GdkGravity` for
    /// more details about window gravity.
    case notifyGravity = "notify::gravity"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Whether the window has a corner resize grip.
    /// 
    /// Note that the resize grip is only shown if the window is
    /// actually resizable and not maximized. Use
    /// `GtkWindow:resize`-grip-visible to find out if the resize
    /// grip is currently shown.
    ///
    /// **has-resize-grip is deprecated:**
    /// Resize grips have been removed.
    case notifyHasResizeGrip = "notify::has-resize-grip"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHasToplevelFocus = "notify::has-toplevel-focus"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// Whether the titlebar should be hidden during maximization.
    case notifyHideTitlebarWhenMaximized = "notify::hide-titlebar-when-maximized"
    case notifyIcon = "notify::icon"
    /// The :icon-name property specifies the name of the themed icon to
    /// use as the window icon. See `GtkIconTheme` for more details.
    case notifyIconName = "notify::icon-name"
    case notifyIsActive = "notify::is-active"
    case notifyIsFocus = "notify::is-focus"
    case notifyIsMaximized = "notify::is-maximized"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    /// Whether mnemonics are currently visible in this window.
    /// 
    /// This property is maintained by GTK+ based on user input,
    /// and should not be set by applications.
    case notifyMnemonicsVisible = "notify::mnemonics-visible"
    case notifyModal = "notify::modal"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizable = "notify::resizable"
    /// Whether a corner resize grip is currently shown.
    ///
    /// **resize-grip-visible is deprecated:**
    /// Resize grips have been removed.
    case notifyResizeGripVisible = "notify::resize-grip-visible"
    case notifyResizeMode = "notify::resize-mode"
    case notifyRole = "notify::role"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifyScreen = "notify::screen"
    case notifySensitive = "notify::sensitive"
    case notifyShowEditor = "notify::show-editor"
    case notifySkipPagerHint = "notify::skip-pager-hint"
    case notifySkipTaskbarHint = "notify::skip-taskbar-hint"
    /// The :startup-id is a write-only property for setting window's
    /// startup notification identifier. See `gtk_window_set_startup_id()`
    /// for more details.
    case notifyStartupID = "notify::startup-id"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    case notifyTitle = "notify::title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// The transient parent of the window. See `gtk_window_set_transient_for()` for
    /// more details about transient windows.
    case notifyTransientFor = "notify::transient-for"
    case notifyType_ = "notify::type"
    case notifyTypeHint = "notify::type-hint"
    case notifyUrgencyHint = "notify::urgency-hint"
    /// `true` if the dialog uses a `GtkHeaderBar` for action buttons
    /// instead of the action-area.
    /// 
    /// For technical reasons, this property is declared as an integer
    /// property, but you should only set it to `true` or `false`.
    case notifyUseHeaderBar = "notify::use-header-bar"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
    case notifyWindowPosition = "notify::window-position"
}

public extension ColorChooserDialogProtocol {
    /// Connect a `ColorChooserDialogSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: ColorChooserDialogSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(color_chooser_dialog_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension ColorChooserDialogProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkColorChooserDialog` instance.
    var color_chooser_dialog_ptr: UnsafeMutablePointer<GtkColorChooserDialog> { return ptr.assumingMemoryBound(to: GtkColorChooserDialog.self) }

}



// MARK: - ColorChooserWidget Class

/// The `ColorChooserWidgetProtocol` protocol exposes the methods and properties of an underlying `GtkColorChooserWidget` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ColorChooserWidget`.
/// Alternatively, use `ColorChooserWidgetRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// The `GtkColorChooserWidget` widget lets the user select a
/// color. By default, the chooser presents a predefined palette
/// of colors, plus a small number of settable custom colors.
/// It is also possible to select a different color with the
/// single-color editor. To enter the single-color editing mode,
/// use the context menu of any color of the palette, or use the
/// '+' button to add a new custom color.
/// 
/// The chooser automatically remembers the last selection, as well
/// as custom colors.
/// 
/// To change the initially selected color, use `gtk_color_chooser_set_rgba()`.
/// To get the selected color use `gtk_color_chooser_get_rgba()`.
/// 
/// The `GtkColorChooserWidget` is used in the `GtkColorChooserDialog`
/// to provide a dialog for selecting colors.
/// 
/// # CSS names
/// 
/// GtkColorChooserWidget has a single CSS node with name colorchooser.
public protocol ColorChooserWidgetProtocol: BoxProtocol, ColorChooserProtocol {
    /// Untyped pointer to the underlying `GtkColorChooserWidget` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkColorChooserWidget` instance.
    var color_chooser_widget_ptr: UnsafeMutablePointer<GtkColorChooserWidget> { get }
}

/// The `ColorChooserWidgetRef` type acts as a lightweight Swift reference to an underlying `GtkColorChooserWidget` instance.
/// It exposes methods that can operate on this data type through `ColorChooserWidgetProtocol` conformance.
/// Use `ColorChooserWidgetRef` only as an `unowned` reference to an existing `GtkColorChooserWidget` instance.
///
/// The `GtkColorChooserWidget` widget lets the user select a
/// color. By default, the chooser presents a predefined palette
/// of colors, plus a small number of settable custom colors.
/// It is also possible to select a different color with the
/// single-color editor. To enter the single-color editing mode,
/// use the context menu of any color of the palette, or use the
/// '+' button to add a new custom color.
/// 
/// The chooser automatically remembers the last selection, as well
/// as custom colors.
/// 
/// To change the initially selected color, use `gtk_color_chooser_set_rgba()`.
/// To get the selected color use `gtk_color_chooser_get_rgba()`.
/// 
/// The `GtkColorChooserWidget` is used in the `GtkColorChooserDialog`
/// to provide a dialog for selecting colors.
/// 
/// # CSS names
/// 
/// GtkColorChooserWidget has a single CSS node with name colorchooser.
public struct ColorChooserWidgetRef: ColorChooserWidgetProtocol {
    /// Untyped pointer to the underlying `GtkColorChooserWidget` instance.
    /// For type-safe access, use the generated, typed pointer `color_chooser_widget_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension ColorChooserWidgetRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkColorChooserWidget>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `ColorChooserWidgetProtocol`
    init<T: ColorChooserWidgetProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkColorChooserWidget`.
    init() {
        let rv = gtk_color_chooser_widget_new()
        self.init(cast(rv))
    }
}

/// The `ColorChooserWidget` type acts as a reference-counted owner of an underlying `GtkColorChooserWidget` instance.
/// It provides the methods that can operate on this data type through `ColorChooserWidgetProtocol` conformance.
/// Use `ColorChooserWidget` as a strong reference or owner of a `GtkColorChooserWidget` instance.
///
/// The `GtkColorChooserWidget` widget lets the user select a
/// color. By default, the chooser presents a predefined palette
/// of colors, plus a small number of settable custom colors.
/// It is also possible to select a different color with the
/// single-color editor. To enter the single-color editing mode,
/// use the context menu of any color of the palette, or use the
/// '+' button to add a new custom color.
/// 
/// The chooser automatically remembers the last selection, as well
/// as custom colors.
/// 
/// To change the initially selected color, use `gtk_color_chooser_set_rgba()`.
/// To get the selected color use `gtk_color_chooser_get_rgba()`.
/// 
/// The `GtkColorChooserWidget` is used in the `GtkColorChooserDialog`
/// to provide a dialog for selecting colors.
/// 
/// # CSS names
/// 
/// GtkColorChooserWidget has a single CSS node with name colorchooser.
open class ColorChooserWidget: Box, ColorChooserWidgetProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `ColorChooserWidget` instance.
    public init(_ op: UnsafeMutablePointer<GtkColorChooserWidget>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `ColorChooserWidgetProtocol`
    /// Will retain `GtkColorChooserWidget`.
    public convenience init<T: ColorChooserWidgetProtocol>(_ other: T) {
        self.init(cast(other.color_chooser_widget_ptr))
        g_object_ref(cast(color_chooser_widget_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkColorChooserWidget.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkColorChooserWidget.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkColorChooserWidget.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkColorChooserWidget>(opaquePointer))
    }

    /// Creates a new `GtkColorChooserWidget`.
    public convenience init() {
        let rv = gtk_color_chooser_widget_new()
        self.init(cast(rv))
    }


}

public enum ColorChooserWidgetPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case appPaintable = "app-paintable"
    case baselinePosition = "baseline-position"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case compositeChild = "composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    case homogeneous = "homogeneous"
    case isFocus = "is-focus"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case resizeMode = "resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// The `show`-editor property is `true` when the color chooser
    /// is showing the single-color editor. It can be set to switch
    /// the color chooser into single-color editing mode.
    case showEditor = "show-editor"
    case spacing = "spacing"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
}

public extension ColorChooserWidgetProtocol {
    /// Bind a `ColorChooserWidgetPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ColorChooserWidgetPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(color_chooser_widget_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum ColorChooserWidgetSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    case add = "add"
    /// The `button`-press-event signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button`-release-event signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child`-notify signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The `composited`-changed signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure`-event signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete`-event signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy`-event signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag`-begin signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag`-data-delete signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag`-data-get signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag`-data-received signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag`-drop signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag`-drop signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag`-data-received handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag`-end signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag`-begin.
    case dragEnd = "drag-end"
    /// The `drag`-failed signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag`-leave signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag`-motion, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag`-leave signal is also emitted before the
    /// `drag`-drop signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag`-motion signal handler.
    case dragLeave = "drag-leave"
    /// The `drag`-motion signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag`-data-received
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag`-leave and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enter`-notify-event will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key`-press-event) and finally a generic
    /// `GtkWidget::event`-after signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event`-after will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `focus`-in-event signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus`-out-event signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab`-notify signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy`-changed signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key`-press-event signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key`-release-event signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `leave`-notify-event will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map`-event will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map`-event signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion`-notify-event signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent`-set signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The `property`-notify-event signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// The `screen`-changed signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll`-event signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `selection`-clear-event signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection`-request-event signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-changed signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style`-set signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style`-updated signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style`-updated signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap`-event signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility`-notify-event will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    /// The `window`-state-event will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBaselinePosition = "notify::baseline-position"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    case notifyHomogeneous = "notify::homogeneous"
    case notifyIsFocus = "notify::is-focus"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizeMode = "notify::resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// The `show`-editor property is `true` when the color chooser
    /// is showing the single-color editor. It can be set to switch
    /// the color chooser into single-color editing mode.
    case notifyShowEditor = "notify::show-editor"
    case notifySpacing = "notify::spacing"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
}

public extension ColorChooserWidgetProtocol {
    /// Connect a `ColorChooserWidgetSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: ColorChooserWidgetSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(color_chooser_widget_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension ColorChooserWidgetProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkColorChooserWidget` instance.
    var color_chooser_widget_ptr: UnsafeMutablePointer<GtkColorChooserWidget> { return ptr.assumingMemoryBound(to: GtkColorChooserWidget.self) }

}



// MARK: - ColorSelection Class

/// The `ColorSelectionProtocol` protocol exposes the methods and properties of an underlying `GtkColorSelection` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ColorSelection`.
/// Alternatively, use `ColorSelectionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///

public protocol ColorSelectionProtocol: BoxProtocol {
    /// Untyped pointer to the underlying `GtkColorSelection` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkColorSelection` instance.
    var color_selection_ptr: UnsafeMutablePointer<GtkColorSelection> { get }
}

/// The `ColorSelectionRef` type acts as a lightweight Swift reference to an underlying `GtkColorSelection` instance.
/// It exposes methods that can operate on this data type through `ColorSelectionProtocol` conformance.
/// Use `ColorSelectionRef` only as an `unowned` reference to an existing `GtkColorSelection` instance.
///

public struct ColorSelectionRef: ColorSelectionProtocol {
    /// Untyped pointer to the underlying `GtkColorSelection` instance.
    /// For type-safe access, use the generated, typed pointer `color_selection_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension ColorSelectionRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkColorSelection>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `ColorSelectionProtocol`
    init<T: ColorSelectionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorSelectionProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorSelectionProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorSelectionProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorSelectionProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorSelectionProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new GtkColorSelection.
@available(*, deprecated)     init() {
        let rv = gtk_color_selection_new()
        self.init(cast(rv))
    }
}

/// The `ColorSelection` type acts as a reference-counted owner of an underlying `GtkColorSelection` instance.
/// It provides the methods that can operate on this data type through `ColorSelectionProtocol` conformance.
/// Use `ColorSelection` as a strong reference or owner of a `GtkColorSelection` instance.
///

open class ColorSelection: Box, ColorSelectionProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `ColorSelection` instance.
    public init(_ op: UnsafeMutablePointer<GtkColorSelection>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `ColorSelectionProtocol`
    /// Will retain `GtkColorSelection`.
    public convenience init<T: ColorSelectionProtocol>(_ other: T) {
        self.init(cast(other.color_selection_ptr))
        g_object_ref(cast(color_selection_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorSelectionProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkColorSelection.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorSelectionProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkColorSelection.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorSelectionProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkColorSelection.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorSelectionProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkColorSelection>(opaquePointer))
    }

    /// Creates a new GtkColorSelection.
@available(*, deprecated)     public convenience init() {
        let rv = gtk_color_selection_new()
        self.init(cast(rv))
    }


}

public enum ColorSelectionPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case appPaintable = "app-paintable"
    case baselinePosition = "baseline-position"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case compositeChild = "composite-child"
    case currentAlpha = "current-alpha"
    /// The current GdkColor color.
    ///
    /// **current-color is deprecated:**
    /// Use #GtkColorSelection:current-rgba instead.
    case currentColor = "current-color"
    /// The current RGBA color.
    case currentRGBA = "current-rgba"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    case hasOpacityControl = "has-opacity-control"
    case hasPalette = "has-palette"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    case homogeneous = "homogeneous"
    case isFocus = "is-focus"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case resizeMode = "resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    case spacing = "spacing"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
}

public extension ColorSelectionProtocol {
    /// Bind a `ColorSelectionPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ColorSelectionPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(color_selection_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum ColorSelectionSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    case add = "add"
    /// The `button`-press-event signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button`-release-event signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child`-notify signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// This signal is emitted when the color changes in the `GtkColorSelection`
    /// according to its update policy.
    case colorChanged = "color-changed"
    /// The `composited`-changed signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure`-event signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete`-event signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy`-event signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag`-begin signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag`-data-delete signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag`-data-get signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag`-data-received signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag`-drop signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag`-drop signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag`-data-received handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag`-end signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag`-begin.
    case dragEnd = "drag-end"
    /// The `drag`-failed signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag`-leave signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag`-motion, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag`-leave signal is also emitted before the
    /// `drag`-drop signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag`-motion signal handler.
    case dragLeave = "drag-leave"
    /// The `drag`-motion signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag`-data-received
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag`-leave and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enter`-notify-event will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key`-press-event) and finally a generic
    /// `GtkWidget::event`-after signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event`-after will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `focus`-in-event signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus`-out-event signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab`-notify signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy`-changed signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key`-press-event signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key`-release-event signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `leave`-notify-event will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map`-event will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map`-event signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion`-notify-event signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent`-set signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The `property`-notify-event signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// The `screen`-changed signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll`-event signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `selection`-clear-event signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection`-request-event signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-changed signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style`-set signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style`-updated signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style`-updated signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap`-event signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility`-notify-event will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    /// The `window`-state-event will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBaselinePosition = "notify::baseline-position"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCompositeChild = "notify::composite-child"
    case notifyCurrentAlpha = "notify::current-alpha"
    /// The current GdkColor color.
    ///
    /// **current-color is deprecated:**
    /// Use #GtkColorSelection:current-rgba instead.
    case notifyCurrentColor = "notify::current-color"
    /// The current RGBA color.
    case notifyCurrentRGBA = "notify::current-rgba"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    case notifyHasOpacityControl = "notify::has-opacity-control"
    case notifyHasPalette = "notify::has-palette"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    case notifyHomogeneous = "notify::homogeneous"
    case notifyIsFocus = "notify::is-focus"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizeMode = "notify::resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    case notifySpacing = "notify::spacing"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
}

public extension ColorSelectionProtocol {
    /// Connect a `ColorSelectionSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: ColorSelectionSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(color_selection_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension ColorSelectionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkColorSelection` instance.
    var color_selection_ptr: UnsafeMutablePointer<GtkColorSelection> { return ptr.assumingMemoryBound(to: GtkColorSelection.self) }

    /// Returns the current alpha value.
    @available(*, deprecated) func getCurrentAlpha() -> UInt16 {
        let rv = gtk_color_selection_get_current_alpha(cast(color_selection_ptr))
        return UInt16(rv)
    }

    /// Sets `color` to be the current color in the GtkColorSelection widget.
    ///
    /// **get_current_color is deprecated:**
    /// Use gtk_color_selection_get_current_rgba() instead.
    @available(*, deprecated) func getCurrent(color: Gdk.ColorProtocol) {
        gtk_color_selection_get_current_color(cast(color_selection_ptr), cast(color.ptr))
    
    }

    /// Sets `rgba` to be the current color in the GtkColorSelection widget.
    @available(*, deprecated) func getCurrent(rgba: RGBAProtocol) {
        gtk_color_selection_get_current_rgba(cast(color_selection_ptr), cast(rgba.ptr))
    
    }

    /// Determines whether the colorsel has an opacity control.
    @available(*, deprecated) func getHasOpacityControl() -> Bool {
        let rv = gtk_color_selection_get_has_opacity_control(cast(color_selection_ptr))
        return Bool(rv != 0)
    }

    /// Determines whether the color selector has a color palette.
    @available(*, deprecated) func getHasPalette() -> Bool {
        let rv = gtk_color_selection_get_has_palette(cast(color_selection_ptr))
        return Bool(rv != 0)
    }

    /// Returns the previous alpha value.
    @available(*, deprecated) func getPreviousAlpha() -> UInt16 {
        let rv = gtk_color_selection_get_previous_alpha(cast(color_selection_ptr))
        return UInt16(rv)
    }

    /// Fills `color` in with the original color value.
    ///
    /// **get_previous_color is deprecated:**
    /// Use gtk_color_selection_get_previous_rgba() instead.
    @available(*, deprecated) func getPrevious(color: Gdk.ColorProtocol) {
        gtk_color_selection_get_previous_color(cast(color_selection_ptr), cast(color.ptr))
    
    }

    /// Fills `rgba` in with the original color value.
    @available(*, deprecated) func getPrevious(rgba: RGBAProtocol) {
        gtk_color_selection_get_previous_rgba(cast(color_selection_ptr), cast(rgba.ptr))
    
    }

    /// Sets the current opacity to be `alpha`.
    /// 
    /// The first time this is called, it will also set
    /// the original opacity to be `alpha` too.
    @available(*, deprecated) func setCurrent(alpha: UInt16) {
        gtk_color_selection_set_current_alpha(cast(color_selection_ptr), guint16(alpha))
    
    }

    /// Sets the current color to be `color`.
    /// 
    /// The first time this is called, it will also set
    /// the original color to be `color` too.
    ///
    /// **set_current_color is deprecated:**
    /// Use gtk_color_selection_set_current_rgba() instead.
    @available(*, deprecated) func setCurrent(color: Gdk.ColorProtocol) {
        gtk_color_selection_set_current_color(cast(color_selection_ptr), cast(color.ptr))
    
    }

    /// Sets the current color to be `rgba`.
    /// 
    /// The first time this is called, it will also set
    /// the original color to be `rgba` too.
    @available(*, deprecated) func setCurrent(rgba: RGBAProtocol) {
        gtk_color_selection_set_current_rgba(cast(color_selection_ptr), cast(rgba.ptr))
    
    }

    /// Sets the `colorsel` to use or not use opacity.
    @available(*, deprecated) func setHasOpacityControl(hasOpacity has_opacity: Bool) {
        gtk_color_selection_set_has_opacity_control(cast(color_selection_ptr), gboolean(has_opacity ? 1 : 0))
    
    }

    /// Shows and hides the palette based upon the value of `has_palette`.
    @available(*, deprecated) func set(hasPalette has_palette: Bool) {
        gtk_color_selection_set_has_palette(cast(color_selection_ptr), gboolean(has_palette ? 1 : 0))
    
    }

    /// Sets the “previous” alpha to be `alpha`.
    /// 
    /// This function should be called with some hesitations,
    /// as it might seem confusing to have that alpha change.
    @available(*, deprecated) func setPrevious(alpha: UInt16) {
        gtk_color_selection_set_previous_alpha(cast(color_selection_ptr), guint16(alpha))
    
    }

    /// Sets the “previous” color to be `color`.
    /// 
    /// This function should be called with some hesitations,
    /// as it might seem confusing to have that color change.
    /// Calling `gtk_color_selection_set_current_color()` will also
    /// set this color the first time it is called.
    ///
    /// **set_previous_color is deprecated:**
    /// Use gtk_color_selection_set_previous_rgba() instead.
    @available(*, deprecated) func setPrevious(color: Gdk.ColorProtocol) {
        gtk_color_selection_set_previous_color(cast(color_selection_ptr), cast(color.ptr))
    
    }

    /// Sets the “previous” color to be `rgba`.
    /// 
    /// This function should be called with some hesitations,
    /// as it might seem confusing to have that color change.
    /// Calling `gtk_color_selection_set_current_rgba()` will also
    /// set this color the first time it is called.
    @available(*, deprecated) func setPrevious(rgba: RGBAProtocol) {
        gtk_color_selection_set_previous_rgba(cast(color_selection_ptr), cast(rgba.ptr))
    
    }
    /// Returns the current alpha value.
    @available(*, deprecated) var currentAlpha: UInt16 {
        /// Returns the current alpha value.
        get {
            let rv = gtk_color_selection_get_current_alpha(cast(color_selection_ptr))
            return UInt16(rv)
        }
        /// Sets the current opacity to be `alpha`.
        /// 
        /// The first time this is called, it will also set
        /// the original opacity to be `alpha` too.
        nonmutating set {
            gtk_color_selection_set_current_alpha(cast(color_selection_ptr), guint16(newValue))
        }
    }

    /// Determines whether the colorsel has an opacity control.
    @available(*, deprecated) var hasOpacityControl: Bool {
        /// Determines whether the colorsel has an opacity control.
        get {
            let rv = gtk_color_selection_get_has_opacity_control(cast(color_selection_ptr))
            return Bool(rv != 0)
        }
        /// Sets the `colorsel` to use or not use opacity.
        nonmutating set {
            gtk_color_selection_set_has_opacity_control(cast(color_selection_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Determines whether the color selector has a color palette.
    @available(*, deprecated) var hasPalette: Bool {
        /// Determines whether the color selector has a color palette.
        get {
            let rv = gtk_color_selection_get_has_palette(cast(color_selection_ptr))
            return Bool(rv != 0)
        }
        /// Shows and hides the palette based upon the value of `has_palette`.
        nonmutating set {
            gtk_color_selection_set_has_palette(cast(color_selection_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Gets the current state of the `colorsel`.
    @available(*, deprecated) var isAdjusting: Bool {
        /// Gets the current state of the `colorsel`.
        get {
            let rv = gtk_color_selection_is_adjusting(cast(color_selection_ptr))
            return Bool(rv != 0)
        }
    }

    /// Returns the previous alpha value.
    @available(*, deprecated) var previousAlpha: UInt16 {
        /// Returns the previous alpha value.
        get {
            let rv = gtk_color_selection_get_previous_alpha(cast(color_selection_ptr))
            return UInt16(rv)
        }
        /// Sets the “previous” alpha to be `alpha`.
        /// 
        /// This function should be called with some hesitations,
        /// as it might seem confusing to have that alpha change.
        nonmutating set {
            gtk_color_selection_set_previous_alpha(cast(color_selection_ptr), guint16(newValue))
        }
    }
}



// MARK: - ColorSelectionDialog Class

/// The `ColorSelectionDialogProtocol` protocol exposes the methods and properties of an underlying `GtkColorSelectionDialog` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ColorSelectionDialog`.
/// Alternatively, use `ColorSelectionDialogRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///

public protocol ColorSelectionDialogProtocol: DialogProtocol {
    /// Untyped pointer to the underlying `GtkColorSelectionDialog` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkColorSelectionDialog` instance.
    var color_selection_dialog_ptr: UnsafeMutablePointer<GtkColorSelectionDialog> { get }
}

/// The `ColorSelectionDialogRef` type acts as a lightweight Swift reference to an underlying `GtkColorSelectionDialog` instance.
/// It exposes methods that can operate on this data type through `ColorSelectionDialogProtocol` conformance.
/// Use `ColorSelectionDialogRef` only as an `unowned` reference to an existing `GtkColorSelectionDialog` instance.
///

public struct ColorSelectionDialogRef: ColorSelectionDialogProtocol {
    /// Untyped pointer to the underlying `GtkColorSelectionDialog` instance.
    /// For type-safe access, use the generated, typed pointer `color_selection_dialog_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension ColorSelectionDialogRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkColorSelectionDialog>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `ColorSelectionDialogProtocol`
    init<T: ColorSelectionDialogProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorSelectionDialogProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorSelectionDialogProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorSelectionDialogProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorSelectionDialogProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorSelectionDialogProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkColorSelectionDialog`.
@available(*, deprecated)     init( title: UnsafePointer<gchar>) {
        let rv = gtk_color_selection_dialog_new(title)
        self.init(cast(rv))
    }
}

/// The `ColorSelectionDialog` type acts as a reference-counted owner of an underlying `GtkColorSelectionDialog` instance.
/// It provides the methods that can operate on this data type through `ColorSelectionDialogProtocol` conformance.
/// Use `ColorSelectionDialog` as a strong reference or owner of a `GtkColorSelectionDialog` instance.
///

open class ColorSelectionDialog: Dialog, ColorSelectionDialogProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `ColorSelectionDialog` instance.
    public init(_ op: UnsafeMutablePointer<GtkColorSelectionDialog>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `ColorSelectionDialogProtocol`
    /// Will retain `GtkColorSelectionDialog`.
    public convenience init<T: ColorSelectionDialogProtocol>(_ other: T) {
        self.init(cast(other.color_selection_dialog_ptr))
        g_object_ref(cast(color_selection_dialog_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorSelectionDialogProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkColorSelectionDialog.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorSelectionDialogProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkColorSelectionDialog.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorSelectionDialogProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkColorSelectionDialog.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorSelectionDialogProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkColorSelectionDialog>(opaquePointer))
    }

    /// Creates a new `GtkColorSelectionDialog`.
@available(*, deprecated)     public convenience init( title: UnsafePointer<gchar>) {
        let rv = gtk_color_selection_dialog_new(title)
        self.init(cast(rv))
    }


}

public enum ColorSelectionDialogPropertyName: String, PropertyNameProtocol {
    /// Whether the window should receive the input focus.
    case acceptFocus = "accept-focus"
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case appPaintable = "app-paintable"
    /// The `GtkApplication` associated with the window.
    /// 
    /// The application will be kept alive for at least as long as it
    /// has any windows associated with it (see `g_application_hold()`
    /// for a way to keep it alive without windows).
    /// 
    /// Normally, the connection between the application and the window
    /// will remain until the window is destroyed, but you can explicitly
    /// remove it by setting the :application property to `nil`.
    case application = "application"
    /// The widget to which this window is attached.
    /// See `gtk_window_set_attached_to()`.
    /// 
    /// Examples of places where specifying this relation is useful are
    /// for instance a `GtkMenu` created by a `GtkComboBox`, a completion
    /// popup window created by `GtkEntry` or a typeahead search entry
    /// created by `GtkTreeView`.
    case attachedTo = "attached-to"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case cancelButton = "cancel-button"
    case child = "child"
    case colorSelection = "color-selection"
    case compositeChild = "composite-child"
    /// Whether the window should be decorated by the window manager.
    case decorated = "decorated"
    case defaultHeight = "default-height"
    case defaultWidth = "default-width"
    /// Whether the window frame should have a close button.
    case deletable = "deletable"
    case destroyWithParent = "destroy-with-parent"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// Whether the window should receive the input focus when mapped.
    case focusOnMap = "focus-on-map"
    /// Whether 'focus rectangles' are currently visible in this window.
    /// 
    /// This property is maintained by GTK+ based on user input
    /// and should not be set by applications.
    case focusVisible = "focus-visible"
    /// The window gravity of the window. See `gtk_window_move()` and `GdkGravity` for
    /// more details about window gravity.
    case gravity = "gravity"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Whether the window has a corner resize grip.
    /// 
    /// Note that the resize grip is only shown if the window is
    /// actually resizable and not maximized. Use
    /// `GtkWindow:resize`-grip-visible to find out if the resize
    /// grip is currently shown.
    ///
    /// **has-resize-grip is deprecated:**
    /// Resize grips have been removed.
    case hasResizeGrip = "has-resize-grip"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case hasToplevelFocus = "has-toplevel-focus"
    case heightRequest = "height-request"
    case helpButton = "help-button"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// Whether the titlebar should be hidden during maximization.
    case hideTitlebarWhenMaximized = "hide-titlebar-when-maximized"
    case icon = "icon"
    /// The :icon-name property specifies the name of the themed icon to
    /// use as the window icon. See `GtkIconTheme` for more details.
    case iconName = "icon-name"
    case isActive = "is-active"
    case isFocus = "is-focus"
    case isMaximized = "is-maximized"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    /// Whether mnemonics are currently visible in this window.
    /// 
    /// This property is maintained by GTK+ based on user input,
    /// and should not be set by applications.
    case mnemonicsVisible = "mnemonics-visible"
    case modal = "modal"
    case name = "name"
    case noShowAll = "no-show-all"
    case okButton = "ok-button"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case resizable = "resizable"
    /// Whether a corner resize grip is currently shown.
    ///
    /// **resize-grip-visible is deprecated:**
    /// Resize grips have been removed.
    case resizeGripVisible = "resize-grip-visible"
    case resizeMode = "resize-mode"
    case role = "role"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case screen = "screen"
    case sensitive = "sensitive"
    case skipPagerHint = "skip-pager-hint"
    case skipTaskbarHint = "skip-taskbar-hint"
    /// The :startup-id is a write-only property for setting window's
    /// startup notification identifier. See `gtk_window_set_startup_id()`
    /// for more details.
    case startupID = "startup-id"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    case title = "title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// The transient parent of the window. See `gtk_window_set_transient_for()` for
    /// more details about transient windows.
    case transientFor = "transient-for"
    case type = "type"
    case typeHint = "type-hint"
    case urgencyHint = "urgency-hint"
    /// `true` if the dialog uses a `GtkHeaderBar` for action buttons
    /// instead of the action-area.
    /// 
    /// For technical reasons, this property is declared as an integer
    /// property, but you should only set it to `true` or `false`.
    case useHeaderBar = "use-header-bar"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
    case windowPosition = "window-position"
}

public extension ColorSelectionDialogProtocol {
    /// Bind a `ColorSelectionDialogPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ColorSelectionDialogPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(color_selection_dialog_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum ColorSelectionDialogSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    /// The `activate`-default signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user activates the default widget
    /// of `window`.
    case activateDefault = "activate-default"
    /// The `activate`-focus signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user activates the currently
    /// focused widget of `window`.
    case activateFocus = "activate-focus"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    case add = "add"
    /// The `button`-press-event signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button`-release-event signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child`-notify signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The `close` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user uses a keybinding to close
    /// the dialog.
    /// 
    /// The default binding for this signal is the Escape key.
    case close = "close"
    /// The `composited`-changed signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure`-event signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete`-event signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy`-event signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag`-begin signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag`-data-delete signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag`-data-get signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag`-data-received signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag`-drop signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag`-drop signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag`-data-received handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag`-end signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag`-begin.
    case dragEnd = "drag-end"
    /// The `drag`-failed signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag`-leave signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag`-motion, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag`-leave signal is also emitted before the
    /// `drag`-drop signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag`-motion signal handler.
    case dragLeave = "drag-leave"
    /// The `drag`-motion signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag`-data-received
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag`-leave and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enable`-debugging signal is a [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user enables or disables interactive
    /// debugging. When `toggle` is `true`, interactive debugging is toggled
    /// on or off, when it is `false`, the debugger will be pointed at the
    /// widget under the pointer.
    /// 
    /// The default bindings for this signal are Ctrl-Shift-I
    /// and Ctrl-Shift-D.
    case enableDebugging = "enable-debugging"
    /// The `enter`-notify-event will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key`-press-event) and finally a generic
    /// `GtkWidget::event`-after signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event`-after will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `focus`-in-event signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus`-out-event signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab`-notify signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy`-changed signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key`-press-event signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key`-release-event signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `keys`-changed signal gets emitted when the set of accelerators
    /// or mnemonics that are associated with `window` changes.
    case keysChanged = "keys-changed"
    /// The `leave`-notify-event will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map`-event will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map`-event signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion`-notify-event signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent`-set signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The `property`-notify-event signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// Emitted when an action widget is clicked, the dialog receives a
    /// delete event, or the application programmer calls `gtk_dialog_response()`.
    /// On a delete event, the response ID is `GTK_RESPONSE_DELETE_EVENT`.
    /// Otherwise, it depends on which action widget was clicked.
    case response = "response"
    /// The `screen`-changed signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll`-event signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `selection`-clear-event signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection`-request-event signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocus = "set-focus"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-changed signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style`-set signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style`-updated signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style`-updated signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap`-event signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility`-notify-event will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    /// The `window`-state-event will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    /// Whether the window should receive the input focus.
    case notifyAcceptFocus = "notify::accept-focus"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyAppPaintable = "notify::app-paintable"
    /// The `GtkApplication` associated with the window.
    /// 
    /// The application will be kept alive for at least as long as it
    /// has any windows associated with it (see `g_application_hold()`
    /// for a way to keep it alive without windows).
    /// 
    /// Normally, the connection between the application and the window
    /// will remain until the window is destroyed, but you can explicitly
    /// remove it by setting the :application property to `nil`.
    case notifyApplication = "notify::application"
    /// The widget to which this window is attached.
    /// See `gtk_window_set_attached_to()`.
    /// 
    /// Examples of places where specifying this relation is useful are
    /// for instance a `GtkMenu` created by a `GtkComboBox`, a completion
    /// popup window created by `GtkEntry` or a typeahead search entry
    /// created by `GtkTreeView`.
    case notifyAttachedTo = "notify::attached-to"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyCancelButton = "notify::cancel-button"
    case notifyChild = "notify::child"
    case notifyColorSelection = "notify::color-selection"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the window should be decorated by the window manager.
    case notifyDecorated = "notify::decorated"
    case notifyDefaultHeight = "notify::default-height"
    case notifyDefaultWidth = "notify::default-width"
    /// Whether the window frame should have a close button.
    case notifyDeletable = "notify::deletable"
    case notifyDestroyWithParent = "notify::destroy-with-parent"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether the window should receive the input focus when mapped.
    case notifyFocusOnMap = "notify::focus-on-map"
    /// Whether 'focus rectangles' are currently visible in this window.
    /// 
    /// This property is maintained by GTK+ based on user input
    /// and should not be set by applications.
    case notifyFocusVisible = "notify::focus-visible"
    /// The window gravity of the window. See `gtk_window_move()` and `GdkGravity` for
    /// more details about window gravity.
    case notifyGravity = "notify::gravity"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Whether the window has a corner resize grip.
    /// 
    /// Note that the resize grip is only shown if the window is
    /// actually resizable and not maximized. Use
    /// `GtkWindow:resize`-grip-visible to find out if the resize
    /// grip is currently shown.
    ///
    /// **has-resize-grip is deprecated:**
    /// Resize grips have been removed.
    case notifyHasResizeGrip = "notify::has-resize-grip"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHasToplevelFocus = "notify::has-toplevel-focus"
    case notifyHeightRequest = "notify::height-request"
    case notifyHelpButton = "notify::help-button"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// Whether the titlebar should be hidden during maximization.
    case notifyHideTitlebarWhenMaximized = "notify::hide-titlebar-when-maximized"
    case notifyIcon = "notify::icon"
    /// The :icon-name property specifies the name of the themed icon to
    /// use as the window icon. See `GtkIconTheme` for more details.
    case notifyIconName = "notify::icon-name"
    case notifyIsActive = "notify::is-active"
    case notifyIsFocus = "notify::is-focus"
    case notifyIsMaximized = "notify::is-maximized"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    /// Whether mnemonics are currently visible in this window.
    /// 
    /// This property is maintained by GTK+ based on user input,
    /// and should not be set by applications.
    case notifyMnemonicsVisible = "notify::mnemonics-visible"
    case notifyModal = "notify::modal"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    case notifyOkButton = "notify::ok-button"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizable = "notify::resizable"
    /// Whether a corner resize grip is currently shown.
    ///
    /// **resize-grip-visible is deprecated:**
    /// Resize grips have been removed.
    case notifyResizeGripVisible = "notify::resize-grip-visible"
    case notifyResizeMode = "notify::resize-mode"
    case notifyRole = "notify::role"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifyScreen = "notify::screen"
    case notifySensitive = "notify::sensitive"
    case notifySkipPagerHint = "notify::skip-pager-hint"
    case notifySkipTaskbarHint = "notify::skip-taskbar-hint"
    /// The :startup-id is a write-only property for setting window's
    /// startup notification identifier. See `gtk_window_set_startup_id()`
    /// for more details.
    case notifyStartupID = "notify::startup-id"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    case notifyTitle = "notify::title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// The transient parent of the window. See `gtk_window_set_transient_for()` for
    /// more details about transient windows.
    case notifyTransientFor = "notify::transient-for"
    case notifyType_ = "notify::type"
    case notifyTypeHint = "notify::type-hint"
    case notifyUrgencyHint = "notify::urgency-hint"
    /// `true` if the dialog uses a `GtkHeaderBar` for action buttons
    /// instead of the action-area.
    /// 
    /// For technical reasons, this property is declared as an integer
    /// property, but you should only set it to `true` or `false`.
    case notifyUseHeaderBar = "notify::use-header-bar"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
    case notifyWindowPosition = "notify::window-position"
}

public extension ColorSelectionDialogProtocol {
    /// Connect a `ColorSelectionDialogSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: ColorSelectionDialogSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(color_selection_dialog_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension ColorSelectionDialogProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkColorSelectionDialog` instance.
    var color_selection_dialog_ptr: UnsafeMutablePointer<GtkColorSelectionDialog> { return ptr.assumingMemoryBound(to: GtkColorSelectionDialog.self) }

    /// Retrieves the `GtkColorSelection` widget embedded in the dialog.
    @available(*, deprecated) func getColorSelection() -> UnsafeMutablePointer<GtkWidget>! {
        let rv = gtk_color_selection_dialog_get_color_selection(cast(color_selection_dialog_ptr))
        return cast(rv)
    }
    /// Retrieves the `GtkColorSelection` widget embedded in the dialog.
    @available(*, deprecated) var colorSelection: UnsafeMutablePointer<GtkWidget>! {
        /// Retrieves the `GtkColorSelection` widget embedded in the dialog.
        get {
            let rv = gtk_color_selection_dialog_get_color_selection(cast(color_selection_dialog_ptr))
            return cast(rv)
        }
    }
}



// MARK: - ComboBox Class

/// The `ComboBoxProtocol` protocol exposes the methods and properties of an underlying `GtkComboBox` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ComboBox`.
/// Alternatively, use `ComboBoxRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A GtkComboBox is a widget that allows the user to choose from a list of
/// valid choices. The GtkComboBox displays the selected choice. When
/// activated, the GtkComboBox displays a popup which allows the user to
/// make a new choice. The style in which the selected value is displayed,
/// and the style of the popup is determined by the current theme. It may
/// be similar to a Windows-style combo box.
/// 
/// The GtkComboBox uses the model-view pattern; the list of valid choices
/// is specified in the form of a tree model, and the display of the choices
/// can be adapted to the data in the model by using cell renderers, as you
/// would in a tree view. This is possible since GtkComboBox implements the
/// `GtkCellLayout` interface. The tree model holding the valid choices is
/// not restricted to a flat list, it can be a real tree, and the popup will
/// reflect the tree structure.
/// 
/// To allow the user to enter values not in the model, the “has-entry”
/// property allows the GtkComboBox to contain a `GtkEntry`. This entry
/// can be accessed by calling `gtk_bin_get_child()` on the combo box.
/// 
/// For a simple list of textual choices, the model-view API of GtkComboBox
/// can be a bit overwhelming. In this case, `GtkComboBoxText` offers a
/// simple alternative. Both GtkComboBox and `GtkComboBoxText` can contain
/// an entry.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// combobox
/// ├── box.linked
/// │   ╰── button.combo
/// │       ╰── box
/// │           ├── cellview
/// │           ╰── arrow
/// ╰── window.popup
/// ```
/// 
/// A normal combobox contains a box with the .linked class, a button
/// with the .combo class and inside those buttons, there are a cellview and
/// an arrow.
/// 
/// (plain Language Example):
/// ```plain
/// combobox
/// ├── box.linked
/// │   ├── entry.combo
/// │   ╰── button.combo
/// │       ╰── box
/// │           ╰── arrow
/// ╰── window.popup
/// ```
/// 
/// A GtkComboBox with an entry has a single CSS node with name combobox. It
/// contains a box with the .linked class. That box contains an entry and a
/// button, both with the .combo class added.
/// The button also contains another node with name arrow.
public protocol ComboBoxProtocol: BinProtocol, CellEditableProtocol, CellLayoutProtocol {
    /// Untyped pointer to the underlying `GtkComboBox` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkComboBox` instance.
    var combo_box_ptr: UnsafeMutablePointer<GtkComboBox> { get }
}

/// The `ComboBoxRef` type acts as a lightweight Swift reference to an underlying `GtkComboBox` instance.
/// It exposes methods that can operate on this data type through `ComboBoxProtocol` conformance.
/// Use `ComboBoxRef` only as an `unowned` reference to an existing `GtkComboBox` instance.
///
/// A GtkComboBox is a widget that allows the user to choose from a list of
/// valid choices. The GtkComboBox displays the selected choice. When
/// activated, the GtkComboBox displays a popup which allows the user to
/// make a new choice. The style in which the selected value is displayed,
/// and the style of the popup is determined by the current theme. It may
/// be similar to a Windows-style combo box.
/// 
/// The GtkComboBox uses the model-view pattern; the list of valid choices
/// is specified in the form of a tree model, and the display of the choices
/// can be adapted to the data in the model by using cell renderers, as you
/// would in a tree view. This is possible since GtkComboBox implements the
/// `GtkCellLayout` interface. The tree model holding the valid choices is
/// not restricted to a flat list, it can be a real tree, and the popup will
/// reflect the tree structure.
/// 
/// To allow the user to enter values not in the model, the “has-entry”
/// property allows the GtkComboBox to contain a `GtkEntry`. This entry
/// can be accessed by calling `gtk_bin_get_child()` on the combo box.
/// 
/// For a simple list of textual choices, the model-view API of GtkComboBox
/// can be a bit overwhelming. In this case, `GtkComboBoxText` offers a
/// simple alternative. Both GtkComboBox and `GtkComboBoxText` can contain
/// an entry.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// combobox
/// ├── box.linked
/// │   ╰── button.combo
/// │       ╰── box
/// │           ├── cellview
/// │           ╰── arrow
/// ╰── window.popup
/// ```
/// 
/// A normal combobox contains a box with the .linked class, a button
/// with the .combo class and inside those buttons, there are a cellview and
/// an arrow.
/// 
/// (plain Language Example):
/// ```plain
/// combobox
/// ├── box.linked
/// │   ├── entry.combo
/// │   ╰── button.combo
/// │       ╰── box
/// │           ╰── arrow
/// ╰── window.popup
/// ```
/// 
/// A GtkComboBox with an entry has a single CSS node with name combobox. It
/// contains a box with the .linked class. That box contains an entry and a
/// button, both with the .combo class added.
/// The button also contains another node with name arrow.
public struct ComboBoxRef: ComboBoxProtocol {
    /// Untyped pointer to the underlying `GtkComboBox` instance.
    /// For type-safe access, use the generated, typed pointer `combo_box_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension ComboBoxRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkComboBox>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `ComboBoxProtocol`
    init<T: ComboBoxProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new empty `GtkComboBox`.
@available(*, deprecated)     init() {
        let rv = gtk_combo_box_new()
        self.init(cast(rv))
    }

    /// Creates a new empty `GtkComboBox` using `area` to layout cells.
    init(area: CellAreaProtocol) {
        let rv = gtk_combo_box_new_with_area(cast(area.ptr))
        self.init(cast(rv))
    }

    /// Creates a new empty `GtkComboBox` with an entry.
    /// 
    /// The new combo box will use `area` to layout cells.
    init(areaAndEntry area: CellAreaProtocol) {
        let rv = gtk_combo_box_new_with_area_and_entry(cast(area.ptr))
        self.init(cast(rv))
    }

    /// Creates a new `GtkComboBox` with the model initialized to `model`.
    init(model: TreeModelProtocol) {
        let rv = gtk_combo_box_new_with_model(cast(model.ptr))
        self.init(cast(rv))
    }

    /// Creates a new empty `GtkComboBox` with an entry
    /// and with the model initialized to `model`.
    init(modelAndEntry model: TreeModelProtocol) {
        let rv = gtk_combo_box_new_with_model_and_entry(cast(model.ptr))
        self.init(cast(rv))
    }
    /// Creates a new empty `GtkComboBox` using `area` to layout cells.
    static func newWith(area: CellAreaProtocol) -> ComboBoxRef! {
        let rv = gtk_combo_box_new_with_area(cast(area.ptr))
        return rv.map { ComboBoxRef(cast($0)) }
    }

    /// Creates a new empty `GtkComboBox` with an entry.
    /// 
    /// The new combo box will use `area` to layout cells.
    static func newWith(areaAndEntry area: CellAreaProtocol) -> ComboBoxRef! {
        let rv = gtk_combo_box_new_with_area_and_entry(cast(area.ptr))
        return rv.map { ComboBoxRef(cast($0)) }
    }

    /// Creates a new empty `GtkComboBox` with an entry.
    static func newWithEntry() -> ComboBoxRef! {
        let rv = gtk_combo_box_new_with_entry()
        return rv.map { ComboBoxRef(cast($0)) }
    }

    /// Creates a new `GtkComboBox` with the model initialized to `model`.
    static func newWith(model: TreeModelProtocol) -> ComboBoxRef! {
        let rv = gtk_combo_box_new_with_model(cast(model.ptr))
        return rv.map { ComboBoxRef(cast($0)) }
    }

    /// Creates a new empty `GtkComboBox` with an entry
    /// and with the model initialized to `model`.
    static func newWith(modelAndEntry model: TreeModelProtocol) -> ComboBoxRef! {
        let rv = gtk_combo_box_new_with_model_and_entry(cast(model.ptr))
        return rv.map { ComboBoxRef(cast($0)) }
    }
}

/// The `ComboBox` type acts as a reference-counted owner of an underlying `GtkComboBox` instance.
/// It provides the methods that can operate on this data type through `ComboBoxProtocol` conformance.
/// Use `ComboBox` as a strong reference or owner of a `GtkComboBox` instance.
///
/// A GtkComboBox is a widget that allows the user to choose from a list of
/// valid choices. The GtkComboBox displays the selected choice. When
/// activated, the GtkComboBox displays a popup which allows the user to
/// make a new choice. The style in which the selected value is displayed,
/// and the style of the popup is determined by the current theme. It may
/// be similar to a Windows-style combo box.
/// 
/// The GtkComboBox uses the model-view pattern; the list of valid choices
/// is specified in the form of a tree model, and the display of the choices
/// can be adapted to the data in the model by using cell renderers, as you
/// would in a tree view. This is possible since GtkComboBox implements the
/// `GtkCellLayout` interface. The tree model holding the valid choices is
/// not restricted to a flat list, it can be a real tree, and the popup will
/// reflect the tree structure.
/// 
/// To allow the user to enter values not in the model, the “has-entry”
/// property allows the GtkComboBox to contain a `GtkEntry`. This entry
/// can be accessed by calling `gtk_bin_get_child()` on the combo box.
/// 
/// For a simple list of textual choices, the model-view API of GtkComboBox
/// can be a bit overwhelming. In this case, `GtkComboBoxText` offers a
/// simple alternative. Both GtkComboBox and `GtkComboBoxText` can contain
/// an entry.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// combobox
/// ├── box.linked
/// │   ╰── button.combo
/// │       ╰── box
/// │           ├── cellview
/// │           ╰── arrow
/// ╰── window.popup
/// ```
/// 
/// A normal combobox contains a box with the .linked class, a button
/// with the .combo class and inside those buttons, there are a cellview and
/// an arrow.
/// 
/// (plain Language Example):
/// ```plain
/// combobox
/// ├── box.linked
/// │   ├── entry.combo
/// │   ╰── button.combo
/// │       ╰── box
/// │           ╰── arrow
/// ╰── window.popup
/// ```
/// 
/// A GtkComboBox with an entry has a single CSS node with name combobox. It
/// contains a box with the .linked class. That box contains an entry and a
/// button, both with the .combo class added.
/// The button also contains another node with name arrow.
open class ComboBox: Bin, ComboBoxProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `ComboBox` instance.
    public init(_ op: UnsafeMutablePointer<GtkComboBox>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `ComboBoxProtocol`
    /// Will retain `GtkComboBox`.
    public convenience init<T: ComboBoxProtocol>(_ other: T) {
        self.init(cast(other.combo_box_ptr))
        g_object_ref(cast(combo_box_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkComboBox.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkComboBox.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkComboBox.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkComboBox>(opaquePointer))
    }

    /// Creates a new empty `GtkComboBox`.
    public convenience init() {
        let rv = gtk_combo_box_new()
        self.init(cast(rv))
    }

    /// Creates a new empty `GtkComboBox` using `area` to layout cells.
    public convenience init(area: CellAreaProtocol) {
        let rv = gtk_combo_box_new_with_area(cast(area.ptr))
        self.init(cast(rv))
    }

    /// Creates a new empty `GtkComboBox` with an entry.
    /// 
    /// The new combo box will use `area` to layout cells.
    public convenience init(areaAndEntry area: CellAreaProtocol) {
        let rv = gtk_combo_box_new_with_area_and_entry(cast(area.ptr))
        self.init(cast(rv))
    }

    /// Creates a new `GtkComboBox` with the model initialized to `model`.
    public convenience init(model: TreeModelProtocol) {
        let rv = gtk_combo_box_new_with_model(cast(model.ptr))
        self.init(cast(rv))
    }

    /// Creates a new empty `GtkComboBox` with an entry
    /// and with the model initialized to `model`.
    public convenience init(modelAndEntry model: TreeModelProtocol) {
        let rv = gtk_combo_box_new_with_model_and_entry(cast(model.ptr))
        self.init(cast(rv))
    }

    /// Creates a new empty `GtkComboBox` using `area` to layout cells.
    public static func newWith(area: CellAreaProtocol) -> ComboBox! {
        let rv = gtk_combo_box_new_with_area(cast(area.ptr))
        return rv.map { ComboBox(cast($0)) }
    }

    /// Creates a new empty `GtkComboBox` with an entry.
    /// 
    /// The new combo box will use `area` to layout cells.
    public static func newWith(areaAndEntry area: CellAreaProtocol) -> ComboBox! {
        let rv = gtk_combo_box_new_with_area_and_entry(cast(area.ptr))
        return rv.map { ComboBox(cast($0)) }
    }

    /// Creates a new empty `GtkComboBox` with an entry.
    public static func newWithEntry() -> ComboBox! {
        let rv = gtk_combo_box_new_with_entry()
        return rv.map { ComboBox(cast($0)) }
    }

    /// Creates a new `GtkComboBox` with the model initialized to `model`.
    public static func newWith(model: TreeModelProtocol) -> ComboBox! {
        let rv = gtk_combo_box_new_with_model(cast(model.ptr))
        return rv.map { ComboBox(cast($0)) }
    }

    /// Creates a new empty `GtkComboBox` with an entry
    /// and with the model initialized to `model`.
    public static func newWith(modelAndEntry model: TreeModelProtocol) -> ComboBox! {
        let rv = gtk_combo_box_new_with_model_and_entry(cast(model.ptr))
        return rv.map { ComboBox(cast($0)) }
    }

}

public enum ComboBoxPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    /// The item which is currently active. If the model is a non-flat treemodel,
    /// and the active item is not an immediate child of the root of the tree,
    /// this property has the value
    /// `gtk_tree_path_get_indices (path)[0]`,
    /// where `path` is the `GtkTreePath` of the active item.
    case active = "active"
    /// The value of the ID column of the active row.
    case activeID = "active-id"
    /// The add-tearoffs property controls whether generated menus
    /// have tearoff menu items.
    /// 
    /// Note that this only affects menu style combo boxes.
    ///
    /// **add-tearoffs is deprecated:**
    /// This method is deprecated.
    case addTearoffs = "add-tearoffs"
    case appPaintable = "app-paintable"
    case borderWidth = "border-width"
    /// Whether the dropdown button is sensitive when
    /// the model is empty.
    case buttonSensitivity = "button-sensitivity"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    /// The `GtkCellArea` used to layout cell renderers for this combo box.
    /// 
    /// If no area is specified when creating the combo box with `gtk_combo_box_new_with_area()`
    /// a horizontally oriented `GtkCellAreaBox` will be used.
    case cellArea = "cell-area"
    case child = "child"
    /// If this is set to a non-negative value, it must be the index of a column
    /// of type `G_TYPE_INT` in the model. The value in that column for each item
    /// will determine how many columns that item will span in the popup.
    /// Therefore, values in this column must be greater than zero, and the sum of
    /// an item’s column position + span should not exceed `GtkComboBox:wrap`-width.
    case columnSpanColumn = "column-span-column"
    case compositeChild = "composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    /// The column in the combo box's model to associate with strings from the entry
    /// if the combo was created with `GtkComboBox:has`-entry = `true`.
    case entryTextColumn = "entry-text-column"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    /// Whether the combo box has an entry.
    case hasEntry = "has-entry"
    case hasFocus = "has-focus"
    /// The has-frame property controls whether a frame
    /// is drawn around the entry.
    case hasFrame = "has-frame"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The column in the combo box's model that provides string
    /// IDs for the values in the model, if != -1.
    case idColumn = "id-column"
    case isFocus = "is-focus"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    /// The model from which the combo box takes the values shown
    /// in the list.
    case model = "model"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    /// Whether the popup's width should be a fixed width matching the
    /// allocated width of the combo box.
    case popupFixedWidth = "popup-fixed-width"
    /// Whether the combo boxes dropdown is popped up.
    /// Note that this property is mainly useful, because
    /// it allows you to connect to notify`popup`-shown.
    case popupShown = "popup-shown"
    case receivesDefault = "receives-default"
    case resizeMode = "resize-mode"
    /// If this is set to a non-negative value, it must be the index of a column
    /// of type `G_TYPE_INT` in the model. The value in that column for each item
    /// will determine how many rows that item will span in the popup. Therefore,
    /// values in this column must be greater than zero.
    case rowSpanColumn = "row-span-column"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    /// A title that may be displayed by the window manager
    /// when the popup is torn-off.
    ///
    /// **tearoff-title is deprecated:**
    /// This method is deprecated.
    case tearoffTitle = "tearoff-title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
    /// If wrap-width is set to a positive value, items in the popup will be laid
    /// out along multiple columns, starting a new row on reaching the wrap width.
    case wrapWidth = "wrap-width"
}

public extension ComboBoxProtocol {
    /// Bind a `ComboBoxPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ComboBoxPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(combo_box_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum ComboBoxSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    case add = "add"
    /// The `button`-press-event signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button`-release-event signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    /// The changed signal is emitted when the active
    /// item is changed. The can be due to the user selecting
    /// a different item from the list, or due to a
    /// call to `gtk_combo_box_set_active_iter()`.
    /// It will also be emitted while typing into the entry of a combo box
    /// with an entry.
    case changed = "changed"
    case checkResize = "check-resize"
    /// The `child`-notify signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The `composited`-changed signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure`-event signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete`-event signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy`-event signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag`-begin signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag`-data-delete signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag`-data-get signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag`-data-received signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag`-drop signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag`-drop signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag`-data-received handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag`-end signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag`-begin.
    case dragEnd = "drag-end"
    /// The `drag`-failed signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag`-leave signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag`-motion, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag`-leave signal is also emitted before the
    /// `drag`-drop signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag`-motion signal handler.
    case dragLeave = "drag-leave"
    /// The `drag`-motion signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag`-data-received
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag`-leave and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enter`-notify-event will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key`-press-event) and finally a generic
    /// `GtkWidget::event`-after signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event`-after will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `focus`-in-event signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus`-out-event signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// For combo boxes that are created with an entry (See GtkComboBox:has-entry).
    /// 
    /// A signal which allows you to change how the text displayed in a combo box's
    /// entry is displayed.
    /// 
    /// Connect a signal handler which returns an allocated string representing
    /// `path`. That string will then be used to set the text in the combo box's entry.
    /// The default signal handler uses the text from the GtkComboBox`entry`-text-column
    /// model column.
    /// 
    /// Here's an example signal handler which fetches data from the model and
    /// displays it in the entry.
    /// (C Language Example):
    /// ```C
    /// static gchar*
    /// format_entry_text_callback (GtkComboBox *combo,
    ///                             const gchar *path,
    ///                             gpointer     user_data)
    /// {
    ///   GtkTreeIter iter;
    ///   GtkTreeModel model;
    ///   gdouble      value;
    /// 
    ///   model = gtk_combo_box_get_model (combo);
    /// 
    ///   gtk_tree_model_get_iter_from_string (model, &iter, path);
    ///   gtk_tree_model_get (model, &iter,
    ///                       THE_DOUBLE_VALUE_COLUMN, &value,
    ///                       -1);
    /// 
    ///   return g_strdup_printf ("%g", value);
    /// }
    /// ```
    /// 
    case formatEntryText = "format-entry-text"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab`-notify signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy`-changed signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key`-press-event signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key`-release-event signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `leave`-notify-event will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map`-event will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map`-event signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion`-notify-event signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    /// The `move`-active signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to move the active selection.
    case moveActive = "move-active"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent`-set signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// The `popdown` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to popdown the combo box list.
    /// 
    /// The default bindings for this signal are Alt+Up and Escape.
    case popdown = "popdown"
    /// The `popup` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to popup the combo box list.
    /// 
    /// The default binding for this signal is Alt+Down.
    case popup = "popup"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The `property`-notify-event signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// The `screen`-changed signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll`-event signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `selection`-clear-event signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection`-request-event signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-changed signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style`-set signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style`-updated signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style`-updated signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap`-event signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility`-notify-event will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    /// The `window`-state-event will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    /// The item which is currently active. If the model is a non-flat treemodel,
    /// and the active item is not an immediate child of the root of the tree,
    /// this property has the value
    /// `gtk_tree_path_get_indices (path)[0]`,
    /// where `path` is the `GtkTreePath` of the active item.
    case notifyActive = "notify::active"
    /// The value of the ID column of the active row.
    case notifyActiveID = "notify::active-id"
    /// The add-tearoffs property controls whether generated menus
    /// have tearoff menu items.
    /// 
    /// Note that this only affects menu style combo boxes.
    ///
    /// **add-tearoffs is deprecated:**
    /// This method is deprecated.
    case notifyAddTearoffs = "notify::add-tearoffs"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBorderWidth = "notify::border-width"
    /// Whether the dropdown button is sensitive when
    /// the model is empty.
    case notifyButtonSensitivity = "notify::button-sensitivity"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    /// The `GtkCellArea` used to layout cell renderers for this combo box.
    /// 
    /// If no area is specified when creating the combo box with `gtk_combo_box_new_with_area()`
    /// a horizontally oriented `GtkCellAreaBox` will be used.
    case notifyCellArea = "notify::cell-area"
    case notifyChild = "notify::child"
    /// If this is set to a non-negative value, it must be the index of a column
    /// of type `G_TYPE_INT` in the model. The value in that column for each item
    /// will determine how many columns that item will span in the popup.
    /// Therefore, values in this column must be greater than zero, and the sum of
    /// an item’s column position + span should not exceed `GtkComboBox:wrap`-width.
    case notifyColumnSpanColumn = "notify::column-span-column"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    /// The column in the combo box's model to associate with strings from the entry
    /// if the combo was created with `GtkComboBox:has`-entry = `true`.
    case notifyEntryTextColumn = "notify::entry-text-column"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    /// Whether the combo box has an entry.
    case notifyHasEntry = "notify::has-entry"
    case notifyHasFocus = "notify::has-focus"
    /// The has-frame property controls whether a frame
    /// is drawn around the entry.
    case notifyHasFrame = "notify::has-frame"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The column in the combo box's model that provides string
    /// IDs for the values in the model, if != -1.
    case notifyIDColumn = "notify::id-column"
    case notifyIsFocus = "notify::is-focus"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    /// The model from which the combo box takes the values shown
    /// in the list.
    case notifyModel = "notify::model"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    /// Whether the popup's width should be a fixed width matching the
    /// allocated width of the combo box.
    case notifyPopupFixedWidth = "notify::popup-fixed-width"
    /// Whether the combo boxes dropdown is popped up.
    /// Note that this property is mainly useful, because
    /// it allows you to connect to notify`popup`-shown.
    case notifyPopupShown = "notify::popup-shown"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizeMode = "notify::resize-mode"
    /// If this is set to a non-negative value, it must be the index of a column
    /// of type `G_TYPE_INT` in the model. The value in that column for each item
    /// will determine how many rows that item will span in the popup. Therefore,
    /// values in this column must be greater than zero.
    case notifyRowSpanColumn = "notify::row-span-column"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    /// A title that may be displayed by the window manager
    /// when the popup is torn-off.
    ///
    /// **tearoff-title is deprecated:**
    /// This method is deprecated.
    case notifyTearoffTitle = "notify::tearoff-title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
    /// If wrap-width is set to a positive value, items in the popup will be laid
    /// out along multiple columns, starting a new row on reaching the wrap width.
    case notifyWrapWidth = "notify::wrap-width"
}

public extension ComboBoxProtocol {
    /// Connect a `ComboBoxSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: ComboBoxSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(combo_box_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension ComboBoxProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkComboBox` instance.
    var combo_box_ptr: UnsafeMutablePointer<GtkComboBox> { return ptr.assumingMemoryBound(to: GtkComboBox.self) }

    /// Returns the index of the currently active item, or -1 if there’s no
    /// active item. If the model is a non-flat treemodel, and the active item
    /// is not an immediate child of the root of the tree, this function returns
    /// `gtk_tree_path_get_indices (path)[0]`, where
    /// `path` is the `GtkTreePath` of the active item.
    func getActive() -> CInt {
        let rv = gtk_combo_box_get_active(cast(combo_box_ptr))
        return CInt(rv)
    }

    /// Returns the ID of the active row of `combo_box`.  This value is taken
    /// from the active row and the column specified by the `GtkComboBox:id`-column
    /// property of `combo_box` (see `gtk_combo_box_set_id_column()`).
    /// 
    /// The returned value is an interned string which means that you can
    /// compare the pointer by value to other interned strings and that you
    /// must not free it.
    /// 
    /// If the `GtkComboBox:id`-column property of `combo_box` is not set, or if
    /// no row is active, or if the active row has a `nil` ID value, then `nil`
    /// is returned.
    func getActiveID() -> String! {
        let rv = gtk_combo_box_get_active_id(cast(combo_box_ptr))
        return rv.map { String(cString: UnsafePointer<CChar>($0)) }
    }

    /// Sets `iter` to point to the currently active item, if any item is active.
    /// Otherwise, `iter` is left unchanged.
    func getActive(iter: TreeIterProtocol) -> Bool {
        let rv = gtk_combo_box_get_active_iter(cast(combo_box_ptr), cast(iter.ptr))
        return Bool(rv != 0)
    }

    /// Gets the current value of the :add-tearoffs property.
    ///
    /// **get_add_tearoffs is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func getAddTearoffs() -> Bool {
        let rv = gtk_combo_box_get_add_tearoffs(cast(combo_box_ptr))
        return Bool(rv != 0)
    }

    /// Returns whether the combo box sets the dropdown button
    /// sensitive or not when there are no items in the model.
    func getButtonSensitivity() -> GtkSensitivityType {
        let rv = gtk_combo_box_get_button_sensitivity(cast(combo_box_ptr))
        return rv
    }

    /// Returns the column with column span information for `combo_box`.
    func getColumnSpanColumn() -> CInt {
        let rv = gtk_combo_box_get_column_span_column(cast(combo_box_ptr))
        return CInt(rv)
    }

    /// Returns the column which `combo_box` is using to get the strings
    /// from to display in the internal entry.
    func getEntryTextColumn() -> CInt {
        let rv = gtk_combo_box_get_entry_text_column(cast(combo_box_ptr))
        return CInt(rv)
    }

    /// Returns whether the combo box grabs focus when it is clicked
    /// with the mouse. See `gtk_combo_box_set_focus_on_click()`.
    ///
    /// **get_focus_on_click is deprecated:**
    /// Use gtk_widget_get_focus_on_click() instead
    @available(*, deprecated) @available(*, deprecated) func getFocusOnClick() -> Bool {
        let rv = gtk_combo_box_get_focus_on_click(cast(combo_box_ptr))
        return Bool(rv != 0)
    }

    /// Returns whether the combo box has an entry.
    func getHasEntry() -> Bool {
        let rv = gtk_combo_box_get_has_entry(cast(combo_box_ptr))
        return Bool(rv != 0)
    }

    /// Returns the column which `combo_box` is using to get string IDs
    /// for values from.
    func getIDColumn() -> CInt {
        let rv = gtk_combo_box_get_id_column(cast(combo_box_ptr))
        return CInt(rv)
    }

    /// Returns the `GtkTreeModel` which is acting as data source for `combo_box`.
    func getModel() -> UnsafeMutablePointer<GtkTreeModel>! {
        let rv = gtk_combo_box_get_model(cast(combo_box_ptr))
        return cast(rv)
    }

    /// Gets the accessible object corresponding to the combo box’s popup.
    /// 
    /// This function is mostly intended for use by accessibility technologies;
    /// applications should have little use for it.
    func getPopupAccessible() -> UnsafeMutablePointer<AtkObject>! {
        let rv = gtk_combo_box_get_popup_accessible(cast(combo_box_ptr))
        return cast(rv)
    }

    /// Gets whether the popup uses a fixed width matching
    /// the allocated width of the combo box.
    func getPopupFixedWidth() -> Bool {
        let rv = gtk_combo_box_get_popup_fixed_width(cast(combo_box_ptr))
        return Bool(rv != 0)
    }

    /// Returns the current row separator function.
    func getRowSeparatorFunc() -> GtkTreeViewRowSeparatorFunc! {
        let rv = gtk_combo_box_get_row_separator_func(cast(combo_box_ptr))
        return rv
    }

    /// Returns the column with row span information for `combo_box`.
    func getRowSpanColumn() -> CInt {
        let rv = gtk_combo_box_get_row_span_column(cast(combo_box_ptr))
        return CInt(rv)
    }

    /// Gets the current title of the menu in tearoff mode. See
    /// `gtk_combo_box_set_add_tearoffs()`.
    ///
    /// **get_title is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func getTitle() -> String! {
        let rv = gtk_combo_box_get_title(cast(combo_box_ptr))
        return rv.map { String(cString: UnsafePointer<CChar>($0)) }
    }

    /// Returns the wrap width which is used to determine the number of columns
    /// for the popup menu. If the wrap width is larger than 1, the combo box
    /// is in table mode.
    func getWrapWidth() -> CInt {
        let rv = gtk_combo_box_get_wrap_width(cast(combo_box_ptr))
        return CInt(rv)
    }

    /// Hides the menu or dropdown list of `combo_box`.
    /// 
    /// This function is mostly intended for use by accessibility technologies;
    /// applications should have little use for it.
    func popdown() {
        gtk_combo_box_popdown(cast(combo_box_ptr))
    
    }

    /// Pops up the menu or dropdown list of `combo_box`.
    /// 
    /// This function is mostly intended for use by accessibility technologies;
    /// applications should have little use for it.
    /// 
    /// Before calling this, `combo_box` must be mapped, or nothing will happen.
    func popup() {
        gtk_combo_box_popup(cast(combo_box_ptr))
    
    }

    /// Pops up the menu or dropdown list of `combo_box`, the popup window
    /// will be grabbed so only `device` and its associated pointer/keyboard
    /// are the only `GdkDevices` able to send events to it.
    func popupFor(device: Gdk.DeviceProtocol) {
        gtk_combo_box_popup_for_device(cast(combo_box_ptr), cast(device.ptr))
    
    }

    /// Sets the active item of `combo_box` to be the item at `index`.
    func setActive(index_: CInt) {
        gtk_combo_box_set_active(cast(combo_box_ptr), gint(index_))
    
    }

    /// Changes the active row of `combo_box` to the one that has an ID equal to
    /// `active_id`, or unsets the active row if `active_id` is `nil`.  Rows having
    /// a `nil` ID string cannot be made active by this function.
    /// 
    /// If the `GtkComboBox:id`-column property of `combo_box` is unset or if no
    /// row has the given ID then the function does nothing and returns `false`.
    func set(activeID active_id: UnsafePointer<gchar>) -> Bool {
        let rv = gtk_combo_box_set_active_id(cast(combo_box_ptr), active_id)
        return Bool(rv != 0)
    }

    /// Sets the current active item to be the one referenced by `iter`, or
    /// unsets the active item if `iter` is `nil`.
    func setActive(iter: TreeIterProtocol) {
        gtk_combo_box_set_active_iter(cast(combo_box_ptr), cast(iter.ptr))
    
    }

    /// Sets whether the popup menu should have a tearoff
    /// menu item.
    ///
    /// **set_add_tearoffs is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func set(addTearoffs add_tearoffs: Bool) {
        gtk_combo_box_set_add_tearoffs(cast(combo_box_ptr), gboolean(add_tearoffs ? 1 : 0))
    
    }

    /// Sets whether the dropdown button of the combo box should be
    /// always sensitive (`GTK_SENSITIVITY_ON`), never sensitive (`GTK_SENSITIVITY_OFF`)
    /// or only if there is at least one item to display (`GTK_SENSITIVITY_AUTO`).
    func setButton(sensitivity: SensitivityType) {
        gtk_combo_box_set_button_sensitivity(cast(combo_box_ptr), sensitivity)
    
    }

    /// Sets the column with column span information for `combo_box` to be
    /// `column_span`. The column span column contains integers which indicate
    /// how many columns an item should span.
    func setColumnSpanColumn(columnSpan column_span: CInt) {
        gtk_combo_box_set_column_span_column(cast(combo_box_ptr), gint(column_span))
    
    }

    /// Sets the model column which `combo_box` should use to get strings from
    /// to be `text_column`. The column `text_column` in the model of `combo_box`
    /// must be of type `G_TYPE_STRING`.
    /// 
    /// This is only relevant if `combo_box` has been created with
    /// `GtkComboBox:has`-entry as `true`.
    func setEntry(textColumn text_column: CInt) {
        gtk_combo_box_set_entry_text_column(cast(combo_box_ptr), gint(text_column))
    
    }

    /// Sets whether the combo box will grab focus when it is clicked with
    /// the mouse. Making mouse clicks not grab focus is useful in places
    /// like toolbars where you don’t want the keyboard focus removed from
    /// the main area of the application.
    ///
    /// **set_focus_on_click is deprecated:**
    /// Use gtk_widget_set_focus_on_click() instead
    @available(*, deprecated) @available(*, deprecated) func set(focusOnClick focus_on_click: Bool) {
        gtk_combo_box_set_focus_on_click(cast(combo_box_ptr), gboolean(focus_on_click ? 1 : 0))
    
    }

    /// Sets the model column which `combo_box` should use to get string IDs
    /// for values from. The column `id_column` in the model of `combo_box`
    /// must be of type `G_TYPE_STRING`.
    func set(idColumn id_column: CInt) {
        gtk_combo_box_set_id_column(cast(combo_box_ptr), gint(id_column))
    
    }

    /// Sets the model used by `combo_box` to be `model`. Will unset a previously set
    /// model (if applicable). If model is `nil`, then it will unset the model.
    /// 
    /// Note that this function does not clear the cell renderers, you have to
    /// call `gtk_cell_layout_clear()` yourself if you need to set up different
    /// cell renderers for the new model.
    func set(model: TreeModelProtocol) {
        gtk_combo_box_set_model(cast(combo_box_ptr), cast(model.ptr))
    
    }

    /// Specifies whether the popup’s width should be a fixed width
    /// matching the allocated width of the combo box.
    func setPopupFixedWidth(fixed: Bool) {
        gtk_combo_box_set_popup_fixed_width(cast(combo_box_ptr), gboolean(fixed ? 1 : 0))
    
    }

    /// Sets the row separator function, which is used to determine
    /// whether a row should be drawn as a separator. If the row separator
    /// function is `nil`, no separators are drawn. This is the default value.
    func setRowSeparatorFunc(_ func_: @escaping TreeViewRowSeparatorFunc, data: UnsafeMutableRawPointer, destroy: @escaping GLib.DestroyNotify) {
        gtk_combo_box_set_row_separator_func(cast(combo_box_ptr), func_, cast(data), destroy)
    
    }

    /// Sets the column with row span information for `combo_box` to be `row_span`.
    /// The row span column contains integers which indicate how many rows
    /// an item should span.
    func setRowSpanColumn(rowSpan row_span: CInt) {
        gtk_combo_box_set_row_span_column(cast(combo_box_ptr), gint(row_span))
    
    }

    /// Sets the menu’s title in tearoff mode.
    ///
    /// **set_title is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func set(title: UnsafePointer<gchar>) {
        gtk_combo_box_set_title(cast(combo_box_ptr), title)
    
    }

    /// Sets the wrap width of `combo_box` to be `width`. The wrap width is basically
    /// the preferred number of columns when you want the popup to be layed out
    /// in a table.
    func setWrap(width: CInt) {
        gtk_combo_box_set_wrap_width(cast(combo_box_ptr), gint(width))
    
    }
    /// The item which is currently active. If the model is a non-flat treemodel,
    /// and the active item is not an immediate child of the root of the tree,
    /// this property has the value
    /// `gtk_tree_path_get_indices (path)[0]`,
    /// where `path` is the `GtkTreePath` of the active item.
    var active: CInt {
        /// Returns the index of the currently active item, or -1 if there’s no
        /// active item. If the model is a non-flat treemodel, and the active item
        /// is not an immediate child of the root of the tree, this function returns
        /// `gtk_tree_path_get_indices (path)[0]`, where
        /// `path` is the `GtkTreePath` of the active item.
        get {
            let rv = gtk_combo_box_get_active(cast(combo_box_ptr))
            return CInt(rv)
        }
        /// Sets the active item of `combo_box` to be the item at `index`.
        nonmutating set {
            gtk_combo_box_set_active(cast(combo_box_ptr), gint(newValue))
        }
    }

    /// Returns the ID of the active row of `combo_box`.  This value is taken
    /// from the active row and the column specified by the `GtkComboBox:id`-column
    /// property of `combo_box` (see `gtk_combo_box_set_id_column()`).
    /// 
    /// The returned value is an interned string which means that you can
    /// compare the pointer by value to other interned strings and that you
    /// must not free it.
    /// 
    /// If the `GtkComboBox:id`-column property of `combo_box` is not set, or if
    /// no row is active, or if the active row has a `nil` ID value, then `nil`
    /// is returned.
    var activeID: String! {
        /// Returns the ID of the active row of `combo_box`.  This value is taken
        /// from the active row and the column specified by the `GtkComboBox:id`-column
        /// property of `combo_box` (see `gtk_combo_box_set_id_column()`).
        /// 
        /// The returned value is an interned string which means that you can
        /// compare the pointer by value to other interned strings and that you
        /// must not free it.
        /// 
        /// If the `GtkComboBox:id`-column property of `combo_box` is not set, or if
        /// no row is active, or if the active row has a `nil` ID value, then `nil`
        /// is returned.
        get {
            let rv = gtk_combo_box_get_active_id(cast(combo_box_ptr))
            return rv.map { String(cString: UnsafePointer<CChar>($0)) }
        }
        /// Changes the active row of `combo_box` to the one that has an ID equal to
        /// `active_id`, or unsets the active row if `active_id` is `nil`.  Rows having
        /// a `nil` ID string cannot be made active by this function.
        /// 
        /// If the `GtkComboBox:id`-column property of `combo_box` is unset or if no
        /// row has the given ID then the function does nothing and returns `false`.
        nonmutating set {
            let _ = gtk_combo_box_set_active_id(cast(combo_box_ptr), newValue)
        }
    }

    /// Gets the current value of the :add-tearoffs property.
    ///
    /// **get_add_tearoffs is deprecated:**
    /// This method is deprecated.
    var addTearoffs: Bool {
        /// Gets the current value of the :add-tearoffs property.
        ///
        /// **get_add_tearoffs is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated) get {
            let rv = gtk_combo_box_get_add_tearoffs(cast(combo_box_ptr))
            return Bool(rv != 0)
        }
        /// Sets whether the popup menu should have a tearoff
        /// menu item.
        ///
        /// **set_add_tearoffs is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated) nonmutating set {
            gtk_combo_box_set_add_tearoffs(cast(combo_box_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Returns whether the combo box sets the dropdown button
    /// sensitive or not when there are no items in the model.
    var buttonSensitivity: GtkSensitivityType {
        /// Returns whether the combo box sets the dropdown button
        /// sensitive or not when there are no items in the model.
        get {
            let rv = gtk_combo_box_get_button_sensitivity(cast(combo_box_ptr))
            return rv
        }
        /// Sets whether the dropdown button of the combo box should be
        /// always sensitive (`GTK_SENSITIVITY_ON`), never sensitive (`GTK_SENSITIVITY_OFF`)
        /// or only if there is at least one item to display (`GTK_SENSITIVITY_AUTO`).
        nonmutating set {
            gtk_combo_box_set_button_sensitivity(cast(combo_box_ptr), newValue)
        }
    }

    /// Returns the column with column span information for `combo_box`.
    var columnSpanColumn: CInt {
        /// Returns the column with column span information for `combo_box`.
        get {
            let rv = gtk_combo_box_get_column_span_column(cast(combo_box_ptr))
            return CInt(rv)
        }
        /// Sets the column with column span information for `combo_box` to be
        /// `column_span`. The column span column contains integers which indicate
        /// how many columns an item should span.
        nonmutating set {
            gtk_combo_box_set_column_span_column(cast(combo_box_ptr), gint(newValue))
        }
    }

    /// Returns the column which `combo_box` is using to get the strings
    /// from to display in the internal entry.
    var entryTextColumn: CInt {
        /// Returns the column which `combo_box` is using to get the strings
        /// from to display in the internal entry.
        get {
            let rv = gtk_combo_box_get_entry_text_column(cast(combo_box_ptr))
            return CInt(rv)
        }
        /// Sets the model column which `combo_box` should use to get strings from
        /// to be `text_column`. The column `text_column` in the model of `combo_box`
        /// must be of type `G_TYPE_STRING`.
        /// 
        /// This is only relevant if `combo_box` has been created with
        /// `GtkComboBox:has`-entry as `true`.
        nonmutating set {
            gtk_combo_box_set_entry_text_column(cast(combo_box_ptr), gint(newValue))
        }
    }

    /// Returns whether the combo box grabs focus when it is clicked
    /// with the mouse. See `gtk_combo_box_set_focus_on_click()`.
    ///
    /// **get_focus_on_click is deprecated:**
    /// Use gtk_widget_get_focus_on_click() instead
    @available(*, deprecated) var focusOnClick: Bool {
        /// Returns whether the combo box grabs focus when it is clicked
        /// with the mouse. See `gtk_combo_box_set_focus_on_click()`.
        ///
        /// **get_focus_on_click is deprecated:**
        /// Use gtk_widget_get_focus_on_click() instead
        @available(*, deprecated) get {
            let rv = gtk_combo_box_get_focus_on_click(cast(combo_box_ptr))
            return Bool(rv != 0)
        }
        /// Sets whether the combo box will grab focus when it is clicked with
        /// the mouse. Making mouse clicks not grab focus is useful in places
        /// like toolbars where you don’t want the keyboard focus removed from
        /// the main area of the application.
        ///
        /// **set_focus_on_click is deprecated:**
        /// Use gtk_widget_set_focus_on_click() instead
        @available(*, deprecated) nonmutating set {
            gtk_combo_box_set_focus_on_click(cast(combo_box_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Returns whether the combo box has an entry.
    var hasEntry: Bool {
        /// Returns whether the combo box has an entry.
        get {
            let rv = gtk_combo_box_get_has_entry(cast(combo_box_ptr))
            return Bool(rv != 0)
        }
    }

    /// Returns the column which `combo_box` is using to get string IDs
    /// for values from.
    var idColumn: CInt {
        /// Returns the column which `combo_box` is using to get string IDs
        /// for values from.
        get {
            let rv = gtk_combo_box_get_id_column(cast(combo_box_ptr))
            return CInt(rv)
        }
        /// Sets the model column which `combo_box` should use to get string IDs
        /// for values from. The column `id_column` in the model of `combo_box`
        /// must be of type `G_TYPE_STRING`.
        nonmutating set {
            gtk_combo_box_set_id_column(cast(combo_box_ptr), gint(newValue))
        }
    }

    /// The model from which the combo box takes the values shown
    /// in the list.
    var model: UnsafeMutablePointer<GtkTreeModel>! {
        /// Returns the `GtkTreeModel` which is acting as data source for `combo_box`.
        get {
            let rv = gtk_combo_box_get_model(cast(combo_box_ptr))
            return cast(rv)
        }
        /// Sets the model used by `combo_box` to be `model`. Will unset a previously set
        /// model (if applicable). If model is `nil`, then it will unset the model.
        /// 
        /// Note that this function does not clear the cell renderers, you have to
        /// call `gtk_cell_layout_clear()` yourself if you need to set up different
        /// cell renderers for the new model.
        nonmutating set {
            gtk_combo_box_set_model(cast(combo_box_ptr), cast(newValue))
        }
    }

    /// Gets the accessible object corresponding to the combo box’s popup.
    /// 
    /// This function is mostly intended for use by accessibility technologies;
    /// applications should have little use for it.
    var popupAccessible: UnsafeMutablePointer<AtkObject>! {
        /// Gets the accessible object corresponding to the combo box’s popup.
        /// 
        /// This function is mostly intended for use by accessibility technologies;
        /// applications should have little use for it.
        get {
            let rv = gtk_combo_box_get_popup_accessible(cast(combo_box_ptr))
            return cast(rv)
        }
    }

    /// Gets whether the popup uses a fixed width matching
    /// the allocated width of the combo box.
    var popupFixedWidth: Bool {
        /// Gets whether the popup uses a fixed width matching
        /// the allocated width of the combo box.
        get {
            let rv = gtk_combo_box_get_popup_fixed_width(cast(combo_box_ptr))
            return Bool(rv != 0)
        }
        /// Specifies whether the popup’s width should be a fixed width
        /// matching the allocated width of the combo box.
        nonmutating set {
            gtk_combo_box_set_popup_fixed_width(cast(combo_box_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Returns the current row separator function.
    var rowSeparatorFunc: GtkTreeViewRowSeparatorFunc! {
        /// Returns the current row separator function.
        get {
            let rv = gtk_combo_box_get_row_separator_func(cast(combo_box_ptr))
            return rv
        }
    }

    /// Returns the column with row span information for `combo_box`.
    var rowSpanColumn: CInt {
        /// Returns the column with row span information for `combo_box`.
        get {
            let rv = gtk_combo_box_get_row_span_column(cast(combo_box_ptr))
            return CInt(rv)
        }
        /// Sets the column with row span information for `combo_box` to be `row_span`.
        /// The row span column contains integers which indicate how many rows
        /// an item should span.
        nonmutating set {
            gtk_combo_box_set_row_span_column(cast(combo_box_ptr), gint(newValue))
        }
    }

    /// Gets the current title of the menu in tearoff mode. See
    /// `gtk_combo_box_set_add_tearoffs()`.
    ///
    /// **get_title is deprecated:**
    /// This method is deprecated.
    var title: String! {
        /// Gets the current title of the menu in tearoff mode. See
        /// `gtk_combo_box_set_add_tearoffs()`.
        ///
        /// **get_title is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated) get {
            let rv = gtk_combo_box_get_title(cast(combo_box_ptr))
            return rv.map { String(cString: UnsafePointer<CChar>($0)) }
        }
        /// Sets the menu’s title in tearoff mode.
        ///
        /// **set_title is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated) nonmutating set {
            gtk_combo_box_set_title(cast(combo_box_ptr), newValue)
        }
    }

    /// Returns the wrap width which is used to determine the number of columns
    /// for the popup menu. If the wrap width is larger than 1, the combo box
    /// is in table mode.
    var wrapWidth: CInt {
        /// Returns the wrap width which is used to determine the number of columns
        /// for the popup menu. If the wrap width is larger than 1, the combo box
        /// is in table mode.
        get {
            let rv = gtk_combo_box_get_wrap_width(cast(combo_box_ptr))
            return CInt(rv)
        }
        /// Sets the wrap width of `combo_box` to be `width`. The wrap width is basically
        /// the preferred number of columns when you want the popup to be layed out
        /// in a table.
        nonmutating set {
            gtk_combo_box_set_wrap_width(cast(combo_box_ptr), gint(newValue))
        }
    }
}



// MARK: - ComboBoxAccessible Class

/// The `ComboBoxAccessibleProtocol` protocol exposes the methods and properties of an underlying `GtkComboBoxAccessible` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ComboBoxAccessible`.
/// Alternatively, use `ComboBoxAccessibleRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///

public protocol ComboBoxAccessibleProtocol: ContainerAccessibleProtocol, Atk.ActionProtocol, Atk.SelectionProtocol {
    /// Untyped pointer to the underlying `GtkComboBoxAccessible` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkComboBoxAccessible` instance.
    var combo_box_accessible_ptr: UnsafeMutablePointer<GtkComboBoxAccessible> { get }
}

/// The `ComboBoxAccessibleRef` type acts as a lightweight Swift reference to an underlying `GtkComboBoxAccessible` instance.
/// It exposes methods that can operate on this data type through `ComboBoxAccessibleProtocol` conformance.
/// Use `ComboBoxAccessibleRef` only as an `unowned` reference to an existing `GtkComboBoxAccessible` instance.
///

public struct ComboBoxAccessibleRef: ComboBoxAccessibleProtocol {
    /// Untyped pointer to the underlying `GtkComboBoxAccessible` instance.
    /// For type-safe access, use the generated, typed pointer `combo_box_accessible_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension ComboBoxAccessibleRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkComboBoxAccessible>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `ComboBoxAccessibleProtocol`
    init<T: ComboBoxAccessibleProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxAccessibleProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxAccessibleProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxAccessibleProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxAccessibleProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxAccessibleProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `ComboBoxAccessible` type acts as a reference-counted owner of an underlying `GtkComboBoxAccessible` instance.
/// It provides the methods that can operate on this data type through `ComboBoxAccessibleProtocol` conformance.
/// Use `ComboBoxAccessible` as a strong reference or owner of a `GtkComboBoxAccessible` instance.
///

open class ComboBoxAccessible: ContainerAccessible, ComboBoxAccessibleProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `ComboBoxAccessible` instance.
    public init(_ op: UnsafeMutablePointer<GtkComboBoxAccessible>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `ComboBoxAccessibleProtocol`
    /// Will retain `GtkComboBoxAccessible`.
    public convenience init<T: ComboBoxAccessibleProtocol>(_ other: T) {
        self.init(cast(other.combo_box_accessible_ptr))
        g_object_ref(cast(combo_box_accessible_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxAccessibleProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkComboBoxAccessible.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxAccessibleProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkComboBoxAccessible.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxAccessibleProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkComboBoxAccessible.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxAccessibleProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkComboBoxAccessible>(opaquePointer))
    }



}

public enum ComboBoxAccessiblePropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case widget = "widget"
}

public extension ComboBoxAccessibleProtocol {
    /// Bind a `ComboBoxAccessiblePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ComboBoxAccessiblePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(combo_box_accessible_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum ComboBoxAccessibleSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyWidget = "notify::widget"
}

public extension ComboBoxAccessibleProtocol {
    /// Connect a `ComboBoxAccessibleSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: ComboBoxAccessibleSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(combo_box_accessible_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension ComboBoxAccessibleProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkComboBoxAccessible` instance.
    var combo_box_accessible_ptr: UnsafeMutablePointer<GtkComboBoxAccessible> { return ptr.assumingMemoryBound(to: GtkComboBoxAccessible.self) }

}



// MARK: - ComboBoxText Class

/// The `ComboBoxTextProtocol` protocol exposes the methods and properties of an underlying `GtkComboBoxText` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ComboBoxText`.
/// Alternatively, use `ComboBoxTextRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A GtkComboBoxText is a simple variant of `GtkComboBox` that hides
/// the model-view complexity for simple text-only use cases.
/// 
/// To create a GtkComboBoxText, use `gtk_combo_box_text_new()` or
/// `gtk_combo_box_text_new_with_entry()`.
/// 
/// You can add items to a GtkComboBoxText with
/// `gtk_combo_box_text_append_text()`, `gtk_combo_box_text_insert_text()`
/// or `gtk_combo_box_text_prepend_text()` and remove options with
/// `gtk_combo_box_text_remove()`.
/// 
/// If the GtkComboBoxText contains an entry (via the “has-entry” property),
/// its contents can be retrieved using `gtk_combo_box_text_get_active_text()`.
/// The entry itself can be accessed by calling `gtk_bin_get_child()` on the
/// combo box.
/// 
/// You should not call `gtk_combo_box_set_model()` or attempt to pack more cells
/// into this combo box via its GtkCellLayout interface.
/// 
/// # GtkComboBoxText as GtkBuildable
/// 
/// The GtkComboBoxText implementation of the GtkBuildable interface supports
/// adding items directly using the <items> element and specifying <item>
/// elements for each item. Each <item> element can specify the “id”
/// corresponding to the appended text and also supports the regular
/// translation attributes “translatable”, “context” and “comments”.
/// 
/// Here is a UI definition fragment specifying GtkComboBoxText items:
/// ```
/// <object class="GtkComboBoxText">
///   <items>
///     <item translatable="yes" id="factory">Factory</item>
///     <item translatable="yes" id="home">Home</item>
///     <item translatable="yes" id="subway">Subway</item>
///   </items>
/// </object>
/// ```
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// combobox
/// ╰── box.linked
///     ├── entry.combo
///     ├── button.combo
///     ╰── window.popup
/// ```
/// 
/// GtkComboBoxText has a single CSS node with name combobox. It adds
/// the style class .combo to the main CSS nodes of its entry and button
/// children, and the .linked class to the node of its internal box.
public protocol ComboBoxTextProtocol: ComboBoxProtocol {
    /// Untyped pointer to the underlying `GtkComboBoxText` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkComboBoxText` instance.
    var combo_box_text_ptr: UnsafeMutablePointer<GtkComboBoxText> { get }
}

/// The `ComboBoxTextRef` type acts as a lightweight Swift reference to an underlying `GtkComboBoxText` instance.
/// It exposes methods that can operate on this data type through `ComboBoxTextProtocol` conformance.
/// Use `ComboBoxTextRef` only as an `unowned` reference to an existing `GtkComboBoxText` instance.
///
/// A GtkComboBoxText is a simple variant of `GtkComboBox` that hides
/// the model-view complexity for simple text-only use cases.
/// 
/// To create a GtkComboBoxText, use `gtk_combo_box_text_new()` or
/// `gtk_combo_box_text_new_with_entry()`.
/// 
/// You can add items to a GtkComboBoxText with
/// `gtk_combo_box_text_append_text()`, `gtk_combo_box_text_insert_text()`
/// or `gtk_combo_box_text_prepend_text()` and remove options with
/// `gtk_combo_box_text_remove()`.
/// 
/// If the GtkComboBoxText contains an entry (via the “has-entry” property),
/// its contents can be retrieved using `gtk_combo_box_text_get_active_text()`.
/// The entry itself can be accessed by calling `gtk_bin_get_child()` on the
/// combo box.
/// 
/// You should not call `gtk_combo_box_set_model()` or attempt to pack more cells
/// into this combo box via its GtkCellLayout interface.
/// 
/// # GtkComboBoxText as GtkBuildable
/// 
/// The GtkComboBoxText implementation of the GtkBuildable interface supports
/// adding items directly using the <items> element and specifying <item>
/// elements for each item. Each <item> element can specify the “id”
/// corresponding to the appended text and also supports the regular
/// translation attributes “translatable”, “context” and “comments”.
/// 
/// Here is a UI definition fragment specifying GtkComboBoxText items:
/// ```
/// <object class="GtkComboBoxText">
///   <items>
///     <item translatable="yes" id="factory">Factory</item>
///     <item translatable="yes" id="home">Home</item>
///     <item translatable="yes" id="subway">Subway</item>
///   </items>
/// </object>
/// ```
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// combobox
/// ╰── box.linked
///     ├── entry.combo
///     ├── button.combo
///     ╰── window.popup
/// ```
/// 
/// GtkComboBoxText has a single CSS node with name combobox. It adds
/// the style class .combo to the main CSS nodes of its entry and button
/// children, and the .linked class to the node of its internal box.
public struct ComboBoxTextRef: ComboBoxTextProtocol {
    /// Untyped pointer to the underlying `GtkComboBoxText` instance.
    /// For type-safe access, use the generated, typed pointer `combo_box_text_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension ComboBoxTextRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkComboBoxText>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `ComboBoxTextProtocol`
    init<T: ComboBoxTextProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkComboBoxText`, which is a `GtkComboBox` just displaying
    /// strings.
    init() {
        let rv = gtk_combo_box_text_new()
        self.init(cast(rv))
    }
    /// Creates a new `GtkComboBoxText`, which is a `GtkComboBox` just displaying
    /// strings. The combo box created by this function has an entry.
    static func comboBoxTextNewWithEntry() -> ComboBoxTextRef! {
        let rv = gtk_combo_box_text_new_with_entry()
        return rv.map { ComboBoxTextRef(cast($0)) }
    }
}

/// The `ComboBoxText` type acts as a reference-counted owner of an underlying `GtkComboBoxText` instance.
/// It provides the methods that can operate on this data type through `ComboBoxTextProtocol` conformance.
/// Use `ComboBoxText` as a strong reference or owner of a `GtkComboBoxText` instance.
///
/// A GtkComboBoxText is a simple variant of `GtkComboBox` that hides
/// the model-view complexity for simple text-only use cases.
/// 
/// To create a GtkComboBoxText, use `gtk_combo_box_text_new()` or
/// `gtk_combo_box_text_new_with_entry()`.
/// 
/// You can add items to a GtkComboBoxText with
/// `gtk_combo_box_text_append_text()`, `gtk_combo_box_text_insert_text()`
/// or `gtk_combo_box_text_prepend_text()` and remove options with
/// `gtk_combo_box_text_remove()`.
/// 
/// If the GtkComboBoxText contains an entry (via the “has-entry” property),
/// its contents can be retrieved using `gtk_combo_box_text_get_active_text()`.
/// The entry itself can be accessed by calling `gtk_bin_get_child()` on the
/// combo box.
/// 
/// You should not call `gtk_combo_box_set_model()` or attempt to pack more cells
/// into this combo box via its GtkCellLayout interface.
/// 
/// # GtkComboBoxText as GtkBuildable
/// 
/// The GtkComboBoxText implementation of the GtkBuildable interface supports
/// adding items directly using the <items> element and specifying <item>
/// elements for each item. Each <item> element can specify the “id”
/// corresponding to the appended text and also supports the regular
/// translation attributes “translatable”, “context” and “comments”.
/// 
/// Here is a UI definition fragment specifying GtkComboBoxText items:
/// ```
/// <object class="GtkComboBoxText">
///   <items>
///     <item translatable="yes" id="factory">Factory</item>
///     <item translatable="yes" id="home">Home</item>
///     <item translatable="yes" id="subway">Subway</item>
///   </items>
/// </object>
/// ```
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// combobox
/// ╰── box.linked
///     ├── entry.combo
///     ├── button.combo
///     ╰── window.popup
/// ```
/// 
/// GtkComboBoxText has a single CSS node with name combobox. It adds
/// the style class .combo to the main CSS nodes of its entry and button
/// children, and the .linked class to the node of its internal box.
open class ComboBoxText: ComboBox, ComboBoxTextProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `ComboBoxText` instance.
    public init(_ op: UnsafeMutablePointer<GtkComboBoxText>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `ComboBoxTextProtocol`
    /// Will retain `GtkComboBoxText`.
    public convenience init<T: ComboBoxTextProtocol>(_ other: T) {
        self.init(cast(other.combo_box_text_ptr))
        g_object_ref(cast(combo_box_text_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkComboBoxText.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkComboBoxText.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkComboBoxText.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkComboBoxText>(opaquePointer))
    }

    /// Creates a new `GtkComboBoxText`, which is a `GtkComboBox` just displaying
    /// strings.
    public convenience init() {
        let rv = gtk_combo_box_text_new()
        self.init(cast(rv))
    }

    /// Creates a new `GtkComboBoxText`, which is a `GtkComboBox` just displaying
    /// strings. The combo box created by this function has an entry.
    public static func comboBoxTextNewWithEntry() -> ComboBoxText! {
        let rv = gtk_combo_box_text_new_with_entry()
        return rv.map { ComboBoxText(cast($0)) }
    }

}

public enum ComboBoxTextPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    /// The item which is currently active. If the model is a non-flat treemodel,
    /// and the active item is not an immediate child of the root of the tree,
    /// this property has the value
    /// `gtk_tree_path_get_indices (path)[0]`,
    /// where `path` is the `GtkTreePath` of the active item.
    case active = "active"
    /// The value of the ID column of the active row.
    case activeID = "active-id"
    /// The add-tearoffs property controls whether generated menus
    /// have tearoff menu items.
    /// 
    /// Note that this only affects menu style combo boxes.
    ///
    /// **add-tearoffs is deprecated:**
    /// This method is deprecated.
    case addTearoffs = "add-tearoffs"
    case appPaintable = "app-paintable"
    case borderWidth = "border-width"
    /// Whether the dropdown button is sensitive when
    /// the model is empty.
    case buttonSensitivity = "button-sensitivity"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    /// The `GtkCellArea` used to layout cell renderers for this combo box.
    /// 
    /// If no area is specified when creating the combo box with `gtk_combo_box_new_with_area()`
    /// a horizontally oriented `GtkCellAreaBox` will be used.
    case cellArea = "cell-area"
    case child = "child"
    /// If this is set to a non-negative value, it must be the index of a column
    /// of type `G_TYPE_INT` in the model. The value in that column for each item
    /// will determine how many columns that item will span in the popup.
    /// Therefore, values in this column must be greater than zero, and the sum of
    /// an item’s column position + span should not exceed `GtkComboBox:wrap`-width.
    case columnSpanColumn = "column-span-column"
    case compositeChild = "composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    /// The column in the combo box's model to associate with strings from the entry
    /// if the combo was created with `GtkComboBox:has`-entry = `true`.
    case entryTextColumn = "entry-text-column"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    /// Whether the combo box has an entry.
    case hasEntry = "has-entry"
    case hasFocus = "has-focus"
    /// The has-frame property controls whether a frame
    /// is drawn around the entry.
    case hasFrame = "has-frame"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The column in the combo box's model that provides string
    /// IDs for the values in the model, if != -1.
    case idColumn = "id-column"
    case isFocus = "is-focus"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    /// The model from which the combo box takes the values shown
    /// in the list.
    case model = "model"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    /// Whether the popup's width should be a fixed width matching the
    /// allocated width of the combo box.
    case popupFixedWidth = "popup-fixed-width"
    /// Whether the combo boxes dropdown is popped up.
    /// Note that this property is mainly useful, because
    /// it allows you to connect to notify`popup`-shown.
    case popupShown = "popup-shown"
    case receivesDefault = "receives-default"
    case resizeMode = "resize-mode"
    /// If this is set to a non-negative value, it must be the index of a column
    /// of type `G_TYPE_INT` in the model. The value in that column for each item
    /// will determine how many rows that item will span in the popup. Therefore,
    /// values in this column must be greater than zero.
    case rowSpanColumn = "row-span-column"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    /// A title that may be displayed by the window manager
    /// when the popup is torn-off.
    ///
    /// **tearoff-title is deprecated:**
    /// This method is deprecated.
    case tearoffTitle = "tearoff-title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
    /// If wrap-width is set to a positive value, items in the popup will be laid
    /// out along multiple columns, starting a new row on reaching the wrap width.
    case wrapWidth = "wrap-width"
}

public extension ComboBoxTextProtocol {
    /// Bind a `ComboBoxTextPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ComboBoxTextPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(combo_box_text_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum ComboBoxTextSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    case add = "add"
    /// The `button`-press-event signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button`-release-event signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    /// The changed signal is emitted when the active
    /// item is changed. The can be due to the user selecting
    /// a different item from the list, or due to a
    /// call to `gtk_combo_box_set_active_iter()`.
    /// It will also be emitted while typing into the entry of a combo box
    /// with an entry.
    case changed = "changed"
    case checkResize = "check-resize"
    /// The `child`-notify signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The `composited`-changed signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure`-event signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete`-event signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy`-event signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag`-begin signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag`-data-delete signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag`-data-get signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag`-data-received signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag`-drop signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag`-drop signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag`-data-received handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag`-end signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag`-begin.
    case dragEnd = "drag-end"
    /// The `drag`-failed signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag`-leave signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag`-motion, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag`-leave signal is also emitted before the
    /// `drag`-drop signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag`-motion signal handler.
    case dragLeave = "drag-leave"
    /// The `drag`-motion signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag`-data-received
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag`-leave and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enter`-notify-event will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key`-press-event) and finally a generic
    /// `GtkWidget::event`-after signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event`-after will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `focus`-in-event signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus`-out-event signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// For combo boxes that are created with an entry (See GtkComboBox:has-entry).
    /// 
    /// A signal which allows you to change how the text displayed in a combo box's
    /// entry is displayed.
    /// 
    /// Connect a signal handler which returns an allocated string representing
    /// `path`. That string will then be used to set the text in the combo box's entry.
    /// The default signal handler uses the text from the GtkComboBox`entry`-text-column
    /// model column.
    /// 
    /// Here's an example signal handler which fetches data from the model and
    /// displays it in the entry.
    /// (C Language Example):
    /// ```C
    /// static gchar*
    /// format_entry_text_callback (GtkComboBox *combo,
    ///                             const gchar *path,
    ///                             gpointer     user_data)
    /// {
    ///   GtkTreeIter iter;
    ///   GtkTreeModel model;
    ///   gdouble      value;
    /// 
    ///   model = gtk_combo_box_get_model (combo);
    /// 
    ///   gtk_tree_model_get_iter_from_string (model, &iter, path);
    ///   gtk_tree_model_get (model, &iter,
    ///                       THE_DOUBLE_VALUE_COLUMN, &value,
    ///                       -1);
    /// 
    ///   return g_strdup_printf ("%g", value);
    /// }
    /// ```
    /// 
    case formatEntryText = "format-entry-text"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab`-notify signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy`-changed signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key`-press-event signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key`-release-event signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `leave`-notify-event will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map`-event will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map`-event signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion`-notify-event signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    /// The `move`-active signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to move the active selection.
    case moveActive = "move-active"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent`-set signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// The `popdown` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to popdown the combo box list.
    /// 
    /// The default bindings for this signal are Alt+Up and Escape.
    case popdown = "popdown"
    /// The `popup` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to popup the combo box list.
    /// 
    /// The default binding for this signal is Alt+Down.
    case popup = "popup"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The `property`-notify-event signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// The `screen`-changed signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll`-event signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `selection`-clear-event signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection`-request-event signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-changed signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style`-set signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style`-updated signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style`-updated signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap`-event signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility`-notify-event will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    /// The `window`-state-event will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    /// The item which is currently active. If the model is a non-flat treemodel,
    /// and the active item is not an immediate child of the root of the tree,
    /// this property has the value
    /// `gtk_tree_path_get_indices (path)[0]`,
    /// where `path` is the `GtkTreePath` of the active item.
    case notifyActive = "notify::active"
    /// The value of the ID column of the active row.
    case notifyActiveID = "notify::active-id"
    /// The add-tearoffs property controls whether generated menus
    /// have tearoff menu items.
    /// 
    /// Note that this only affects menu style combo boxes.
    ///
    /// **add-tearoffs is deprecated:**
    /// This method is deprecated.
    case notifyAddTearoffs = "notify::add-tearoffs"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBorderWidth = "notify::border-width"
    /// Whether the dropdown button is sensitive when
    /// the model is empty.
    case notifyButtonSensitivity = "notify::button-sensitivity"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    /// The `GtkCellArea` used to layout cell renderers for this combo box.
    /// 
    /// If no area is specified when creating the combo box with `gtk_combo_box_new_with_area()`
    /// a horizontally oriented `GtkCellAreaBox` will be used.
    case notifyCellArea = "notify::cell-area"
    case notifyChild = "notify::child"
    /// If this is set to a non-negative value, it must be the index of a column
    /// of type `G_TYPE_INT` in the model. The value in that column for each item
    /// will determine how many columns that item will span in the popup.
    /// Therefore, values in this column must be greater than zero, and the sum of
    /// an item’s column position + span should not exceed `GtkComboBox:wrap`-width.
    case notifyColumnSpanColumn = "notify::column-span-column"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    /// The column in the combo box's model to associate with strings from the entry
    /// if the combo was created with `GtkComboBox:has`-entry = `true`.
    case notifyEntryTextColumn = "notify::entry-text-column"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    /// Whether the combo box has an entry.
    case notifyHasEntry = "notify::has-entry"
    case notifyHasFocus = "notify::has-focus"
    /// The has-frame property controls whether a frame
    /// is drawn around the entry.
    case notifyHasFrame = "notify::has-frame"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The column in the combo box's model that provides string
    /// IDs for the values in the model, if != -1.
    case notifyIDColumn = "notify::id-column"
    case notifyIsFocus = "notify::is-focus"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    /// The model from which the combo box takes the values shown
    /// in the list.
    case notifyModel = "notify::model"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    /// Whether the popup's width should be a fixed width matching the
    /// allocated width of the combo box.
    case notifyPopupFixedWidth = "notify::popup-fixed-width"
    /// Whether the combo boxes dropdown is popped up.
    /// Note that this property is mainly useful, because
    /// it allows you to connect to notify`popup`-shown.
    case notifyPopupShown = "notify::popup-shown"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizeMode = "notify::resize-mode"
    /// If this is set to a non-negative value, it must be the index of a column
    /// of type `G_TYPE_INT` in the model. The value in that column for each item
    /// will determine how many rows that item will span in the popup. Therefore,
    /// values in this column must be greater than zero.
    case notifyRowSpanColumn = "notify::row-span-column"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    /// A title that may be displayed by the window manager
    /// when the popup is torn-off.
    ///
    /// **tearoff-title is deprecated:**
    /// This method is deprecated.
    case notifyTearoffTitle = "notify::tearoff-title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
    /// If wrap-width is set to a positive value, items in the popup will be laid
    /// out along multiple columns, starting a new row on reaching the wrap width.
    case notifyWrapWidth = "notify::wrap-width"
}

public extension ComboBoxTextProtocol {
    /// Connect a `ComboBoxTextSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: ComboBoxTextSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(combo_box_text_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension ComboBoxTextProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkComboBoxText` instance.
    var combo_box_text_ptr: UnsafeMutablePointer<GtkComboBoxText> { return ptr.assumingMemoryBound(to: GtkComboBoxText.self) }

    /// Appends `text` to the list of strings stored in `combo_box`.
    /// If `id` is non-`nil` then it is used as the ID of the row.
    /// 
    /// This is the same as calling `gtk_combo_box_text_insert()` with a
    /// position of -1.
    func append(id: UnsafePointer<gchar>, text: UnsafePointer<gchar>) {
        gtk_combo_box_text_append(cast(combo_box_text_ptr), id, text)
    
    }

    /// Appends `text` to the list of strings stored in `combo_box`.
    /// 
    /// This is the same as calling `gtk_combo_box_text_insert_text()` with a
    /// position of -1.
    func append(text: UnsafePointer<gchar>) {
        gtk_combo_box_text_append_text(cast(combo_box_text_ptr), text)
    
    }

    /// Returns the currently active string in `combo_box`, or `nil`
    /// if none is selected. If `combo_box` contains an entry, this
    /// function will return its contents (which will not necessarily
    /// be an item from the list).
    func getActiveText() -> String! {
        let rv = gtk_combo_box_text_get_active_text(cast(combo_box_text_ptr))
        return rv.map { String(cString: UnsafePointer<CChar>($0)) }
    }

    /// Inserts `text` at `position` in the list of strings stored in `combo_box`.
    /// If `id` is non-`nil` then it is used as the ID of the row.  See
    /// `GtkComboBox:id`-column.
    /// 
    /// If `position` is negative then `text` is appended.
    func insert(position: CInt, id: UnsafePointer<gchar>, text: UnsafePointer<gchar>) {
        gtk_combo_box_text_insert(cast(combo_box_text_ptr), gint(position), id, text)
    
    }

    /// Inserts `text` at `position` in the list of strings stored in `combo_box`.
    /// 
    /// If `position` is negative then `text` is appended.
    /// 
    /// This is the same as calling `gtk_combo_box_text_insert()` with a `nil`
    /// ID string.
    func insertText(position: CInt, text: UnsafePointer<gchar>) {
        gtk_combo_box_text_insert_text(cast(combo_box_text_ptr), gint(position), text)
    
    }

    /// Prepends `text` to the list of strings stored in `combo_box`.
    /// If `id` is non-`nil` then it is used as the ID of the row.
    /// 
    /// This is the same as calling `gtk_combo_box_text_insert()` with a
    /// position of 0.
    func prepend(id: UnsafePointer<gchar>, text: UnsafePointer<gchar>) {
        gtk_combo_box_text_prepend(cast(combo_box_text_ptr), id, text)
    
    }

    /// Prepends `text` to the list of strings stored in `combo_box`.
    /// 
    /// This is the same as calling `gtk_combo_box_text_insert_text()` with a
    /// position of 0.
    func prepend(text: UnsafePointer<gchar>) {
        gtk_combo_box_text_prepend_text(cast(combo_box_text_ptr), text)
    
    }

    /// Removes the string at `position` from `combo_box`.
    func remove(position: CInt) {
        gtk_combo_box_text_remove(cast(combo_box_text_ptr), gint(position))
    
    }

    /// Removes all the text entries from the combo box.
    func removeAll() {
        gtk_combo_box_text_remove_all(cast(combo_box_text_ptr))
    
    }
    /// Returns the currently active string in `combo_box`, or `nil`
    /// if none is selected. If `combo_box` contains an entry, this
    /// function will return its contents (which will not necessarily
    /// be an item from the list).
    var activeText: String! {
        /// Returns the currently active string in `combo_box`, or `nil`
        /// if none is selected. If `combo_box` contains an entry, this
        /// function will return its contents (which will not necessarily
        /// be an item from the list).
        get {
            let rv = gtk_combo_box_text_get_active_text(cast(combo_box_text_ptr))
            return rv.map { String(cString: UnsafePointer<CChar>($0)) }
        }
    }
}



// MARK: - Container Class

/// The `ContainerProtocol` protocol exposes the methods and properties of an underlying `GtkContainer` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Container`.
/// Alternatively, use `ContainerRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A GTK+ user interface is constructed by nesting widgets inside widgets.
/// Container widgets are the inner nodes in the resulting tree of widgets:
/// they contain other widgets. So, for example, you might have a `GtkWindow`
/// containing a `GtkFrame` containing a `GtkLabel`. If you wanted an image instead
/// of a textual label inside the frame, you might replace the `GtkLabel` widget
/// with a `GtkImage` widget.
/// 
/// There are two major kinds of container widgets in GTK+. Both are subclasses
/// of the abstract GtkContainer base class.
/// 
/// The first type of container widget has a single child widget and derives
/// from `GtkBin`. These containers are decorators, which
/// add some kind of functionality to the child. For example, a `GtkButton` makes
/// its child into a clickable button; a `GtkFrame` draws a frame around its child
/// and a `GtkWindow` places its child widget inside a top-level window.
/// 
/// The second type of container can have more than one child; its purpose is to
/// manage layout. This means that these containers assign
/// sizes and positions to their children. For example, a `GtkHBox` arranges its
/// children in a horizontal row, and a `GtkGrid` arranges the widgets it contains
/// in a two-dimensional grid.
/// 
/// For implementations of `GtkContainer` the virtual method `GtkContainerClass.forall``()`
/// is always required, since it's used for drawing and other internal operations
/// on the children.
/// If the `GtkContainer` implementation expect to have non internal children
/// it's needed to implement both `GtkContainerClass.add``()` and `GtkContainerClass.remove``()`.
/// If the GtkContainer implementation has internal children, they should be added
/// with `gtk_widget_set_parent()` on `init()` and removed with `gtk_widget_unparent()`
/// in the `GtkWidgetClass.destroy``()` implementation.
/// See more about implementing custom widgets at https://wiki.gnome.org/HowDoI/CustomWidgets
/// 
/// # Height for width geometry management
/// 
/// GTK+ uses a height-for-width (and width-for-height) geometry management system.
/// Height-for-width means that a widget can change how much vertical space it needs,
/// depending on the amount of horizontal space that it is given (and similar for
/// width-for-height).
/// 
/// There are some things to keep in mind when implementing container widgets
/// that make use of GTK+’s height for width geometry management system. First,
/// it’s important to note that a container must prioritize one of its
/// dimensions, that is to say that a widget or container can only have a
/// `GtkSizeRequestMode` that is `GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH` or
/// `GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT`. However, every widget and container
/// must be able to respond to the APIs for both dimensions, i.e. even if a
/// widget has a request mode that is height-for-width, it is possible that
/// its parent will request its sizes using the width-for-height APIs.
/// 
/// To ensure that everything works properly, here are some guidelines to follow
/// when implementing height-for-width (or width-for-height) containers.
/// 
/// Each request mode involves 2 virtual methods. Height-for-width apis run
/// through `gtk_widget_get_preferred_width()` and then through `gtk_widget_get_preferred_height_for_width()`.
/// When handling requests in the opposite `GtkSizeRequestMode` it is important that
/// every widget request at least enough space to display all of its content at all times.
/// 
/// When `gtk_widget_get_preferred_height()` is called on a container that is height-for-width,
/// the container must return the height for its minimum width. This is easily achieved by
/// simply calling the reverse apis implemented for itself as follows:
/// 
/// (C Language Example):
/// ```C
/// static void
/// foo_container_get_preferred_height (GtkWidget *widget,
///                                     gint *min_height,
///                                     gint *nat_height)
/// {
///    if (i_am_in_height_for_width_mode)
///      {
///        gint min_width;
/// 
///        GTK_WIDGET_GET_CLASS (widget)->get_preferred_width (widget,
///                                                            &min_width,
///                                                            NULL);
///        GTK_WIDGET_GET_CLASS (widget)->get_preferred_height_for_width
///                                                           (widget,
///                                                            min_width,
///                                                            min_height,
///                                                            nat_height);
///      }
///    else
///      {
///        ... many containers support both request modes, execute the
///        real width-for-height request here by returning the
///        collective heights of all widgets that are stacked
///        vertically (or whatever is appropriate for this container)
///        ...
///      }
/// }
/// ```
/// 
/// Similarly, when `gtk_widget_get_preferred_width_for_height()` is called for a container or widget
/// that is height-for-width, it then only needs to return the base minimum width like so:
/// 
/// (C Language Example):
/// ```C
/// static void
/// foo_container_get_preferred_width_for_height (GtkWidget *widget,
///                                               gint for_height,
///                                               gint *min_width,
///                                               gint *nat_width)
/// {
///    if (i_am_in_height_for_width_mode)
///      {
///        GTK_WIDGET_GET_CLASS (widget)->get_preferred_width (widget,
///                                                            min_width,
///                                                            nat_width);
///      }
///    else
///      {
///        ... execute the real width-for-height request here based on
///        the required width of the children collectively if the
///        container were to be allocated the said height ...
///      }
/// }
/// ```
/// 
/// Height for width requests are generally implemented in terms of a virtual allocation
/// of widgets in the input orientation. Assuming an height-for-width request mode, a container
/// would implement the `get_preferred_height_for_width()` virtual function by first calling
/// `gtk_widget_get_preferred_width()` for each of its children.
/// 
/// For each potential group of children that are lined up horizontally, the values returned by
/// `gtk_widget_get_preferred_width()` should be collected in an array of `GtkRequestedSize` structures.
/// Any child spacing should be removed from the input `for_width` and then the collective size should be
/// allocated using the `gtk_distribute_natural_allocation()` convenience function.
/// 
/// The container will then move on to request the preferred height for each child by using
/// `gtk_widget_get_preferred_height_for_width()` and using the sizes stored in the `GtkRequestedSize` array.
/// 
/// To allocate a height-for-width container, it’s again important
/// to consider that a container must prioritize one dimension over the other. So if
/// a container is a height-for-width container it must first allocate all widgets horizontally
/// using a `GtkRequestedSize` array and `gtk_distribute_natural_allocation()` and then add any
/// extra space (if and where appropriate) for the widget to expand.
/// 
/// After adding all the expand space, the container assumes it was allocated sufficient
/// height to fit all of its content. At this time, the container must use the total horizontal sizes
/// of each widget to request the height-for-width of each of its children and store the requests in a
/// `GtkRequestedSize` array for any widgets that stack vertically (for tabular containers this can
/// be generalized into the heights and widths of rows and columns).
/// The vertical space must then again be distributed using `gtk_distribute_natural_allocation()`
/// while this time considering the allocated height of the widget minus any vertical spacing
/// that the container adds. Then vertical expand space should be added where appropriate and available
/// and the container should go on to actually allocating the child widgets.
/// 
/// See [GtkWidget’s geometry management section](#geometry-management)
/// to learn more about implementing height-for-width geometry management for widgets.
/// 
/// # Child properties
/// 
/// GtkContainer introduces child properties.
/// These are object properties that are not specific
/// to either the container or the contained widget, but rather to their relation.
/// Typical examples of child properties are the position or pack-type of a widget
/// which is contained in a `GtkBox`.
/// 
/// Use `gtk_container_class_install_child_property()` to install child properties
/// for a container class and `gtk_container_class_find_child_property()` or
/// `gtk_container_class_list_child_properties()` to get information about existing
/// child properties.
/// 
/// To set the value of a child property, use `gtk_container_child_set_property()`,
/// `gtk_container_child_set()` or `gtk_container_child_set_valist()`.
/// To obtain the value of a child property, use
/// `gtk_container_child_get_property()`, `gtk_container_child_get()` or
/// `gtk_container_child_get_valist()`. To emit notification about child property
/// changes, use `gtk_widget_child_notify()`.
/// 
/// # GtkContainer as GtkBuildable
/// 
/// The GtkContainer implementation of the GtkBuildable interface supports
/// a <packing> element for children, which can contain multiple <property>
/// elements that specify child properties for the child.
/// 
/// Since 2.16, child properties can also be marked as translatable using
/// the same “translatable”, “comments” and “context” attributes that are used
/// for regular properties.
/// 
/// Since 3.16, containers can have a <focus-chain> element containing multiple
/// <widget> elements, one for each child that should be added to the focus
/// chain. The ”name” attribute gives the id of the widget.
/// 
/// An example of these properties in UI definitions:
/// ```
/// <object class="GtkBox">
///   <child>
///     <object class="GtkEntry" id="entry1"/>
///     <packing>
///       <property name="pack-type">start</property>
///     </packing>
///   </child>
///   <child>
///     <object class="GtkEntry" id="entry2"/>
///   </child>
///   <focus-chain>
///     <widget name="entry1"/>
///     <widget name="entry2"/>
///   </focus-chain>
/// </object>
/// ```
/// 
public protocol ContainerProtocol: WidgetProtocol {
    /// Untyped pointer to the underlying `GtkContainer` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkContainer` instance.
    var container_ptr: UnsafeMutablePointer<GtkContainer> { get }
}

/// The `ContainerRef` type acts as a lightweight Swift reference to an underlying `GtkContainer` instance.
/// It exposes methods that can operate on this data type through `ContainerProtocol` conformance.
/// Use `ContainerRef` only as an `unowned` reference to an existing `GtkContainer` instance.
///
/// A GTK+ user interface is constructed by nesting widgets inside widgets.
/// Container widgets are the inner nodes in the resulting tree of widgets:
/// they contain other widgets. So, for example, you might have a `GtkWindow`
/// containing a `GtkFrame` containing a `GtkLabel`. If you wanted an image instead
/// of a textual label inside the frame, you might replace the `GtkLabel` widget
/// with a `GtkImage` widget.
/// 
/// There are two major kinds of container widgets in GTK+. Both are subclasses
/// of the abstract GtkContainer base class.
/// 
/// The first type of container widget has a single child widget and derives
/// from `GtkBin`. These containers are decorators, which
/// add some kind of functionality to the child. For example, a `GtkButton` makes
/// its child into a clickable button; a `GtkFrame` draws a frame around its child
/// and a `GtkWindow` places its child widget inside a top-level window.
/// 
/// The second type of container can have more than one child; its purpose is to
/// manage layout. This means that these containers assign
/// sizes and positions to their children. For example, a `GtkHBox` arranges its
/// children in a horizontal row, and a `GtkGrid` arranges the widgets it contains
/// in a two-dimensional grid.
/// 
/// For implementations of `GtkContainer` the virtual method `GtkContainerClass.forall``()`
/// is always required, since it's used for drawing and other internal operations
/// on the children.
/// If the `GtkContainer` implementation expect to have non internal children
/// it's needed to implement both `GtkContainerClass.add``()` and `GtkContainerClass.remove``()`.
/// If the GtkContainer implementation has internal children, they should be added
/// with `gtk_widget_set_parent()` on `init()` and removed with `gtk_widget_unparent()`
/// in the `GtkWidgetClass.destroy``()` implementation.
/// See more about implementing custom widgets at https://wiki.gnome.org/HowDoI/CustomWidgets
/// 
/// # Height for width geometry management
/// 
/// GTK+ uses a height-for-width (and width-for-height) geometry management system.
/// Height-for-width means that a widget can change how much vertical space it needs,
/// depending on the amount of horizontal space that it is given (and similar for
/// width-for-height).
/// 
/// There are some things to keep in mind when implementing container widgets
/// that make use of GTK+’s height for width geometry management system. First,
/// it’s important to note that a container must prioritize one of its
/// dimensions, that is to say that a widget or container can only have a
/// `GtkSizeRequestMode` that is `GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH` or
/// `GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT`. However, every widget and container
/// must be able to respond to the APIs for both dimensions, i.e. even if a
/// widget has a request mode that is height-for-width, it is possible that
/// its parent will request its sizes using the width-for-height APIs.
/// 
/// To ensure that everything works properly, here are some guidelines to follow
/// when implementing height-for-width (or width-for-height) containers.
/// 
/// Each request mode involves 2 virtual methods. Height-for-width apis run
/// through `gtk_widget_get_preferred_width()` and then through `gtk_widget_get_preferred_height_for_width()`.
/// When handling requests in the opposite `GtkSizeRequestMode` it is important that
/// every widget request at least enough space to display all of its content at all times.
/// 
/// When `gtk_widget_get_preferred_height()` is called on a container that is height-for-width,
/// the container must return the height for its minimum width. This is easily achieved by
/// simply calling the reverse apis implemented for itself as follows:
/// 
/// (C Language Example):
/// ```C
/// static void
/// foo_container_get_preferred_height (GtkWidget *widget,
///                                     gint *min_height,
///                                     gint *nat_height)
/// {
///    if (i_am_in_height_for_width_mode)
///      {
///        gint min_width;
/// 
///        GTK_WIDGET_GET_CLASS (widget)->get_preferred_width (widget,
///                                                            &min_width,
///                                                            NULL);
///        GTK_WIDGET_GET_CLASS (widget)->get_preferred_height_for_width
///                                                           (widget,
///                                                            min_width,
///                                                            min_height,
///                                                            nat_height);
///      }
///    else
///      {
///        ... many containers support both request modes, execute the
///        real width-for-height request here by returning the
///        collective heights of all widgets that are stacked
///        vertically (or whatever is appropriate for this container)
///        ...
///      }
/// }
/// ```
/// 
/// Similarly, when `gtk_widget_get_preferred_width_for_height()` is called for a container or widget
/// that is height-for-width, it then only needs to return the base minimum width like so:
/// 
/// (C Language Example):
/// ```C
/// static void
/// foo_container_get_preferred_width_for_height (GtkWidget *widget,
///                                               gint for_height,
///                                               gint *min_width,
///                                               gint *nat_width)
/// {
///    if (i_am_in_height_for_width_mode)
///      {
///        GTK_WIDGET_GET_CLASS (widget)->get_preferred_width (widget,
///                                                            min_width,
///                                                            nat_width);
///      }
///    else
///      {
///        ... execute the real width-for-height request here based on
///        the required width of the children collectively if the
///        container were to be allocated the said height ...
///      }
/// }
/// ```
/// 
/// Height for width requests are generally implemented in terms of a virtual allocation
/// of widgets in the input orientation. Assuming an height-for-width request mode, a container
/// would implement the `get_preferred_height_for_width()` virtual function by first calling
/// `gtk_widget_get_preferred_width()` for each of its children.
/// 
/// For each potential group of children that are lined up horizontally, the values returned by
/// `gtk_widget_get_preferred_width()` should be collected in an array of `GtkRequestedSize` structures.
/// Any child spacing should be removed from the input `for_width` and then the collective size should be
/// allocated using the `gtk_distribute_natural_allocation()` convenience function.
/// 
/// The container will then move on to request the preferred height for each child by using
/// `gtk_widget_get_preferred_height_for_width()` and using the sizes stored in the `GtkRequestedSize` array.
/// 
/// To allocate a height-for-width container, it’s again important
/// to consider that a container must prioritize one dimension over the other. So if
/// a container is a height-for-width container it must first allocate all widgets horizontally
/// using a `GtkRequestedSize` array and `gtk_distribute_natural_allocation()` and then add any
/// extra space (if and where appropriate) for the widget to expand.
/// 
/// After adding all the expand space, the container assumes it was allocated sufficient
/// height to fit all of its content. At this time, the container must use the total horizontal sizes
/// of each widget to request the height-for-width of each of its children and store the requests in a
/// `GtkRequestedSize` array for any widgets that stack vertically (for tabular containers this can
/// be generalized into the heights and widths of rows and columns).
/// The vertical space must then again be distributed using `gtk_distribute_natural_allocation()`
/// while this time considering the allocated height of the widget minus any vertical spacing
/// that the container adds. Then vertical expand space should be added where appropriate and available
/// and the container should go on to actually allocating the child widgets.
/// 
/// See [GtkWidget’s geometry management section](#geometry-management)
/// to learn more about implementing height-for-width geometry management for widgets.
/// 
/// # Child properties
/// 
/// GtkContainer introduces child properties.
/// These are object properties that are not specific
/// to either the container or the contained widget, but rather to their relation.
/// Typical examples of child properties are the position or pack-type of a widget
/// which is contained in a `GtkBox`.
/// 
/// Use `gtk_container_class_install_child_property()` to install child properties
/// for a container class and `gtk_container_class_find_child_property()` or
/// `gtk_container_class_list_child_properties()` to get information about existing
/// child properties.
/// 
/// To set the value of a child property, use `gtk_container_child_set_property()`,
/// `gtk_container_child_set()` or `gtk_container_child_set_valist()`.
/// To obtain the value of a child property, use
/// `gtk_container_child_get_property()`, `gtk_container_child_get()` or
/// `gtk_container_child_get_valist()`. To emit notification about child property
/// changes, use `gtk_widget_child_notify()`.
/// 
/// # GtkContainer as GtkBuildable
/// 
/// The GtkContainer implementation of the GtkBuildable interface supports
/// a <packing> element for children, which can contain multiple <property>
/// elements that specify child properties for the child.
/// 
/// Since 2.16, child properties can also be marked as translatable using
/// the same “translatable”, “comments” and “context” attributes that are used
/// for regular properties.
/// 
/// Since 3.16, containers can have a <focus-chain> element containing multiple
/// <widget> elements, one for each child that should be added to the focus
/// chain. The ”name” attribute gives the id of the widget.
/// 
/// An example of these properties in UI definitions:
/// ```
/// <object class="GtkBox">
///   <child>
///     <object class="GtkEntry" id="entry1"/>
///     <packing>
///       <property name="pack-type">start</property>
///     </packing>
///   </child>
///   <child>
///     <object class="GtkEntry" id="entry2"/>
///   </child>
///   <focus-chain>
///     <widget name="entry1"/>
///     <widget name="entry2"/>
///   </focus-chain>
/// </object>
/// ```
/// 
public struct ContainerRef: ContainerProtocol {
    /// Untyped pointer to the underlying `GtkContainer` instance.
    /// For type-safe access, use the generated, typed pointer `container_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension ContainerRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkContainer>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `ContainerProtocol`
    init<T: ContainerProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `Container` type acts as a reference-counted owner of an underlying `GtkContainer` instance.
/// It provides the methods that can operate on this data type through `ContainerProtocol` conformance.
/// Use `Container` as a strong reference or owner of a `GtkContainer` instance.
///
/// A GTK+ user interface is constructed by nesting widgets inside widgets.
/// Container widgets are the inner nodes in the resulting tree of widgets:
/// they contain other widgets. So, for example, you might have a `GtkWindow`
/// containing a `GtkFrame` containing a `GtkLabel`. If you wanted an image instead
/// of a textual label inside the frame, you might replace the `GtkLabel` widget
/// with a `GtkImage` widget.
/// 
/// There are two major kinds of container widgets in GTK+. Both are subclasses
/// of the abstract GtkContainer base class.
/// 
/// The first type of container widget has a single child widget and derives
/// from `GtkBin`. These containers are decorators, which
/// add some kind of functionality to the child. For example, a `GtkButton` makes
/// its child into a clickable button; a `GtkFrame` draws a frame around its child
/// and a `GtkWindow` places its child widget inside a top-level window.
/// 
/// The second type of container can have more than one child; its purpose is to
/// manage layout. This means that these containers assign
/// sizes and positions to their children. For example, a `GtkHBox` arranges its
/// children in a horizontal row, and a `GtkGrid` arranges the widgets it contains
/// in a two-dimensional grid.
/// 
/// For implementations of `GtkContainer` the virtual method `GtkContainerClass.forall``()`
/// is always required, since it's used for drawing and other internal operations
/// on the children.
/// If the `GtkContainer` implementation expect to have non internal children
/// it's needed to implement both `GtkContainerClass.add``()` and `GtkContainerClass.remove``()`.
/// If the GtkContainer implementation has internal children, they should be added
/// with `gtk_widget_set_parent()` on `init()` and removed with `gtk_widget_unparent()`
/// in the `GtkWidgetClass.destroy``()` implementation.
/// See more about implementing custom widgets at https://wiki.gnome.org/HowDoI/CustomWidgets
/// 
/// # Height for width geometry management
/// 
/// GTK+ uses a height-for-width (and width-for-height) geometry management system.
/// Height-for-width means that a widget can change how much vertical space it needs,
/// depending on the amount of horizontal space that it is given (and similar for
/// width-for-height).
/// 
/// There are some things to keep in mind when implementing container widgets
/// that make use of GTK+’s height for width geometry management system. First,
/// it’s important to note that a container must prioritize one of its
/// dimensions, that is to say that a widget or container can only have a
/// `GtkSizeRequestMode` that is `GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH` or
/// `GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT`. However, every widget and container
/// must be able to respond to the APIs for both dimensions, i.e. even if a
/// widget has a request mode that is height-for-width, it is possible that
/// its parent will request its sizes using the width-for-height APIs.
/// 
/// To ensure that everything works properly, here are some guidelines to follow
/// when implementing height-for-width (or width-for-height) containers.
/// 
/// Each request mode involves 2 virtual methods. Height-for-width apis run
/// through `gtk_widget_get_preferred_width()` and then through `gtk_widget_get_preferred_height_for_width()`.
/// When handling requests in the opposite `GtkSizeRequestMode` it is important that
/// every widget request at least enough space to display all of its content at all times.
/// 
/// When `gtk_widget_get_preferred_height()` is called on a container that is height-for-width,
/// the container must return the height for its minimum width. This is easily achieved by
/// simply calling the reverse apis implemented for itself as follows:
/// 
/// (C Language Example):
/// ```C
/// static void
/// foo_container_get_preferred_height (GtkWidget *widget,
///                                     gint *min_height,
///                                     gint *nat_height)
/// {
///    if (i_am_in_height_for_width_mode)
///      {
///        gint min_width;
/// 
///        GTK_WIDGET_GET_CLASS (widget)->get_preferred_width (widget,
///                                                            &min_width,
///                                                            NULL);
///        GTK_WIDGET_GET_CLASS (widget)->get_preferred_height_for_width
///                                                           (widget,
///                                                            min_width,
///                                                            min_height,
///                                                            nat_height);
///      }
///    else
///      {
///        ... many containers support both request modes, execute the
///        real width-for-height request here by returning the
///        collective heights of all widgets that are stacked
///        vertically (or whatever is appropriate for this container)
///        ...
///      }
/// }
/// ```
/// 
/// Similarly, when `gtk_widget_get_preferred_width_for_height()` is called for a container or widget
/// that is height-for-width, it then only needs to return the base minimum width like so:
/// 
/// (C Language Example):
/// ```C
/// static void
/// foo_container_get_preferred_width_for_height (GtkWidget *widget,
///                                               gint for_height,
///                                               gint *min_width,
///                                               gint *nat_width)
/// {
///    if (i_am_in_height_for_width_mode)
///      {
///        GTK_WIDGET_GET_CLASS (widget)->get_preferred_width (widget,
///                                                            min_width,
///                                                            nat_width);
///      }
///    else
///      {
///        ... execute the real width-for-height request here based on
///        the required width of the children collectively if the
///        container were to be allocated the said height ...
///      }
/// }
/// ```
/// 
/// Height for width requests are generally implemented in terms of a virtual allocation
/// of widgets in the input orientation. Assuming an height-for-width request mode, a container
/// would implement the `get_preferred_height_for_width()` virtual function by first calling
/// `gtk_widget_get_preferred_width()` for each of its children.
/// 
/// For each potential group of children that are lined up horizontally, the values returned by
/// `gtk_widget_get_preferred_width()` should be collected in an array of `GtkRequestedSize` structures.
/// Any child spacing should be removed from the input `for_width` and then the collective size should be
/// allocated using the `gtk_distribute_natural_allocation()` convenience function.
/// 
/// The container will then move on to request the preferred height for each child by using
/// `gtk_widget_get_preferred_height_for_width()` and using the sizes stored in the `GtkRequestedSize` array.
/// 
/// To allocate a height-for-width container, it’s again important
/// to consider that a container must prioritize one dimension over the other. So if
/// a container is a height-for-width container it must first allocate all widgets horizontally
/// using a `GtkRequestedSize` array and `gtk_distribute_natural_allocation()` and then add any
/// extra space (if and where appropriate) for the widget to expand.
/// 
/// After adding all the expand space, the container assumes it was allocated sufficient
/// height to fit all of its content. At this time, the container must use the total horizontal sizes
/// of each widget to request the height-for-width of each of its children and store the requests in a
/// `GtkRequestedSize` array for any widgets that stack vertically (for tabular containers this can
/// be generalized into the heights and widths of rows and columns).
/// The vertical space must then again be distributed using `gtk_distribute_natural_allocation()`
/// while this time considering the allocated height of the widget minus any vertical spacing
/// that the container adds. Then vertical expand space should be added where appropriate and available
/// and the container should go on to actually allocating the child widgets.
/// 
/// See [GtkWidget’s geometry management section](#geometry-management)
/// to learn more about implementing height-for-width geometry management for widgets.
/// 
/// # Child properties
/// 
/// GtkContainer introduces child properties.
/// These are object properties that are not specific
/// to either the container or the contained widget, but rather to their relation.
/// Typical examples of child properties are the position or pack-type of a widget
/// which is contained in a `GtkBox`.
/// 
/// Use `gtk_container_class_install_child_property()` to install child properties
/// for a container class and `gtk_container_class_find_child_property()` or
/// `gtk_container_class_list_child_properties()` to get information about existing
/// child properties.
/// 
/// To set the value of a child property, use `gtk_container_child_set_property()`,
/// `gtk_container_child_set()` or `gtk_container_child_set_valist()`.
/// To obtain the value of a child property, use
/// `gtk_container_child_get_property()`, `gtk_container_child_get()` or
/// `gtk_container_child_get_valist()`. To emit notification about child property
/// changes, use `gtk_widget_child_notify()`.
/// 
/// # GtkContainer as GtkBuildable
/// 
/// The GtkContainer implementation of the GtkBuildable interface supports
/// a <packing> element for children, which can contain multiple <property>
/// elements that specify child properties for the child.
/// 
/// Since 2.16, child properties can also be marked as translatable using
/// the same “translatable”, “comments” and “context” attributes that are used
/// for regular properties.
/// 
/// Since 3.16, containers can have a <focus-chain> element containing multiple
/// <widget> elements, one for each child that should be added to the focus
/// chain. The ”name” attribute gives the id of the widget.
/// 
/// An example of these properties in UI definitions:
/// ```
/// <object class="GtkBox">
///   <child>
///     <object class="GtkEntry" id="entry1"/>
///     <packing>
///       <property name="pack-type">start</property>
///     </packing>
///   </child>
///   <child>
///     <object class="GtkEntry" id="entry2"/>
///   </child>
///   <focus-chain>
///     <widget name="entry1"/>
///     <widget name="entry2"/>
///   </focus-chain>
/// </object>
/// ```
/// 
open class Container: Widget, ContainerProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `Container` instance.
    public init(_ op: UnsafeMutablePointer<GtkContainer>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `ContainerProtocol`
    /// Will retain `GtkContainer`.
    public convenience init<T: ContainerProtocol>(_ other: T) {
        self.init(cast(other.container_ptr))
        g_object_ref(cast(container_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkContainer.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkContainer.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkContainer.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkContainer>(opaquePointer))
    }



}

public enum ContainerPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case appPaintable = "app-paintable"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case compositeChild = "composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    case isFocus = "is-focus"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case resizeMode = "resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
}

public extension ContainerProtocol {
    /// Bind a `ContainerPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ContainerPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(container_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum ContainerSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    case add = "add"
    /// The `button`-press-event signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button`-release-event signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child`-notify signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The `composited`-changed signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure`-event signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete`-event signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy`-event signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag`-begin signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag`-data-delete signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag`-data-get signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag`-data-received signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag`-drop signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag`-drop signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag`-data-received handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag`-end signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag`-begin.
    case dragEnd = "drag-end"
    /// The `drag`-failed signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag`-leave signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag`-motion, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag`-leave signal is also emitted before the
    /// `drag`-drop signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag`-motion signal handler.
    case dragLeave = "drag-leave"
    /// The `drag`-motion signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag`-data-received
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag`-leave and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enter`-notify-event will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key`-press-event) and finally a generic
    /// `GtkWidget::event`-after signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event`-after will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `focus`-in-event signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus`-out-event signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab`-notify signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy`-changed signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key`-press-event signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key`-release-event signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `leave`-notify-event will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map`-event will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map`-event signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion`-notify-event signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent`-set signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The `property`-notify-event signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// The `screen`-changed signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll`-event signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `selection`-clear-event signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection`-request-event signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-changed signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style`-set signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style`-updated signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style`-updated signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap`-event signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility`-notify-event will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    /// The `window`-state-event will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    case notifyIsFocus = "notify::is-focus"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizeMode = "notify::resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
}

public extension ContainerProtocol {
    /// Connect a `ContainerSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: ContainerSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(container_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension ContainerProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkContainer` instance.
    var container_ptr: UnsafeMutablePointer<GtkContainer> { return ptr.assumingMemoryBound(to: GtkContainer.self) }

    /// Adds `widget` to `container`. Typically used for simple containers
    /// such as `GtkWindow`, `GtkFrame`, or `GtkButton`; for more complicated
    /// layout containers such as `GtkBox` or `GtkGrid`, this function will
    /// pick default packing parameters that may not be correct.  So
    /// consider functions such as `gtk_box_pack_start()` and
    /// `gtk_grid_attach()` as an alternative to `gtk_container_add()` in
    /// those cases. A widget may be added to only one container at a time;
    /// you can’t place the same widget inside two different containers.
    /// 
    /// Note that some containers, such as `GtkScrolledWindow` or `GtkListBox`,
    /// may add intermediate children between the added widget and the
    /// container.
    func add(widget: WidgetProtocol) {
        gtk_container_add(cast(container_ptr), cast(widget.ptr))
    
    }


    // *** addWithProperties() is not available because it has a varargs (...) parameter!


    func checkResize() {
        gtk_container_check_resize(cast(container_ptr))
    
    }


    // *** childGet() is not available because it has a varargs (...) parameter!


    /// Gets the value of a child property for `child` and `container`.
    func childGetProperty(child: WidgetProtocol, propertyName property_name: UnsafePointer<gchar>, value: GLibObject.ValueProtocol) {
        gtk_container_child_get_property(cast(container_ptr), cast(child.ptr), property_name, cast(value.ptr))
    
    }

    /// Gets the values of one or more child properties for `child` and `container`.
    func childGetValist(child: WidgetProtocol, firstPropertyName first_property_name: UnsafePointer<gchar>, varArgs var_args: CVaListPointer) {
        gtk_container_child_get_valist(cast(container_ptr), cast(child.ptr), first_property_name, var_args)
    
    }

    /// Emits a `GtkWidget::child`-notify signal for the
    /// [child property](#child-properties)
    /// `child_property` on the child.
    /// 
    /// This is an analogue of `g_object_notify()` for child properties.
    /// 
    /// Also see `gtk_widget_child_notify()`.
    func childNotify(child: WidgetProtocol, childProperty child_property: UnsafePointer<gchar>) {
        gtk_container_child_notify(cast(container_ptr), cast(child.ptr), child_property)
    
    }

    /// Emits a `GtkWidget::child`-notify signal for the
    /// [child property](#child-properties) specified by
    /// `pspec` on the child.
    /// 
    /// This is an analogue of `g_object_notify_by_pspec()` for child properties.
    func childNotifyByPspec(child: WidgetProtocol, pspec: ParamSpecProtocol) {
        gtk_container_child_notify_by_pspec(cast(container_ptr), cast(child.ptr), cast(pspec.ptr))
    
    }


    // *** childSet() is not available because it has a varargs (...) parameter!


    /// Sets a child property for `child` and `container`.
    func childSetProperty(child: WidgetProtocol, propertyName property_name: UnsafePointer<gchar>, value: GLibObject.ValueProtocol) {
        gtk_container_child_set_property(cast(container_ptr), cast(child.ptr), property_name, cast(value.ptr))
    
    }

    /// Sets one or more child properties for `child` and `container`.
    func childSetValist(child: WidgetProtocol, firstPropertyName first_property_name: UnsafePointer<gchar>, varArgs var_args: CVaListPointer) {
        gtk_container_child_set_valist(cast(container_ptr), cast(child.ptr), first_property_name, var_args)
    
    }

    /// Returns the type of the children supported by the container.
    /// 
    /// Note that this may return `G_TYPE_NONE` to indicate that no more
    /// children can be added, e.g. for a `GtkPaned` which already has two
    /// children.
    func childType() -> GType {
        let rv = gtk_container_child_type(cast(container_ptr))
        return rv
    }

    /// Invokes `callback` on each direct child of `container`, including
    /// children that are considered “internal” (implementation details
    /// of the container). “Internal” children generally weren’t added
    /// by the user of the container, but were added by the container
    /// implementation itself.
    /// 
    /// Most applications should use `gtk_container_foreach()`, rather
    /// than `gtk_container_forall()`.
    func forall(callback: @escaping GCallback, callbackData callback_data: UnsafeMutableRawPointer) {
        gtk_container_forall(cast(container_ptr), callback, cast(callback_data))
    
    }

    /// Invokes `callback` on each non-internal child of `container`.
    /// See `gtk_container_forall()` for details on what constitutes
    /// an “internal” child. For all practical purposes, this function
    /// should iterate over precisely those child widgets that were
    /// added to the container by the application with explicit `add()`
    /// calls.
    /// 
    /// It is permissible to remove the child from the `callback` handler.
    /// 
    /// Most applications should use `gtk_container_foreach()`,
    /// rather than `gtk_container_forall()`.
    func foreach(callback: @escaping GCallback, callbackData callback_data: UnsafeMutableRawPointer) {
        gtk_container_foreach(cast(container_ptr), callback, cast(callback_data))
    
    }

    /// Retrieves the border width of the container. See
    /// `gtk_container_set_border_width()`.
    func getBorderWidth() -> CUnsignedInt {
        let rv = gtk_container_get_border_width(cast(container_ptr))
        return CUnsignedInt(rv)
    }

    /// Returns the container’s non-internal children. See
    /// `gtk_container_forall()` for details on what constitutes an "internal" child.
    func getChildren() -> UnsafeMutablePointer<GList>! {
        let rv = gtk_container_get_children(cast(container_ptr))
        return cast(rv)
    }

    /// Retrieves the focus chain of the container, if one has been
    /// set explicitly. If no focus chain has been explicitly
    /// set, GTK+ computes the focus chain based on the positions
    /// of the children. In that case, GTK+ stores `nil` in
    /// `focusable_widgets` and returns `false`.
    ///
    /// **get_focus_chain is deprecated:**
    /// For overriding focus behavior, use the
    ///     GtkWidgetClass::focus signal.
    @available(*, deprecated) func getFocusChain(focusableWidgets focusable_widgets: ListProtocol) -> Bool {
        let rv = gtk_container_get_focus_chain(cast(container_ptr), cast(focusable_widgets.ptr))
        return Bool(rv != 0)
    }

    /// Returns the current focus child widget inside `container`. This is not the
    /// currently focused widget. That can be obtained by calling
    /// `gtk_window_get_focus()`.
    func getFocusChild() -> UnsafeMutablePointer<GtkWidget>! {
        let rv = gtk_container_get_focus_child(cast(container_ptr))
        return cast(rv)
    }

    /// Retrieves the horizontal focus adjustment for the container. See
    /// gtk_container_set_focus_hadjustment ().
    func getFocusHadjustment() -> UnsafeMutablePointer<GtkAdjustment>! {
        let rv = gtk_container_get_focus_hadjustment(cast(container_ptr))
        return cast(rv)
    }

    /// Retrieves the vertical focus adjustment for the container. See
    /// `gtk_container_set_focus_vadjustment()`.
    func getFocusVadjustment() -> UnsafeMutablePointer<GtkAdjustment>! {
        let rv = gtk_container_get_focus_vadjustment(cast(container_ptr))
        return cast(rv)
    }

    /// Returns a newly created widget path representing all the widget hierarchy
    /// from the toplevel down to and including `child`.
    func getPathFor(child: WidgetProtocol) -> UnsafeMutablePointer<GtkWidgetPath>! {
        let rv = gtk_container_get_path_for_child(cast(container_ptr), cast(child.ptr))
        return cast(rv)
    }

    /// Returns the resize mode for the container. See
    /// gtk_container_set_resize_mode ().
    ///
    /// **get_resize_mode is deprecated:**
    /// Resize modes are deprecated. They aren’t necessary
    ///     anymore since frame clocks and might introduce obscure bugs if
    ///     used.
    @available(*, deprecated) func getResizeMode() -> GtkResizeMode {
        let rv = gtk_container_get_resize_mode(cast(container_ptr))
        return rv
    }

    /// When a container receives a call to the draw function, it must send
    /// synthetic `GtkWidget::draw` calls to all children that don’t have their
    /// own `GdkWindows`. This function provides a convenient way of doing this.
    /// A container, when it receives a call to its `GtkWidget::draw` function,
    /// calls `gtk_container_propagate_draw()` once for each child, passing in
    /// the `cr` the container received.
    /// 
    /// `gtk_container_propagate_draw()` takes care of translating the origin of `cr`,
    /// and deciding whether the draw needs to be sent to the child. It is a
    /// convenient and optimized way of getting the same effect as calling
    /// `gtk_widget_draw()` on the child directly.
    /// 
    /// In most cases, a container can simply either inherit the
    /// `GtkWidget::draw` implementation from `GtkContainer`, or do some drawing
    /// and then chain to the `draw` implementation from `GtkContainer`.
    func propagateDraw(child: WidgetProtocol, cr: cairo.ContextProtocol) {
        gtk_container_propagate_draw(cast(container_ptr), cast(child.ptr), cast(cr.ptr))
    
    }

    /// Removes `widget` from `container`. `widget` must be inside `container`.
    /// Note that `container` will own a reference to `widget`, and that this
    /// may be the last reference held; so removing a widget from its
    /// container can destroy that widget. If you want to use `widget`
    /// again, you need to add a reference to it before removing it from
    /// a container, using `g_object_ref()`. If you don’t want to use `widget`
    /// again it’s usually more efficient to simply destroy it directly
    /// using `gtk_widget_destroy()` since this will remove it from the
    /// container and help break any circular reference count cycles.
    func remove(widget: WidgetProtocol) {
        gtk_container_remove(cast(container_ptr), cast(widget.ptr))
    
    }


    ///
    /// **resize_children is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func resizeChildren() {
        gtk_container_resize_children(cast(container_ptr))
    
    }

    /// Sets the border width of the container.
    /// 
    /// The border width of a container is the amount of space to leave
    /// around the outside of the container. The only exception to this is
    /// `GtkWindow`; because toplevel windows can’t leave space outside,
    /// they leave the space inside. The border is added on all sides of
    /// the container. To add space to only one side, use a specific
    /// `GtkWidget:margin` property on the child widget, for example
    /// `GtkWidget:margin`-top.
    func set(borderWidth border_width: CUnsignedInt) {
        gtk_container_set_border_width(cast(container_ptr), guint(border_width))
    
    }

    /// Sets a focus chain, overriding the one computed automatically by GTK+.
    /// 
    /// In principle each widget in the chain should be a descendant of the
    /// container, but this is not enforced by this method, since it’s allowed
    /// to set the focus chain before you pack the widgets, or have a widget
    /// in the chain that isn’t always packed. The necessary checks are done
    /// when the focus chain is actually traversed.
    ///
    /// **set_focus_chain is deprecated:**
    /// For overriding focus behavior, use the
    ///     GtkWidgetClass::focus signal.
    @available(*, deprecated) func setFocusChain(focusableWidgets focusable_widgets: ListProtocol) {
        gtk_container_set_focus_chain(cast(container_ptr), cast(focusable_widgets.ptr))
    
    }

    /// Sets, or unsets if `child` is `nil`, the focused child of `container`.
    /// 
    /// This function emits the GtkContainer`set_focus_child` signal of
    /// `container`. Implementations of `GtkContainer` can override the
    /// default behaviour by overriding the class closure of this signal.
    /// 
    /// This is function is mostly meant to be used by widgets. Applications can use
    /// `gtk_widget_grab_focus()` to manually set the focus to a specific widget.
    func setFocus(child: WidgetProtocol) {
        gtk_container_set_focus_child(cast(container_ptr), cast(child.ptr))
    
    }

    /// Hooks up an adjustment to focus handling in a container, so when a child
    /// of the container is focused, the adjustment is scrolled to show that
    /// widget. This function sets the horizontal alignment.
    /// See `gtk_scrolled_window_get_hadjustment()` for a typical way of obtaining
    /// the adjustment and `gtk_container_set_focus_vadjustment()` for setting
    /// the vertical adjustment.
    /// 
    /// The adjustments have to be in pixel units and in the same coordinate
    /// system as the allocation for immediate children of the container.
    func setFocusHadjustment(adjustment: AdjustmentProtocol) {
        gtk_container_set_focus_hadjustment(cast(container_ptr), cast(adjustment.ptr))
    
    }

    /// Hooks up an adjustment to focus handling in a container, so when a
    /// child of the container is focused, the adjustment is scrolled to
    /// show that widget. This function sets the vertical alignment. See
    /// `gtk_scrolled_window_get_vadjustment()` for a typical way of obtaining
    /// the adjustment and `gtk_container_set_focus_hadjustment()` for setting
    /// the horizontal adjustment.
    /// 
    /// The adjustments have to be in pixel units and in the same coordinate
    /// system as the allocation for immediate children of the container.
    func setFocusVadjustment(adjustment: AdjustmentProtocol) {
        gtk_container_set_focus_vadjustment(cast(container_ptr), cast(adjustment.ptr))
    
    }

    /// Sets the `reallocate_redraws` flag of the container to the given value.
    /// 
    /// Containers requesting reallocation redraws get automatically
    /// redrawn if any of their children changed allocation.
    ///
    /// **set_reallocate_redraws is deprecated:**
    /// Call gtk_widget_queue_draw() in your size_allocate handler.
    @available(*, deprecated) func setReallocateRedraws(needsRedraws needs_redraws: Bool) {
        gtk_container_set_reallocate_redraws(cast(container_ptr), gboolean(needs_redraws ? 1 : 0))
    
    }

    /// Sets the resize mode for the container.
    /// 
    /// The resize mode of a container determines whether a resize request
    /// will be passed to the container’s parent, queued for later execution
    /// or executed immediately.
    ///
    /// **set_resize_mode is deprecated:**
    /// Resize modes are deprecated. They aren’t necessary
    ///     anymore since frame clocks and might introduce obscure bugs if
    ///     used.
    @available(*, deprecated) func set(resizeMode resize_mode: ResizeMode) {
        gtk_container_set_resize_mode(cast(container_ptr), resize_mode)
    
    }

    /// Removes a focus chain explicitly set with `gtk_container_set_focus_chain()`.
    ///
    /// **unset_focus_chain is deprecated:**
    /// For overriding focus behavior, use the
    ///     GtkWidgetClass::focus signal.
    @available(*, deprecated) func unsetFocusChain() {
        gtk_container_unset_focus_chain(cast(container_ptr))
    
    }
    /// Retrieves the border width of the container. See
    /// `gtk_container_set_border_width()`.
    var borderWidth: CUnsignedInt {
        /// Retrieves the border width of the container. See
        /// `gtk_container_set_border_width()`.
        get {
            let rv = gtk_container_get_border_width(cast(container_ptr))
            return CUnsignedInt(rv)
        }
        /// Sets the border width of the container.
        /// 
        /// The border width of a container is the amount of space to leave
        /// around the outside of the container. The only exception to this is
        /// `GtkWindow`; because toplevel windows can’t leave space outside,
        /// they leave the space inside. The border is added on all sides of
        /// the container. To add space to only one side, use a specific
        /// `GtkWidget:margin` property on the child widget, for example
        /// `GtkWidget:margin`-top.
        nonmutating set {
            gtk_container_set_border_width(cast(container_ptr), guint(newValue))
        }
    }

    /// Returns the container’s non-internal children. See
    /// `gtk_container_forall()` for details on what constitutes an "internal" child.
    var children: UnsafeMutablePointer<GList>! {
        /// Returns the container’s non-internal children. See
        /// `gtk_container_forall()` for details on what constitutes an "internal" child.
        get {
            let rv = gtk_container_get_children(cast(container_ptr))
            return cast(rv)
        }
    }

    /// Returns the current focus child widget inside `container`. This is not the
    /// currently focused widget. That can be obtained by calling
    /// `gtk_window_get_focus()`.
    var focusChild: UnsafeMutablePointer<GtkWidget>! {
        /// Returns the current focus child widget inside `container`. This is not the
        /// currently focused widget. That can be obtained by calling
        /// `gtk_window_get_focus()`.
        get {
            let rv = gtk_container_get_focus_child(cast(container_ptr))
            return cast(rv)
        }
        /// Sets, or unsets if `child` is `nil`, the focused child of `container`.
        /// 
        /// This function emits the GtkContainer`set_focus_child` signal of
        /// `container`. Implementations of `GtkContainer` can override the
        /// default behaviour by overriding the class closure of this signal.
        /// 
        /// This is function is mostly meant to be used by widgets. Applications can use
        /// `gtk_widget_grab_focus()` to manually set the focus to a specific widget.
        nonmutating set {
            gtk_container_set_focus_child(cast(container_ptr), cast(newValue))
        }
    }

    /// Retrieves the horizontal focus adjustment for the container. See
    /// gtk_container_set_focus_hadjustment ().
    var focusHadjustment: UnsafeMutablePointer<GtkAdjustment>! {
        /// Retrieves the horizontal focus adjustment for the container. See
        /// gtk_container_set_focus_hadjustment ().
        get {
            let rv = gtk_container_get_focus_hadjustment(cast(container_ptr))
            return cast(rv)
        }
        /// Hooks up an adjustment to focus handling in a container, so when a child
        /// of the container is focused, the adjustment is scrolled to show that
        /// widget. This function sets the horizontal alignment.
        /// See `gtk_scrolled_window_get_hadjustment()` for a typical way of obtaining
        /// the adjustment and `gtk_container_set_focus_vadjustment()` for setting
        /// the vertical adjustment.
        /// 
        /// The adjustments have to be in pixel units and in the same coordinate
        /// system as the allocation for immediate children of the container.
        nonmutating set {
            gtk_container_set_focus_hadjustment(cast(container_ptr), cast(newValue))
        }
    }

    /// Retrieves the vertical focus adjustment for the container. See
    /// `gtk_container_set_focus_vadjustment()`.
    var focusVadjustment: UnsafeMutablePointer<GtkAdjustment>! {
        /// Retrieves the vertical focus adjustment for the container. See
        /// `gtk_container_set_focus_vadjustment()`.
        get {
            let rv = gtk_container_get_focus_vadjustment(cast(container_ptr))
            return cast(rv)
        }
        /// Hooks up an adjustment to focus handling in a container, so when a
        /// child of the container is focused, the adjustment is scrolled to
        /// show that widget. This function sets the vertical alignment. See
        /// `gtk_scrolled_window_get_vadjustment()` for a typical way of obtaining
        /// the adjustment and `gtk_container_set_focus_hadjustment()` for setting
        /// the horizontal adjustment.
        /// 
        /// The adjustments have to be in pixel units and in the same coordinate
        /// system as the allocation for immediate children of the container.
        nonmutating set {
            gtk_container_set_focus_vadjustment(cast(container_ptr), cast(newValue))
        }
    }

    /// Returns the resize mode for the container. See
    /// gtk_container_set_resize_mode ().
    ///
    /// **get_resize_mode is deprecated:**
    /// Resize modes are deprecated. They aren’t necessary
    ///     anymore since frame clocks and might introduce obscure bugs if
    ///     used.
    var resizeMode: GtkResizeMode {
        /// Returns the resize mode for the container. See
        /// gtk_container_set_resize_mode ().
        ///
        /// **get_resize_mode is deprecated:**
        /// Resize modes are deprecated. They aren’t necessary
        ///     anymore since frame clocks and might introduce obscure bugs if
        ///     used.
        @available(*, deprecated) get {
            let rv = gtk_container_get_resize_mode(cast(container_ptr))
            return rv
        }
        /// Sets the resize mode for the container.
        /// 
        /// The resize mode of a container determines whether a resize request
        /// will be passed to the container’s parent, queued for later execution
        /// or executed immediately.
        ///
        /// **set_resize_mode is deprecated:**
        /// Resize modes are deprecated. They aren’t necessary
        ///     anymore since frame clocks and might introduce obscure bugs if
        ///     used.
        @available(*, deprecated) nonmutating set {
            gtk_container_set_resize_mode(cast(container_ptr), newValue)
        }
    }
}



// MARK: - ContainerAccessible Class

/// The `ContainerAccessibleProtocol` protocol exposes the methods and properties of an underlying `GtkContainerAccessible` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ContainerAccessible`.
/// Alternatively, use `ContainerAccessibleRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///

public protocol ContainerAccessibleProtocol: WidgetAccessibleProtocol {
    /// Untyped pointer to the underlying `GtkContainerAccessible` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkContainerAccessible` instance.
    var container_accessible_ptr: UnsafeMutablePointer<GtkContainerAccessible> { get }
}

/// The `ContainerAccessibleRef` type acts as a lightweight Swift reference to an underlying `GtkContainerAccessible` instance.
/// It exposes methods that can operate on this data type through `ContainerAccessibleProtocol` conformance.
/// Use `ContainerAccessibleRef` only as an `unowned` reference to an existing `GtkContainerAccessible` instance.
///

public struct ContainerAccessibleRef: ContainerAccessibleProtocol {
    /// Untyped pointer to the underlying `GtkContainerAccessible` instance.
    /// For type-safe access, use the generated, typed pointer `container_accessible_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension ContainerAccessibleRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkContainerAccessible>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `ContainerAccessibleProtocol`
    init<T: ContainerAccessibleProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerAccessibleProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerAccessibleProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerAccessibleProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerAccessibleProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerAccessibleProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `ContainerAccessible` type acts as a reference-counted owner of an underlying `GtkContainerAccessible` instance.
/// It provides the methods that can operate on this data type through `ContainerAccessibleProtocol` conformance.
/// Use `ContainerAccessible` as a strong reference or owner of a `GtkContainerAccessible` instance.
///

open class ContainerAccessible: WidgetAccessible, ContainerAccessibleProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `ContainerAccessible` instance.
    public init(_ op: UnsafeMutablePointer<GtkContainerAccessible>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `ContainerAccessibleProtocol`
    /// Will retain `GtkContainerAccessible`.
    public convenience init<T: ContainerAccessibleProtocol>(_ other: T) {
        self.init(cast(other.container_accessible_ptr))
        g_object_ref(cast(container_accessible_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerAccessibleProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkContainerAccessible.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerAccessibleProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkContainerAccessible.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerAccessibleProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkContainerAccessible.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerAccessibleProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkContainerAccessible>(opaquePointer))
    }



}

public enum ContainerAccessiblePropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case widget = "widget"
}

public extension ContainerAccessibleProtocol {
    /// Bind a `ContainerAccessiblePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ContainerAccessiblePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(container_accessible_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum ContainerAccessibleSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyWidget = "notify::widget"
}

public extension ContainerAccessibleProtocol {
    /// Connect a `ContainerAccessibleSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: ContainerAccessibleSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(container_accessible_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension ContainerAccessibleProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkContainerAccessible` instance.
    var container_accessible_ptr: UnsafeMutablePointer<GtkContainerAccessible> { return ptr.assumingMemoryBound(to: GtkContainerAccessible.self) }

}



// MARK: - ContainerCellAccessible Class

/// The `ContainerCellAccessibleProtocol` protocol exposes the methods and properties of an underlying `GtkContainerCellAccessible` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ContainerCellAccessible`.
/// Alternatively, use `ContainerCellAccessibleRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///

public protocol ContainerCellAccessibleProtocol: CellAccessibleProtocol {
    /// Untyped pointer to the underlying `GtkContainerCellAccessible` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkContainerCellAccessible` instance.
    var container_cell_accessible_ptr: UnsafeMutablePointer<GtkContainerCellAccessible> { get }
}

/// The `ContainerCellAccessibleRef` type acts as a lightweight Swift reference to an underlying `GtkContainerCellAccessible` instance.
/// It exposes methods that can operate on this data type through `ContainerCellAccessibleProtocol` conformance.
/// Use `ContainerCellAccessibleRef` only as an `unowned` reference to an existing `GtkContainerCellAccessible` instance.
///

public struct ContainerCellAccessibleRef: ContainerCellAccessibleProtocol {
    /// Untyped pointer to the underlying `GtkContainerCellAccessible` instance.
    /// For type-safe access, use the generated, typed pointer `container_cell_accessible_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension ContainerCellAccessibleRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkContainerCellAccessible>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `ContainerCellAccessibleProtocol`
    init<T: ContainerCellAccessibleProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerCellAccessibleProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerCellAccessibleProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerCellAccessibleProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerCellAccessibleProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerCellAccessibleProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        init() {
        let rv = gtk_container_cell_accessible_new()
        self.init(cast(rv))
    }
}

/// The `ContainerCellAccessible` type acts as a reference-counted owner of an underlying `GtkContainerCellAccessible` instance.
/// It provides the methods that can operate on this data type through `ContainerCellAccessibleProtocol` conformance.
/// Use `ContainerCellAccessible` as a strong reference or owner of a `GtkContainerCellAccessible` instance.
///

open class ContainerCellAccessible: CellAccessible, ContainerCellAccessibleProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `ContainerCellAccessible` instance.
    public init(_ op: UnsafeMutablePointer<GtkContainerCellAccessible>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `ContainerCellAccessibleProtocol`
    /// Will retain `GtkContainerCellAccessible`.
    public convenience init<T: ContainerCellAccessibleProtocol>(_ other: T) {
        self.init(cast(other.container_cell_accessible_ptr))
        g_object_ref(cast(container_cell_accessible_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerCellAccessibleProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkContainerCellAccessible.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerCellAccessibleProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkContainerCellAccessible.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerCellAccessibleProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkContainerCellAccessible.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ContainerCellAccessibleProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkContainerCellAccessible>(opaquePointer))
    }

    public convenience init() {
        let rv = gtk_container_cell_accessible_new()
        self.init(cast(rv))
    }


}

public enum ContainerCellAccessiblePropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case widget = "widget"
}

public extension ContainerCellAccessibleProtocol {
    /// Bind a `ContainerCellAccessiblePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ContainerCellAccessiblePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(container_cell_accessible_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum ContainerCellAccessibleSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyWidget = "notify::widget"
}

public extension ContainerCellAccessibleProtocol {
    /// Connect a `ContainerCellAccessibleSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: ContainerCellAccessibleSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(container_cell_accessible_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension ContainerCellAccessibleProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkContainerCellAccessible` instance.
    var container_cell_accessible_ptr: UnsafeMutablePointer<GtkContainerCellAccessible> { return ptr.assumingMemoryBound(to: GtkContainerCellAccessible.self) }

    func add(child: CellAccessibleProtocol) {
        gtk_container_cell_accessible_add_child(cast(container_cell_accessible_ptr), cast(child.ptr))
    
    }

    /// Get a list of children.
    func getChildren() -> UnsafeMutablePointer<GList>! {
        let rv = gtk_container_cell_accessible_get_children(cast(container_cell_accessible_ptr))
        return cast(rv)
    }

    func remove(child: CellAccessibleProtocol) {
        gtk_container_cell_accessible_remove_child(cast(container_cell_accessible_ptr), cast(child.ptr))
    
    }
    /// Get a list of children.
    var children: UnsafeMutablePointer<GList>! {
        /// Get a list of children.
        get {
            let rv = gtk_container_cell_accessible_get_children(cast(container_cell_accessible_ptr))
            return cast(rv)
        }
    }
}



// MARK: - CssProvider Class

/// The `CssProviderProtocol` protocol exposes the methods and properties of an underlying `GtkCssProvider` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CssProvider`.
/// Alternatively, use `CssProviderRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// GtkCssProvider is an object implementing the `GtkStyleProvider` interface.
/// It is able to parse [CSS-like](#css-overview) input in order to style widgets.
/// 
/// An application can make GTK+ parse a specific CSS style sheet by calling
/// `gtk_css_provider_load_from_file()` or `gtk_css_provider_load_from_resource()`
/// and adding the provider with `gtk_style_context_add_provider()` or
/// `gtk_style_context_add_provider_for_screen()`.
/// 
/// In addition, certain files will be read when GTK+ is initialized. First, the
/// file `$XDG_CONFIG_HOME/gtk-3.0/gtk.css` is loaded if it exists. Then, GTK+
/// loads the first existing file among
/// `XDG_DATA_HOME/themes/THEME/gtk-VERSION/gtk.css`,
/// `$HOME/.themes/THEME/gtk-VERSION/gtk.css`,
/// `$XDG_DATA_DIRS/themes/THEME/gtk-VERSION/gtk.css` and
/// `DATADIR/share/themes/THEME/gtk-VERSION/gtk.css`, where `THEME` is the name of
/// the current theme (see the `GtkSettings:gtk`-theme-name setting), `DATADIR`
/// is the prefix configured when GTK+ was compiled (unless overridden by the
/// `GTK_DATA_PREFIX` environment variable), and `VERSION` is the GTK+ version number.
/// If no file is found for the current version, GTK+ tries older versions all the
/// way back to 3.0.
/// 
/// In the same way, GTK+ tries to load a gtk-keys.css file for the current
/// key theme, as defined by `GtkSettings:gtk`-key-theme-name.
public protocol CssProviderProtocol: GLibObject.ObjectProtocol, StyleProviderProtocol {
    /// Untyped pointer to the underlying `GtkCssProvider` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkCssProvider` instance.
    var css_provider_ptr: UnsafeMutablePointer<GtkCssProvider> { get }
}

/// The `CssProviderRef` type acts as a lightweight Swift reference to an underlying `GtkCssProvider` instance.
/// It exposes methods that can operate on this data type through `CssProviderProtocol` conformance.
/// Use `CssProviderRef` only as an `unowned` reference to an existing `GtkCssProvider` instance.
///
/// GtkCssProvider is an object implementing the `GtkStyleProvider` interface.
/// It is able to parse [CSS-like](#css-overview) input in order to style widgets.
/// 
/// An application can make GTK+ parse a specific CSS style sheet by calling
/// `gtk_css_provider_load_from_file()` or `gtk_css_provider_load_from_resource()`
/// and adding the provider with `gtk_style_context_add_provider()` or
/// `gtk_style_context_add_provider_for_screen()`.
/// 
/// In addition, certain files will be read when GTK+ is initialized. First, the
/// file `$XDG_CONFIG_HOME/gtk-3.0/gtk.css` is loaded if it exists. Then, GTK+
/// loads the first existing file among
/// `XDG_DATA_HOME/themes/THEME/gtk-VERSION/gtk.css`,
/// `$HOME/.themes/THEME/gtk-VERSION/gtk.css`,
/// `$XDG_DATA_DIRS/themes/THEME/gtk-VERSION/gtk.css` and
/// `DATADIR/share/themes/THEME/gtk-VERSION/gtk.css`, where `THEME` is the name of
/// the current theme (see the `GtkSettings:gtk`-theme-name setting), `DATADIR`
/// is the prefix configured when GTK+ was compiled (unless overridden by the
/// `GTK_DATA_PREFIX` environment variable), and `VERSION` is the GTK+ version number.
/// If no file is found for the current version, GTK+ tries older versions all the
/// way back to 3.0.
/// 
/// In the same way, GTK+ tries to load a gtk-keys.css file for the current
/// key theme, as defined by `GtkSettings:gtk`-key-theme-name.
public struct CssProviderRef: CssProviderProtocol {
    /// Untyped pointer to the underlying `GtkCssProvider` instance.
    /// For type-safe access, use the generated, typed pointer `css_provider_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension CssProviderRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkCssProvider>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `CssProviderProtocol`
    init<T: CssProviderProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Returns a newly created `GtkCssProvider`.
    init() {
        let rv = gtk_css_provider_new()
        self.init(cast(rv))
    }
    /// Returns the provider containing the style settings used as a
    /// fallback for all widgets.
    ///
    /// **get_default is deprecated:**
    /// Use gtk_css_provider_new() instead.
    @available(*, deprecated) static func getDefault() -> CssProviderRef! {
        let rv = gtk_css_provider_get_default()
        return rv.map { CssProviderRef(cast($0)) }
    }

    /// Loads a theme from the usual theme paths
    static func getNamed(name: UnsafePointer<gchar>, variant: UnsafePointer<gchar>) -> CssProviderRef! {
        let rv = gtk_css_provider_get_named(name, variant)
        return rv.map { CssProviderRef(cast($0)) }
    }
}

/// The `CssProvider` type acts as a reference-counted owner of an underlying `GtkCssProvider` instance.
/// It provides the methods that can operate on this data type through `CssProviderProtocol` conformance.
/// Use `CssProvider` as a strong reference or owner of a `GtkCssProvider` instance.
///
/// GtkCssProvider is an object implementing the `GtkStyleProvider` interface.
/// It is able to parse [CSS-like](#css-overview) input in order to style widgets.
/// 
/// An application can make GTK+ parse a specific CSS style sheet by calling
/// `gtk_css_provider_load_from_file()` or `gtk_css_provider_load_from_resource()`
/// and adding the provider with `gtk_style_context_add_provider()` or
/// `gtk_style_context_add_provider_for_screen()`.
/// 
/// In addition, certain files will be read when GTK+ is initialized. First, the
/// file `$XDG_CONFIG_HOME/gtk-3.0/gtk.css` is loaded if it exists. Then, GTK+
/// loads the first existing file among
/// `XDG_DATA_HOME/themes/THEME/gtk-VERSION/gtk.css`,
/// `$HOME/.themes/THEME/gtk-VERSION/gtk.css`,
/// `$XDG_DATA_DIRS/themes/THEME/gtk-VERSION/gtk.css` and
/// `DATADIR/share/themes/THEME/gtk-VERSION/gtk.css`, where `THEME` is the name of
/// the current theme (see the `GtkSettings:gtk`-theme-name setting), `DATADIR`
/// is the prefix configured when GTK+ was compiled (unless overridden by the
/// `GTK_DATA_PREFIX` environment variable), and `VERSION` is the GTK+ version number.
/// If no file is found for the current version, GTK+ tries older versions all the
/// way back to 3.0.
/// 
/// In the same way, GTK+ tries to load a gtk-keys.css file for the current
/// key theme, as defined by `GtkSettings:gtk`-key-theme-name.
open class CssProvider: GLibObject.Object, CssProviderProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `CssProvider` instance.
    public init(_ op: UnsafeMutablePointer<GtkCssProvider>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `CssProviderProtocol`
    /// Will retain `GtkCssProvider`.
    public convenience init<T: CssProviderProtocol>(_ other: T) {
        self.init(cast(other.css_provider_ptr))
        g_object_ref(cast(css_provider_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkCssProvider.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkCssProvider.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkCssProvider.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkCssProvider>(opaquePointer))
    }

    /// Returns a newly created `GtkCssProvider`.
    public convenience init() {
        let rv = gtk_css_provider_new()
        self.init(cast(rv))
    }

    /// Returns the provider containing the style settings used as a
    /// fallback for all widgets.
    ///
    /// **get_default is deprecated:**
    /// Use gtk_css_provider_new() instead.
    @available(*, deprecated) public static func getDefault() -> CssProvider! {
        let rv = gtk_css_provider_get_default()
        return rv.map { CssProvider(cast($0)) }
    }

    /// Loads a theme from the usual theme paths
    public static func getNamed(name: UnsafePointer<gchar>, variant: UnsafePointer<gchar>) -> CssProvider! {
        let rv = gtk_css_provider_get_named(name, variant)
        return rv.map { CssProvider(cast($0)) }
    }

}

// MARK: - no CssProvider properties

public enum CssProviderSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Signals that a parsing error occurred. the `path`, `line` and `position`
    /// describe the actual location of the error as accurately as possible.
    /// 
    /// Parsing errors are never fatal, so the parsing will resume after
    /// the error. Errors may however cause parts of the given
    /// data or even all of it to not be parsed at all. So it is a useful idea
    /// to check that the parsing succeeds by connecting to this signal.
    /// 
    /// Note that this signal may be emitted at any time as the css provider
    /// may opt to defer parsing parts or all of the input to a later time
    /// than when a loading function was called.
    case parsingError = "parsing-error"

}

public extension CssProviderProtocol {
    /// Connect a `CssProviderSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: CssProviderSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(css_provider_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension CssProviderProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCssProvider` instance.
    var css_provider_ptr: UnsafeMutablePointer<GtkCssProvider> { return ptr.assumingMemoryBound(to: GtkCssProvider.self) }

    /// Loads `data` into `css_provider`, and by doing so clears any previously loaded
    /// information.
    func loadFrom(data: UnsafePointer<gchar>, length: gssize) throws -> Bool {
        var error: Optional<UnsafeMutablePointer<GError>> = nil
        let rv = gtk_css_provider_load_from_data(cast(css_provider_ptr), cast(data), length, &error)
        if let error = error {
                throw ErrorType(error)
        }
        return Bool(rv != 0)
    }

    /// Loads the data contained in `file` into `css_provider`, making it
    /// clear any previously loaded information.
    func loadFrom(file: FileProtocol) throws -> Bool {
        var error: Optional<UnsafeMutablePointer<GError>> = nil
        let rv = gtk_css_provider_load_from_file(cast(css_provider_ptr), cast(file.ptr), &error)
        if let error = error {
                throw ErrorType(error)
        }
        return Bool(rv != 0)
    }

    /// Loads the data contained in `path` into `css_provider`, making it clear
    /// any previously loaded information.
    func loadFrom(path: UnsafePointer<gchar>) throws -> Bool {
        var error: Optional<UnsafeMutablePointer<GError>> = nil
        let rv = gtk_css_provider_load_from_path(cast(css_provider_ptr), path, &error)
        if let error = error {
                throw ErrorType(error)
        }
        return Bool(rv != 0)
    }

    /// Loads the data contained in the resource at `resource_path` into
    /// the `GtkCssProvider`, clearing any previously loaded information.
    /// 
    /// To track errors while loading CSS, connect to the
    /// `GtkCssProvider::parsing`-error signal.
    func loadFrom(resource resource_path: UnsafePointer<gchar>) {
        gtk_css_provider_load_from_resource(cast(css_provider_ptr), resource_path)
    
    }

    /// Converts the `provider` into a string representation in CSS
    /// format.
    /// 
    /// Using `gtk_css_provider_load_from_data()` with the return value
    /// from this function on a new provider created with
    /// `gtk_css_provider_new()` will basically create a duplicate of
    /// this `provider`.
    func toString() -> String! {
        let rv = gtk_css_provider_to_string(cast(css_provider_ptr))
        return rv.map { String(cString: UnsafePointer<CChar>($0)) }
    }
}



// MARK: - Dialog Class

/// The `DialogProtocol` protocol exposes the methods and properties of an underlying `GtkDialog` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Dialog`.
/// Alternatively, use `DialogRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// Dialog boxes are a convenient way to prompt the user for a small amount
/// of input, e.g. to display a message, ask a question, or anything else
/// that does not require extensive effort on the user’s part.
/// 
/// GTK+ treats a dialog as a window split vertically. The top section is a
/// `GtkVBox`, and is where widgets such as a `GtkLabel` or a `GtkEntry` should
/// be packed. The bottom area is known as the
/// “action area”. This is generally used for
/// packing buttons into the dialog which may perform functions such as
/// cancel, ok, or apply.
/// 
/// `GtkDialog` boxes are created with a call to `gtk_dialog_new()` or
/// `gtk_dialog_new_with_buttons()`. `gtk_dialog_new_with_buttons()` is
/// recommended; it allows you to set the dialog title, some convenient
/// flags, and add simple buttons.
/// 
/// If “dialog” is a newly created dialog, the two primary areas of the
/// window can be accessed through `gtk_dialog_get_content_area()` and
/// `gtk_dialog_get_action_area()`, as can be seen from the example below.
/// 
/// A “modal” dialog (that is, one which freezes the rest of the application
/// from user input), can be created by calling `gtk_window_set_modal()` on the
/// dialog. Use the `GTK_WINDOW()` macro to cast the widget returned from
/// `gtk_dialog_new()` into a `GtkWindow`. When using `gtk_dialog_new_with_buttons()`
/// you can also pass the `GTK_DIALOG_MODAL` flag to make a dialog modal.
/// 
/// If you add buttons to `GtkDialog` using `gtk_dialog_new_with_buttons()`,
/// `gtk_dialog_add_button()`, `gtk_dialog_add_buttons()`, or
/// `gtk_dialog_add_action_widget()`, clicking the button will emit a signal
/// called `GtkDialog::response` with a response ID that you specified. GTK+
/// will never assign a meaning to positive response IDs; these are entirely
/// user-defined. But for convenience, you can use the response IDs in the
/// `GtkResponseType` enumeration (these all have values less than zero). If
/// a dialog receives a delete event, the `GtkDialog::response` signal will
/// be emitted with a response ID of `GTK_RESPONSE_DELETE_EVENT`.
/// 
/// If you want to block waiting for a dialog to return before returning
/// control flow to your code, you can call `gtk_dialog_run()`. This function
/// enters a recursive main loop and waits for the user to respond to the
/// dialog, returning the response ID corresponding to the button the user
/// clicked.
/// 
/// For the simple dialog in the following example, in reality you’d probably
/// use `GtkMessageDialog` to save yourself some effort. But you’d need to
/// create the dialog contents manually if you had more than a simple message
/// in the dialog.
/// 
/// An example for simple GtkDialog usage:
/// (C Language Example):
/// ```C
/// // Function to open a dialog box with a message
/// void
/// quick_message (GtkWindow *parent, gchar *message)
/// {
///  GtkWidget *dialog, *label, *content_area;
///  GtkDialogFlags flags;
/// 
///  // Create the widgets
///  flags = GTK_DIALOG_DESTROY_WITH_PARENT;
///  dialog = gtk_dialog_new_with_buttons ("Message",
///                                        parent,
///                                        flags,
///                                        _("_OK"),
///                                        GTK_RESPONSE_NONE,
///                                        NULL);
///  content_area = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
///  label = gtk_label_new (message);
/// 
///  // Ensure that the dialog box is destroyed when the user responds
/// 
///  g_signal_connect_swapped (dialog,
///                            "response",
///                            G_CALLBACK (gtk_widget_destroy),
///                            dialog);
/// 
///  // Add the label, and show everything we’ve added
/// 
///  gtk_container_add (GTK_CONTAINER (content_area), label);
///  gtk_widget_show_all (dialog);
/// }
/// ```
/// 
/// # GtkDialog as GtkBuildable
/// 
/// The GtkDialog implementation of the `GtkBuildable` interface exposes the
/// `vbox` and `action_area` as internal children with the names “vbox” and
/// “action_area”.
/// 
/// GtkDialog supports a custom <action-widgets> element, which can contain
/// multiple <action-widget> elements. The “response” attribute specifies a
/// numeric response, and the content of the element is the id of widget
/// (which should be a child of the dialogs `action_area`). To mark a response
/// as default, set the “default“ attribute of the <action-widget> element
/// to true.
/// 
/// GtkDialog supports adding action widgets by specifying “action“ as
/// the “type“ attribute of a <child> element. The widget will be added
/// either to the action area or the headerbar of the dialog, depending
/// on the “use-header-bar“ property. The response id has to be associated
/// with the action widget using the <action-widgets> element.
/// 
/// An example of a `GtkDialog` UI definition fragment:
/// ```
/// <object class="GtkDialog" id="dialog1">
///   <child type="action">
///     <object class="GtkButton" id="button_cancel"/>
///   </child>
///   <child type="action">
///     <object class="GtkButton" id="button_ok">
///       <property name="can-default">True</property>
///     </object>
///   </child>
///   <action-widgets>
///     <action-widget response="cancel">button_cancel</action-widget>
///     <action-widget response="ok" default="true">button_ok</action-widget>
///   </action-widgets>
/// </object>
/// ```
/// 
public protocol DialogProtocol: WindowProtocol {
    /// Untyped pointer to the underlying `GtkDialog` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkDialog` instance.
    var dialog_ptr: UnsafeMutablePointer<GtkDialog> { get }
}

/// The `DialogRef` type acts as a lightweight Swift reference to an underlying `GtkDialog` instance.
/// It exposes methods that can operate on this data type through `DialogProtocol` conformance.
/// Use `DialogRef` only as an `unowned` reference to an existing `GtkDialog` instance.
///
/// Dialog boxes are a convenient way to prompt the user for a small amount
/// of input, e.g. to display a message, ask a question, or anything else
/// that does not require extensive effort on the user’s part.
/// 
/// GTK+ treats a dialog as a window split vertically. The top section is a
/// `GtkVBox`, and is where widgets such as a `GtkLabel` or a `GtkEntry` should
/// be packed. The bottom area is known as the
/// “action area”. This is generally used for
/// packing buttons into the dialog which may perform functions such as
/// cancel, ok, or apply.
/// 
/// `GtkDialog` boxes are created with a call to `gtk_dialog_new()` or
/// `gtk_dialog_new_with_buttons()`. `gtk_dialog_new_with_buttons()` is
/// recommended; it allows you to set the dialog title, some convenient
/// flags, and add simple buttons.
/// 
/// If “dialog” is a newly created dialog, the two primary areas of the
/// window can be accessed through `gtk_dialog_get_content_area()` and
/// `gtk_dialog_get_action_area()`, as can be seen from the example below.
/// 
/// A “modal” dialog (that is, one which freezes the rest of the application
/// from user input), can be created by calling `gtk_window_set_modal()` on the
/// dialog. Use the `GTK_WINDOW()` macro to cast the widget returned from
/// `gtk_dialog_new()` into a `GtkWindow`. When using `gtk_dialog_new_with_buttons()`
/// you can also pass the `GTK_DIALOG_MODAL` flag to make a dialog modal.
/// 
/// If you add buttons to `GtkDialog` using `gtk_dialog_new_with_buttons()`,
/// `gtk_dialog_add_button()`, `gtk_dialog_add_buttons()`, or
/// `gtk_dialog_add_action_widget()`, clicking the button will emit a signal
/// called `GtkDialog::response` with a response ID that you specified. GTK+
/// will never assign a meaning to positive response IDs; these are entirely
/// user-defined. But for convenience, you can use the response IDs in the
/// `GtkResponseType` enumeration (these all have values less than zero). If
/// a dialog receives a delete event, the `GtkDialog::response` signal will
/// be emitted with a response ID of `GTK_RESPONSE_DELETE_EVENT`.
/// 
/// If you want to block waiting for a dialog to return before returning
/// control flow to your code, you can call `gtk_dialog_run()`. This function
/// enters a recursive main loop and waits for the user to respond to the
/// dialog, returning the response ID corresponding to the button the user
/// clicked.
/// 
/// For the simple dialog in the following example, in reality you’d probably
/// use `GtkMessageDialog` to save yourself some effort. But you’d need to
/// create the dialog contents manually if you had more than a simple message
/// in the dialog.
/// 
/// An example for simple GtkDialog usage:
/// (C Language Example):
/// ```C
/// // Function to open a dialog box with a message
/// void
/// quick_message (GtkWindow *parent, gchar *message)
/// {
///  GtkWidget *dialog, *label, *content_area;
///  GtkDialogFlags flags;
/// 
///  // Create the widgets
///  flags = GTK_DIALOG_DESTROY_WITH_PARENT;
///  dialog = gtk_dialog_new_with_buttons ("Message",
///                                        parent,
///                                        flags,
///                                        _("_OK"),
///                                        GTK_RESPONSE_NONE,
///                                        NULL);
///  content_area = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
///  label = gtk_label_new (message);
/// 
///  // Ensure that the dialog box is destroyed when the user responds
/// 
///  g_signal_connect_swapped (dialog,
///                            "response",
///                            G_CALLBACK (gtk_widget_destroy),
///                            dialog);
/// 
///  // Add the label, and show everything we’ve added
/// 
///  gtk_container_add (GTK_CONTAINER (content_area), label);
///  gtk_widget_show_all (dialog);
/// }
/// ```
/// 
/// # GtkDialog as GtkBuildable
/// 
/// The GtkDialog implementation of the `GtkBuildable` interface exposes the
/// `vbox` and `action_area` as internal children with the names “vbox” and
/// “action_area”.
/// 
/// GtkDialog supports a custom <action-widgets> element, which can contain
/// multiple <action-widget> elements. The “response” attribute specifies a
/// numeric response, and the content of the element is the id of widget
/// (which should be a child of the dialogs `action_area`). To mark a response
/// as default, set the “default“ attribute of the <action-widget> element
/// to true.
/// 
/// GtkDialog supports adding action widgets by specifying “action“ as
/// the “type“ attribute of a <child> element. The widget will be added
/// either to the action area or the headerbar of the dialog, depending
/// on the “use-header-bar“ property. The response id has to be associated
/// with the action widget using the <action-widgets> element.
/// 
/// An example of a `GtkDialog` UI definition fragment:
/// ```
/// <object class="GtkDialog" id="dialog1">
///   <child type="action">
///     <object class="GtkButton" id="button_cancel"/>
///   </child>
///   <child type="action">
///     <object class="GtkButton" id="button_ok">
///       <property name="can-default">True</property>
///     </object>
///   </child>
///   <action-widgets>
///     <action-widget response="cancel">button_cancel</action-widget>
///     <action-widget response="ok" default="true">button_ok</action-widget>
///   </action-widgets>
/// </object>
/// ```
/// 
public struct DialogRef: DialogProtocol {
    /// Untyped pointer to the underlying `GtkDialog` instance.
    /// For type-safe access, use the generated, typed pointer `dialog_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension DialogRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkDialog>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `DialogProtocol`
    init<T: DialogProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new dialog box.
    /// 
    /// Widgets should not be packed into this `GtkWindow`
    /// directly, but into the `vbox` and `action_area`, as described above.
    init() {
        let rv = gtk_dialog_new()
        self.init(cast(rv))
    }


    // *** newWithButtons() is not available because it has a varargs (...) parameter!


    // *** newWithButtons() is not available because it has a varargs (...) parameter!

}

/// The `Dialog` type acts as a reference-counted owner of an underlying `GtkDialog` instance.
/// It provides the methods that can operate on this data type through `DialogProtocol` conformance.
/// Use `Dialog` as a strong reference or owner of a `GtkDialog` instance.
///
/// Dialog boxes are a convenient way to prompt the user for a small amount
/// of input, e.g. to display a message, ask a question, or anything else
/// that does not require extensive effort on the user’s part.
/// 
/// GTK+ treats a dialog as a window split vertically. The top section is a
/// `GtkVBox`, and is where widgets such as a `GtkLabel` or a `GtkEntry` should
/// be packed. The bottom area is known as the
/// “action area”. This is generally used for
/// packing buttons into the dialog which may perform functions such as
/// cancel, ok, or apply.
/// 
/// `GtkDialog` boxes are created with a call to `gtk_dialog_new()` or
/// `gtk_dialog_new_with_buttons()`. `gtk_dialog_new_with_buttons()` is
/// recommended; it allows you to set the dialog title, some convenient
/// flags, and add simple buttons.
/// 
/// If “dialog” is a newly created dialog, the two primary areas of the
/// window can be accessed through `gtk_dialog_get_content_area()` and
/// `gtk_dialog_get_action_area()`, as can be seen from the example below.
/// 
/// A “modal” dialog (that is, one which freezes the rest of the application
/// from user input), can be created by calling `gtk_window_set_modal()` on the
/// dialog. Use the `GTK_WINDOW()` macro to cast the widget returned from
/// `gtk_dialog_new()` into a `GtkWindow`. When using `gtk_dialog_new_with_buttons()`
/// you can also pass the `GTK_DIALOG_MODAL` flag to make a dialog modal.
/// 
/// If you add buttons to `GtkDialog` using `gtk_dialog_new_with_buttons()`,
/// `gtk_dialog_add_button()`, `gtk_dialog_add_buttons()`, or
/// `gtk_dialog_add_action_widget()`, clicking the button will emit a signal
/// called `GtkDialog::response` with a response ID that you specified. GTK+
/// will never assign a meaning to positive response IDs; these are entirely
/// user-defined. But for convenience, you can use the response IDs in the
/// `GtkResponseType` enumeration (these all have values less than zero). If
/// a dialog receives a delete event, the `GtkDialog::response` signal will
/// be emitted with a response ID of `GTK_RESPONSE_DELETE_EVENT`.
/// 
/// If you want to block waiting for a dialog to return before returning
/// control flow to your code, you can call `gtk_dialog_run()`. This function
/// enters a recursive main loop and waits for the user to respond to the
/// dialog, returning the response ID corresponding to the button the user
/// clicked.
/// 
/// For the simple dialog in the following example, in reality you’d probably
/// use `GtkMessageDialog` to save yourself some effort. But you’d need to
/// create the dialog contents manually if you had more than a simple message
/// in the dialog.
/// 
/// An example for simple GtkDialog usage:
/// (C Language Example):
/// ```C
/// // Function to open a dialog box with a message
/// void
/// quick_message (GtkWindow *parent, gchar *message)
/// {
///  GtkWidget *dialog, *label, *content_area;
///  GtkDialogFlags flags;
/// 
///  // Create the widgets
///  flags = GTK_DIALOG_DESTROY_WITH_PARENT;
///  dialog = gtk_dialog_new_with_buttons ("Message",
///                                        parent,
///                                        flags,
///                                        _("_OK"),
///                                        GTK_RESPONSE_NONE,
///                                        NULL);
///  content_area = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
///  label = gtk_label_new (message);
/// 
///  // Ensure that the dialog box is destroyed when the user responds
/// 
///  g_signal_connect_swapped (dialog,
///                            "response",
///                            G_CALLBACK (gtk_widget_destroy),
///                            dialog);
/// 
///  // Add the label, and show everything we’ve added
/// 
///  gtk_container_add (GTK_CONTAINER (content_area), label);
///  gtk_widget_show_all (dialog);
/// }
/// ```
/// 
/// # GtkDialog as GtkBuildable
/// 
/// The GtkDialog implementation of the `GtkBuildable` interface exposes the
/// `vbox` and `action_area` as internal children with the names “vbox” and
/// “action_area”.
/// 
/// GtkDialog supports a custom <action-widgets> element, which can contain
/// multiple <action-widget> elements. The “response” attribute specifies a
/// numeric response, and the content of the element is the id of widget
/// (which should be a child of the dialogs `action_area`). To mark a response
/// as default, set the “default“ attribute of the <action-widget> element
/// to true.
/// 
/// GtkDialog supports adding action widgets by specifying “action“ as
/// the “type“ attribute of a <child> element. The widget will be added
/// either to the action area or the headerbar of the dialog, depending
/// on the “use-header-bar“ property. The response id has to be associated
/// with the action widget using the <action-widgets> element.
/// 
/// An example of a `GtkDialog` UI definition fragment:
/// ```
/// <object class="GtkDialog" id="dialog1">
///   <child type="action">
///     <object class="GtkButton" id="button_cancel"/>
///   </child>
///   <child type="action">
///     <object class="GtkButton" id="button_ok">
///       <property name="can-default">True</property>
///     </object>
///   </child>
///   <action-widgets>
///     <action-widget response="cancel">button_cancel</action-widget>
///     <action-widget response="ok" default="true">button_ok</action-widget>
///   </action-widgets>
/// </object>
/// ```
/// 
open class Dialog: Window, DialogProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `Dialog` instance.
    public init(_ op: UnsafeMutablePointer<GtkDialog>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `DialogProtocol`
    /// Will retain `GtkDialog`.
    public convenience init<T: DialogProtocol>(_ other: T) {
        self.init(cast(other.dialog_ptr))
        g_object_ref(cast(dialog_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkDialog.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkDialog.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkDialog.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkDialog>(opaquePointer))
    }

    /// Creates a new dialog box.
    /// 
    /// Widgets should not be packed into this `GtkWindow`
    /// directly, but into the `vbox` and `action_area`, as described above.
    public convenience init() {
        let rv = gtk_dialog_new()
        self.init(cast(rv))
    }


    // *** newWithButtons() is not available because it has a varargs (...) parameter!



    // *** newWithButtons() is not available because it has a varargs (...) parameter!


}

public enum DialogPropertyName: String, PropertyNameProtocol {
    /// Whether the window should receive the input focus.
    case acceptFocus = "accept-focus"
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case appPaintable = "app-paintable"
    /// The `GtkApplication` associated with the window.
    /// 
    /// The application will be kept alive for at least as long as it
    /// has any windows associated with it (see `g_application_hold()`
    /// for a way to keep it alive without windows).
    /// 
    /// Normally, the connection between the application and the window
    /// will remain until the window is destroyed, but you can explicitly
    /// remove it by setting the :application property to `nil`.
    case application = "application"
    /// The widget to which this window is attached.
    /// See `gtk_window_set_attached_to()`.
    /// 
    /// Examples of places where specifying this relation is useful are
    /// for instance a `GtkMenu` created by a `GtkComboBox`, a completion
    /// popup window created by `GtkEntry` or a typeahead search entry
    /// created by `GtkTreeView`.
    case attachedTo = "attached-to"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case compositeChild = "composite-child"
    /// Whether the window should be decorated by the window manager.
    case decorated = "decorated"
    case defaultHeight = "default-height"
    case defaultWidth = "default-width"
    /// Whether the window frame should have a close button.
    case deletable = "deletable"
    case destroyWithParent = "destroy-with-parent"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// Whether the window should receive the input focus when mapped.
    case focusOnMap = "focus-on-map"
    /// Whether 'focus rectangles' are currently visible in this window.
    /// 
    /// This property is maintained by GTK+ based on user input
    /// and should not be set by applications.
    case focusVisible = "focus-visible"
    /// The window gravity of the window. See `gtk_window_move()` and `GdkGravity` for
    /// more details about window gravity.
    case gravity = "gravity"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Whether the window has a corner resize grip.
    /// 
    /// Note that the resize grip is only shown if the window is
    /// actually resizable and not maximized. Use
    /// `GtkWindow:resize`-grip-visible to find out if the resize
    /// grip is currently shown.
    ///
    /// **has-resize-grip is deprecated:**
    /// Resize grips have been removed.
    case hasResizeGrip = "has-resize-grip"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case hasToplevelFocus = "has-toplevel-focus"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// Whether the titlebar should be hidden during maximization.
    case hideTitlebarWhenMaximized = "hide-titlebar-when-maximized"
    case icon = "icon"
    /// The :icon-name property specifies the name of the themed icon to
    /// use as the window icon. See `GtkIconTheme` for more details.
    case iconName = "icon-name"
    case isActive = "is-active"
    case isFocus = "is-focus"
    case isMaximized = "is-maximized"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    /// Whether mnemonics are currently visible in this window.
    /// 
    /// This property is maintained by GTK+ based on user input,
    /// and should not be set by applications.
    case mnemonicsVisible = "mnemonics-visible"
    case modal = "modal"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case resizable = "resizable"
    /// Whether a corner resize grip is currently shown.
    ///
    /// **resize-grip-visible is deprecated:**
    /// Resize grips have been removed.
    case resizeGripVisible = "resize-grip-visible"
    case resizeMode = "resize-mode"
    case role = "role"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case screen = "screen"
    case sensitive = "sensitive"
    case skipPagerHint = "skip-pager-hint"
    case skipTaskbarHint = "skip-taskbar-hint"
    /// The :startup-id is a write-only property for setting window's
    /// startup notification identifier. See `gtk_window_set_startup_id()`
    /// for more details.
    case startupID = "startup-id"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    case title = "title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// The transient parent of the window. See `gtk_window_set_transient_for()` for
    /// more details about transient windows.
    case transientFor = "transient-for"
    case type = "type"
    case typeHint = "type-hint"
    case urgencyHint = "urgency-hint"
    /// `true` if the dialog uses a `GtkHeaderBar` for action buttons
    /// instead of the action-area.
    /// 
    /// For technical reasons, this property is declared as an integer
    /// property, but you should only set it to `true` or `false`.
    case useHeaderBar = "use-header-bar"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
    case windowPosition = "window-position"
}

public extension DialogProtocol {
    /// Bind a `DialogPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: DialogPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(dialog_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum DialogSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    /// The `activate`-default signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user activates the default widget
    /// of `window`.
    case activateDefault = "activate-default"
    /// The `activate`-focus signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user activates the currently
    /// focused widget of `window`.
    case activateFocus = "activate-focus"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    case add = "add"
    /// The `button`-press-event signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button`-release-event signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child`-notify signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The `close` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user uses a keybinding to close
    /// the dialog.
    /// 
    /// The default binding for this signal is the Escape key.
    case close = "close"
    /// The `composited`-changed signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure`-event signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete`-event signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy`-event signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag`-begin signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag`-data-delete signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag`-data-get signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag`-data-received signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag`-drop signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag`-drop signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag`-data-received handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag`-end signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag`-begin.
    case dragEnd = "drag-end"
    /// The `drag`-failed signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag`-leave signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag`-motion, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag`-leave signal is also emitted before the
    /// `drag`-drop signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag`-motion signal handler.
    case dragLeave = "drag-leave"
    /// The `drag`-motion signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag`-data-received
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag`-leave and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enable`-debugging signal is a [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user enables or disables interactive
    /// debugging. When `toggle` is `true`, interactive debugging is toggled
    /// on or off, when it is `false`, the debugger will be pointed at the
    /// widget under the pointer.
    /// 
    /// The default bindings for this signal are Ctrl-Shift-I
    /// and Ctrl-Shift-D.
    case enableDebugging = "enable-debugging"
    /// The `enter`-notify-event will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key`-press-event) and finally a generic
    /// `GtkWidget::event`-after signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event`-after will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `focus`-in-event signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus`-out-event signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab`-notify signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy`-changed signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key`-press-event signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key`-release-event signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `keys`-changed signal gets emitted when the set of accelerators
    /// or mnemonics that are associated with `window` changes.
    case keysChanged = "keys-changed"
    /// The `leave`-notify-event will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map`-event will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map`-event signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion`-notify-event signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent`-set signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The `property`-notify-event signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// Emitted when an action widget is clicked, the dialog receives a
    /// delete event, or the application programmer calls `gtk_dialog_response()`.
    /// On a delete event, the response ID is `GTK_RESPONSE_DELETE_EVENT`.
    /// Otherwise, it depends on which action widget was clicked.
    case response = "response"
    /// The `screen`-changed signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll`-event signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `selection`-clear-event signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection`-request-event signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocus = "set-focus"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-changed signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style`-set signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style`-updated signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style`-updated signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap`-event signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility`-notify-event will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    /// The `window`-state-event will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    /// Whether the window should receive the input focus.
    case notifyAcceptFocus = "notify::accept-focus"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyAppPaintable = "notify::app-paintable"
    /// The `GtkApplication` associated with the window.
    /// 
    /// The application will be kept alive for at least as long as it
    /// has any windows associated with it (see `g_application_hold()`
    /// for a way to keep it alive without windows).
    /// 
    /// Normally, the connection between the application and the window
    /// will remain until the window is destroyed, but you can explicitly
    /// remove it by setting the :application property to `nil`.
    case notifyApplication = "notify::application"
    /// The widget to which this window is attached.
    /// See `gtk_window_set_attached_to()`.
    /// 
    /// Examples of places where specifying this relation is useful are
    /// for instance a `GtkMenu` created by a `GtkComboBox`, a completion
    /// popup window created by `GtkEntry` or a typeahead search entry
    /// created by `GtkTreeView`.
    case notifyAttachedTo = "notify::attached-to"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the window should be decorated by the window manager.
    case notifyDecorated = "notify::decorated"
    case notifyDefaultHeight = "notify::default-height"
    case notifyDefaultWidth = "notify::default-width"
    /// Whether the window frame should have a close button.
    case notifyDeletable = "notify::deletable"
    case notifyDestroyWithParent = "notify::destroy-with-parent"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether the window should receive the input focus when mapped.
    case notifyFocusOnMap = "notify::focus-on-map"
    /// Whether 'focus rectangles' are currently visible in this window.
    /// 
    /// This property is maintained by GTK+ based on user input
    /// and should not be set by applications.
    case notifyFocusVisible = "notify::focus-visible"
    /// The window gravity of the window. See `gtk_window_move()` and `GdkGravity` for
    /// more details about window gravity.
    case notifyGravity = "notify::gravity"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Whether the window has a corner resize grip.
    /// 
    /// Note that the resize grip is only shown if the window is
    /// actually resizable and not maximized. Use
    /// `GtkWindow:resize`-grip-visible to find out if the resize
    /// grip is currently shown.
    ///
    /// **has-resize-grip is deprecated:**
    /// Resize grips have been removed.
    case notifyHasResizeGrip = "notify::has-resize-grip"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHasToplevelFocus = "notify::has-toplevel-focus"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// Whether the titlebar should be hidden during maximization.
    case notifyHideTitlebarWhenMaximized = "notify::hide-titlebar-when-maximized"
    case notifyIcon = "notify::icon"
    /// The :icon-name property specifies the name of the themed icon to
    /// use as the window icon. See `GtkIconTheme` for more details.
    case notifyIconName = "notify::icon-name"
    case notifyIsActive = "notify::is-active"
    case notifyIsFocus = "notify::is-focus"
    case notifyIsMaximized = "notify::is-maximized"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    /// Whether mnemonics are currently visible in this window.
    /// 
    /// This property is maintained by GTK+ based on user input,
    /// and should not be set by applications.
    case notifyMnemonicsVisible = "notify::mnemonics-visible"
    case notifyModal = "notify::modal"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizable = "notify::resizable"
    /// Whether a corner resize grip is currently shown.
    ///
    /// **resize-grip-visible is deprecated:**
    /// Resize grips have been removed.
    case notifyResizeGripVisible = "notify::resize-grip-visible"
    case notifyResizeMode = "notify::resize-mode"
    case notifyRole = "notify::role"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifyScreen = "notify::screen"
    case notifySensitive = "notify::sensitive"
    case notifySkipPagerHint = "notify::skip-pager-hint"
    case notifySkipTaskbarHint = "notify::skip-taskbar-hint"
    /// The :startup-id is a write-only property for setting window's
    /// startup notification identifier. See `gtk_window_set_startup_id()`
    /// for more details.
    case notifyStartupID = "notify::startup-id"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    case notifyTitle = "notify::title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// The transient parent of the window. See `gtk_window_set_transient_for()` for
    /// more details about transient windows.
    case notifyTransientFor = "notify::transient-for"
    case notifyType_ = "notify::type"
    case notifyTypeHint = "notify::type-hint"
    case notifyUrgencyHint = "notify::urgency-hint"
    /// `true` if the dialog uses a `GtkHeaderBar` for action buttons
    /// instead of the action-area.
    /// 
    /// For technical reasons, this property is declared as an integer
    /// property, but you should only set it to `true` or `false`.
    case notifyUseHeaderBar = "notify::use-header-bar"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
    case notifyWindowPosition = "notify::window-position"
}

public extension DialogProtocol {
    /// Connect a `DialogSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: DialogSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(dialog_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension DialogProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkDialog` instance.
    var dialog_ptr: UnsafeMutablePointer<GtkDialog> { return ptr.assumingMemoryBound(to: GtkDialog.self) }

    /// Adds an activatable widget to the action area of a `GtkDialog`,
    /// connecting a signal handler that will emit the `GtkDialog::response`
    /// signal on the dialog when the widget is activated. The widget is
    /// appended to the end of the dialog’s action area. If you want to add a
    /// non-activatable widget, simply pack it into the `action_area` field
    /// of the `GtkDialog` struct.
    func addActionWidget(child: WidgetProtocol, responseID response_id: CInt) {
        gtk_dialog_add_action_widget(cast(dialog_ptr), cast(child.ptr), gint(response_id))
    
    }

    /// Adds a button with the given text and sets things up so that
    /// clicking the button will emit the `GtkDialog::response` signal with
    /// the given `response_id`. The button is appended to the end of the
    /// dialog’s action area. The button widget is returned, but usually
    /// you don’t need it.
    func addButton(buttonText button_text: UnsafePointer<gchar>, responseID response_id: CInt) -> UnsafeMutablePointer<GtkWidget>! {
        let rv = gtk_dialog_add_button(cast(dialog_ptr), button_text, gint(response_id))
        return cast(rv)
    }


    // *** addButtons() is not available because it has a varargs (...) parameter!


    /// Returns the action area of `dialog`.
    ///
    /// **get_action_area is deprecated:**
    /// Direct access to the action area
    ///   is discouraged; use gtk_dialog_add_button(), etc.
    @available(*, deprecated) func getActionArea() -> UnsafeMutablePointer<GtkWidget>! {
        let rv = gtk_dialog_get_action_area(cast(dialog_ptr))
        return cast(rv)
    }

    /// Returns the content area of `dialog`.
    func getContentArea() -> UnsafeMutablePointer<GtkWidget>! {
        let rv = gtk_dialog_get_content_area(cast(dialog_ptr))
        return cast(rv)
    }

    /// Returns the header bar of `dialog`. Note that the
    /// headerbar is only used by the dialog if the
    /// `GtkDialog:use`-header-bar property is `true`.
    func getHeaderBar() -> UnsafeMutablePointer<GtkWidget>! {
        let rv = gtk_dialog_get_header_bar(cast(dialog_ptr))
        return cast(rv)
    }

    /// Gets the response id of a widget in the action area
    /// of a dialog.
    func getResponseFor(widget: WidgetProtocol) -> CInt {
        let rv = gtk_dialog_get_response_for_widget(cast(dialog_ptr), cast(widget.ptr))
        return CInt(rv)
    }

    /// Gets the widget button that uses the given response ID in the action area
    /// of a dialog.
    func getWidgetForResponse(responseID response_id: CInt) -> UnsafeMutablePointer<GtkWidget>! {
        let rv = gtk_dialog_get_widget_for_response(cast(dialog_ptr), gint(response_id))
        return cast(rv)
    }

    /// Emits the `GtkDialog::response` signal with the given response ID.
    /// Used to indicate that the user has responded to the dialog in some way;
    /// typically either you or `gtk_dialog_run()` will be monitoring the
    /// `response` signal and take appropriate action.
    func response(responseID response_id: CInt) {
        gtk_dialog_response(cast(dialog_ptr), gint(response_id))
    
    }

    /// Blocks in a recursive main loop until the `dialog` either emits the
    /// `GtkDialog::response` signal, or is destroyed. If the dialog is
    /// destroyed during the call to `gtk_dialog_run()`, `gtk_dialog_run()` returns
    /// `GTK_RESPONSE_NONE`. Otherwise, it returns the response ID from the
    /// `response` signal emission.
    /// 
    /// Before entering the recursive main loop, `gtk_dialog_run()` calls
    /// `gtk_widget_show()` on the dialog for you. Note that you still
    /// need to show any children of the dialog yourself.
    /// 
    /// During `gtk_dialog_run()`, the default behavior of `GtkWidget::delete`-event
    /// is disabled; if the dialog receives `delete_event`, it will not be
    /// destroyed as windows usually are, and `gtk_dialog_run()` will return
    /// `GTK_RESPONSE_DELETE_EVENT`. Also, during `gtk_dialog_run()` the dialog
    /// will be modal. You can force `gtk_dialog_run()` to return at any time by
    /// calling `gtk_dialog_response()` to emit the `response` signal. Destroying
    /// the dialog during `gtk_dialog_run()` is a very bad idea, because your
    /// post-run code won’t know whether the dialog was destroyed or not.
    /// 
    /// After `gtk_dialog_run()` returns, you are responsible for hiding or
    /// destroying the dialog if you wish to do so.
    /// 
    /// Typical usage of this function might be:
    /// (C Language Example):
    /// ```C
    ///   GtkWidget *dialog = gtk_dialog_new ();
    ///   // Set up dialog...
    /// 
    ///   int result = gtk_dialog_run (GTK_DIALOG (dialog));
    ///   switch (result)
    ///     {
    ///       case GTK_RESPONSE_ACCEPT:
    ///          // do_application_specific_something ();
    ///          break;
    ///       default:
    ///          // do_nothing_since_dialog_was_cancelled ();
    ///          break;
    ///     }
    ///   gtk_widget_destroy (dialog);
    /// ```
    /// 
    /// Note that even though the recursive main loop gives the effect of a
    /// modal dialog (it prevents the user from interacting with other
    /// windows in the same window group while the dialog is run), callbacks
    /// such as timeouts, IO channel watches, DND drops, etc, will
    /// be triggered during a `gtk_dialog_run()` call.
    func run() -> CInt {
        let rv = gtk_dialog_run(cast(dialog_ptr))
        return CInt(rv)
    }


    // *** setAlternativeButtonOrder() is not available because it has a varargs (...) parameter!


    /// Sets an alternative button order. If the
    /// `GtkSettings:gtk`-alternative-button-order setting is set to `true`,
    /// the dialog buttons are reordered according to the order of the
    /// response ids in `new_order`.
    /// 
    /// See `gtk_dialog_set_alternative_button_order()` for more information.
    /// 
    /// This function is for use by language bindings.
    ///
    /// **set_alternative_button_order_from_array is deprecated:**
    /// Deprecated
    @available(*, deprecated) func setAlternativeButtonOrderFromArray(nParams n_params: CInt, newOrder new_order: UnsafeMutablePointer<CInt>) {
        gtk_dialog_set_alternative_button_order_from_array(cast(dialog_ptr), gint(n_params), cast(new_order))
    
    }

    /// Sets the last widget in the dialog’s action area with the given `response_id`
    /// as the default widget for the dialog. Pressing “Enter” normally activates
    /// the default widget.
    func setDefaultResponse(responseID response_id: CInt) {
        gtk_dialog_set_default_response(cast(dialog_ptr), gint(response_id))
    
    }

    /// Calls `gtk_widget_set_sensitive (widget, `setting`)`
    /// for each widget in the dialog’s action area with the given `response_id`.
    /// A convenient way to sensitize/desensitize dialog buttons.
    func setResponseSensitive(responseID response_id: CInt, setting: Bool) {
        gtk_dialog_set_response_sensitive(cast(dialog_ptr), gint(response_id), gboolean(setting ? 1 : 0))
    
    }
    /// Returns the action area of `dialog`.
    ///
    /// **get_action_area is deprecated:**
    /// Direct access to the action area
    ///   is discouraged; use gtk_dialog_add_button(), etc.
    var actionArea: UnsafeMutablePointer<GtkWidget>! {
        /// Returns the action area of `dialog`.
        ///
        /// **get_action_area is deprecated:**
        /// Direct access to the action area
        ///   is discouraged; use gtk_dialog_add_button(), etc.
        @available(*, deprecated) get {
            let rv = gtk_dialog_get_action_area(cast(dialog_ptr))
            return cast(rv)
        }
    }

    /// Returns the content area of `dialog`.
    var contentArea: UnsafeMutablePointer<GtkWidget>! {
        /// Returns the content area of `dialog`.
        get {
            let rv = gtk_dialog_get_content_area(cast(dialog_ptr))
            return cast(rv)
        }
    }

    /// Returns the header bar of `dialog`. Note that the
    /// headerbar is only used by the dialog if the
    /// `GtkDialog:use`-header-bar property is `true`.
    var headerBar: UnsafeMutablePointer<GtkWidget>! {
        /// Returns the header bar of `dialog`. Note that the
        /// headerbar is only used by the dialog if the
        /// `GtkDialog:use`-header-bar property is `true`.
        get {
            let rv = gtk_dialog_get_header_bar(cast(dialog_ptr))
            return cast(rv)
        }
    }
}



