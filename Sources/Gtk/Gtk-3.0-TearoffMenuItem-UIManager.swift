import CGLib
import CCairo
import CPango
import CGdkPixbuf
import CGdk
import CAtk
import CGtk
import GLib
import GLibObject
import GIO
import Pango
import Cairo
import PangoCairo
import GdkPixbuf
import Gdk
import Atk

// MARK: - TearoffMenuItem Class

/// The `TearoffMenuItemProtocol` protocol exposes the methods and properties of an underlying `GtkTearoffMenuItem` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TearoffMenuItem`.
/// Alternatively, use `TearoffMenuItemRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkTearoffMenuItem` is a special `GtkMenuItem` which is used to
/// tear off and reattach its menu.
/// 
/// When its menu is shown normally, the `GtkTearoffMenuItem` is drawn as a
/// dotted line indicating that the menu can be torn off.  Activating it
/// causes its menu to be torn off and displayed in its own window
/// as a tearoff menu.
/// 
/// When its menu is shown as a tearoff menu, the `GtkTearoffMenuItem` is drawn
/// as a dotted line which has a left pointing arrow graphic indicating that
/// the tearoff menu can be reattached.  Activating it will erase the tearoff
/// menu window.
/// 
/// > `GtkTearoffMenuItem` is deprecated and should not be used in newly
/// > written code. Menus are not meant to be torn around.
public protocol TearoffMenuItemProtocol: MenuItemProtocol {
    /// Untyped pointer to the underlying `GtkTearoffMenuItem` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkTearoffMenuItem` instance.
    var tearoff_menu_item_ptr: UnsafeMutablePointer<GtkTearoffMenuItem> { get }
}

/// The `TearoffMenuItemRef` type acts as a lightweight Swift reference to an underlying `GtkTearoffMenuItem` instance.
/// It exposes methods that can operate on this data type through `TearoffMenuItemProtocol` conformance.
/// Use `TearoffMenuItemRef` only as an `unowned` reference to an existing `GtkTearoffMenuItem` instance.
///
/// A `GtkTearoffMenuItem` is a special `GtkMenuItem` which is used to
/// tear off and reattach its menu.
/// 
/// When its menu is shown normally, the `GtkTearoffMenuItem` is drawn as a
/// dotted line indicating that the menu can be torn off.  Activating it
/// causes its menu to be torn off and displayed in its own window
/// as a tearoff menu.
/// 
/// When its menu is shown as a tearoff menu, the `GtkTearoffMenuItem` is drawn
/// as a dotted line which has a left pointing arrow graphic indicating that
/// the tearoff menu can be reattached.  Activating it will erase the tearoff
/// menu window.
/// 
/// > `GtkTearoffMenuItem` is deprecated and should not be used in newly
/// > written code. Menus are not meant to be torn around.
public struct TearoffMenuItemRef: TearoffMenuItemProtocol {
    /// Untyped pointer to the underlying `GtkTearoffMenuItem` instance.
    /// For type-safe access, use the generated, typed pointer `tearoff_menu_item_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension TearoffMenuItemRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkTearoffMenuItem>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `TearoffMenuItemProtocol`
    init<T: TearoffMenuItemProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TearoffMenuItemProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TearoffMenuItemProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TearoffMenuItemProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TearoffMenuItemProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TearoffMenuItemProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkTearoffMenuItem`.
    ///
    /// **new is deprecated:**
    /// #GtkTearoffMenuItem is deprecated and should not be
    ///     used in newly written code.
    @available(*, deprecated) init() {
        let rv = gtk_tearoff_menu_item_new()
        self.init(cast(rv))
    }
}

/// The `TearoffMenuItem` type acts as a reference-counted owner of an underlying `GtkTearoffMenuItem` instance.
/// It provides the methods that can operate on this data type through `TearoffMenuItemProtocol` conformance.
/// Use `TearoffMenuItem` as a strong reference or owner of a `GtkTearoffMenuItem` instance.
///
/// A `GtkTearoffMenuItem` is a special `GtkMenuItem` which is used to
/// tear off and reattach its menu.
/// 
/// When its menu is shown normally, the `GtkTearoffMenuItem` is drawn as a
/// dotted line indicating that the menu can be torn off.  Activating it
/// causes its menu to be torn off and displayed in its own window
/// as a tearoff menu.
/// 
/// When its menu is shown as a tearoff menu, the `GtkTearoffMenuItem` is drawn
/// as a dotted line which has a left pointing arrow graphic indicating that
/// the tearoff menu can be reattached.  Activating it will erase the tearoff
/// menu window.
/// 
/// > `GtkTearoffMenuItem` is deprecated and should not be used in newly
/// > written code. Menus are not meant to be torn around.
open class TearoffMenuItem: MenuItem, TearoffMenuItemProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `TearoffMenuItem` instance.
    public init(_ op: UnsafeMutablePointer<GtkTearoffMenuItem>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `TearoffMenuItemProtocol`
    /// Will retain `GtkTearoffMenuItem`.
    public convenience init<T: TearoffMenuItemProtocol>(_ other: T) {
        self.init(cast(other.tearoff_menu_item_ptr))
        g_object_ref(cast(tearoff_menu_item_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TearoffMenuItemProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkTearoffMenuItem.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TearoffMenuItemProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkTearoffMenuItem.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TearoffMenuItemProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkTearoffMenuItem.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TearoffMenuItemProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkTearoffMenuItem>(opaquePointer))
    }

    /// Creates a new `GtkTearoffMenuItem`.
    ///
    /// **new is deprecated:**
    /// #GtkTearoffMenuItem is deprecated and should not be
    ///     used in newly written code.
    @available(*, deprecated) public convenience init() {
        let rv = gtk_tearoff_menu_item_new()
        self.init(cast(rv))
    }


}

public enum TearoffMenuItemPropertyName: String, PropertyNameProtocol {
    /// Sets the accelerator path of the menu item, through which runtime
    /// changes of the menu item's accelerator caused by the user can be
    /// identified and saved to persistant storage.
    case accelPath = "accel-path"
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case appPaintable = "app-paintable"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case compositeChild = "composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    case isFocus = "is-focus"
    /// The text for the child label.
    case label = "label"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case resizeMode = "resize-mode"
    /// Sets whether the menu item appears justified
    /// at the right side of a menu bar.
    case rightJustified = "right-justified"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    /// The submenu attached to the menu item, or `nil` if it has none.
    case submenu = "submenu"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// `true` if underlines in the text indicate mnemonics.
    case useUnderline = "use-underline"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
}

public extension TearoffMenuItemProtocol {
    /// Bind a `TearoffMenuItemPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TearoffMenuItemPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(tearoff_menu_item_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum TearoffMenuItemSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    /// Emitted when the item is activated.
    case activate = "activate"
    /// Emitted when the item is activated, but also if the menu item has a
    /// submenu. For normal applications, the relevant signal is
    /// `GtkMenuItem::activate`.
    case activateItem = "activate-item"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    case add = "add"
    /// The `button`-press-event signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button`-release-event signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child`-notify signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The `composited`-changed signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure`-event signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete`-event signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    case deselect = "deselect"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy`-event signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag`-begin signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag`-data-delete signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag`-data-get signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag`-data-received signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag`-drop signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag`-drop signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag`-data-received handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag`-end signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag`-begin.
    case dragEnd = "drag-end"
    /// The `drag`-failed signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag`-leave signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag`-motion, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag`-leave signal is also emitted before the
    /// `drag`-drop signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag`-motion signal handler.
    case dragLeave = "drag-leave"
    /// The `drag`-motion signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag`-data-received
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag`-leave and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enter`-notify-event will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key`-press-event) and finally a generic
    /// `GtkWidget::event`-after signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event`-after will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `focus`-in-event signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus`-out-event signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab`-notify signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy`-changed signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key`-press-event signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key`-release-event signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `leave`-notify-event will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map`-event will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map`-event signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion`-notify-event signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent`-set signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The `property`-notify-event signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// The `screen`-changed signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll`-event signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    case select = "select"
    /// The `selection`-clear-event signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection`-request-event signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-changed signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style`-set signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style`-updated signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style`-updated signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    case toggleSizeAllocate = "toggle-size-allocate"
    case toggleSizeRequest = "toggle-size-request"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap`-event signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility`-notify-event will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    /// The `window`-state-event will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    /// Sets the accelerator path of the menu item, through which runtime
    /// changes of the menu item's accelerator caused by the user can be
    /// identified and saved to persistant storage.
    case notifyAccelPath = "notify::accel-path"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    case notifyIsFocus = "notify::is-focus"
    /// The text for the child label.
    case notifyLabel = "notify::label"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizeMode = "notify::resize-mode"
    /// Sets whether the menu item appears justified
    /// at the right side of a menu bar.
    case notifyRightJustified = "notify::right-justified"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    /// The submenu attached to the menu item, or `nil` if it has none.
    case notifySubmenu = "notify::submenu"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// `true` if underlines in the text indicate mnemonics.
    case notifyUseUnderline = "notify::use-underline"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
}

public extension TearoffMenuItemProtocol {
    /// Connect a `TearoffMenuItemSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: TearoffMenuItemSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(tearoff_menu_item_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension TearoffMenuItemProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTearoffMenuItem` instance.
    var tearoff_menu_item_ptr: UnsafeMutablePointer<GtkTearoffMenuItem> { return ptr.assumingMemoryBound(to: GtkTearoffMenuItem.self) }

}



// MARK: - TextBuffer Class

/// The `TextBufferProtocol` protocol exposes the methods and properties of an underlying `GtkTextBuffer` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextBuffer`.
/// Alternatively, use `TextBufferRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and data
/// types related to the text widget and how they work together.
public protocol TextBufferProtocol: GLibObject.ObjectProtocol {
    /// Untyped pointer to the underlying `GtkTextBuffer` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkTextBuffer` instance.
    var text_buffer_ptr: UnsafeMutablePointer<GtkTextBuffer> { get }
}

/// The `TextBufferRef` type acts as a lightweight Swift reference to an underlying `GtkTextBuffer` instance.
/// It exposes methods that can operate on this data type through `TextBufferProtocol` conformance.
/// Use `TextBufferRef` only as an `unowned` reference to an existing `GtkTextBuffer` instance.
///
/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and data
/// types related to the text widget and how they work together.
public struct TextBufferRef: TextBufferProtocol {
    /// Untyped pointer to the underlying `GtkTextBuffer` instance.
    /// For type-safe access, use the generated, typed pointer `text_buffer_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension TextBufferRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkTextBuffer>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `TextBufferProtocol`
    init<T: TextBufferProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new text buffer.
    init( table: TextTagTableProtocol) {
        let rv = gtk_text_buffer_new(cast(table.ptr))
        self.init(cast(rv))
    }
}

/// The `TextBuffer` type acts as a reference-counted owner of an underlying `GtkTextBuffer` instance.
/// It provides the methods that can operate on this data type through `TextBufferProtocol` conformance.
/// Use `TextBuffer` as a strong reference or owner of a `GtkTextBuffer` instance.
///
/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and data
/// types related to the text widget and how they work together.
open class TextBuffer: GLibObject.Object, TextBufferProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `TextBuffer` instance.
    public init(_ op: UnsafeMutablePointer<GtkTextBuffer>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `TextBufferProtocol`
    /// Will retain `GtkTextBuffer`.
    public convenience init<T: TextBufferProtocol>(_ other: T) {
        self.init(cast(other.text_buffer_ptr))
        g_object_ref(cast(text_buffer_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkTextBuffer.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkTextBuffer.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkTextBuffer.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkTextBuffer>(opaquePointer))
    }

    /// Creates a new text buffer.
    public convenience init( table: TextTagTableProtocol) {
        let rv = gtk_text_buffer_new(cast(table.ptr))
        self.init(cast(rv))
    }


}

public enum TextBufferPropertyName: String, PropertyNameProtocol {
    /// The list of targets this buffer supports for clipboard copying
    /// and as DND source.
    case copyTargetList = "copy-target-list"
    /// The position of the insert mark (as offset from the beginning
    /// of the buffer). It is useful for getting notified when the
    /// cursor moves.
    case cursorPosition = "cursor-position"
    /// Whether the buffer has some text currently selected.
    case hasSelection = "has-selection"
    /// The list of targets this buffer supports for clipboard pasting
    /// and as DND destination.
    case pasteTargetList = "paste-target-list"
    case tagTable = "tag-table"
    /// The text content of the buffer. Without child widgets and images,
    /// see `gtk_text_buffer_get_text()` for more information.
    case text = "text"
}

public extension TextBufferProtocol {
    /// Bind a `TextBufferPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TextBufferPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(text_buffer_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum TextBufferSignalName: String, SignalNameProtocol {
    /// The `apply`-tag signal is emitted to apply a tag to a
    /// range of text in a `GtkTextBuffer`.
    /// Applying actually occurs in the default handler.
    /// 
    /// Note that if your handler runs before the default handler it must not
    /// invalidate the `start` and `end` iters (or has to revalidate them).
    /// 
    /// See also:
    /// `gtk_text_buffer_apply_tag()`,
    /// `gtk_text_buffer_insert_with_tags()`,
    /// `gtk_text_buffer_insert_range()`.
    case applyTag = "apply-tag"
    /// The `begin`-user-action signal is emitted at the beginning of a single
    /// user-visible operation on a `GtkTextBuffer`.
    /// 
    /// See also:
    /// `gtk_text_buffer_begin_user_action()`,
    /// `gtk_text_buffer_insert_interactive()`,
    /// `gtk_text_buffer_insert_range_interactive()`,
    /// `gtk_text_buffer_delete_interactive()`,
    /// `gtk_text_buffer_backspace()`,
    /// `gtk_text_buffer_delete_selection()`.
    case beginUserAction = "begin-user-action"
    /// The `changed` signal is emitted when the content of a `GtkTextBuffer`
    /// has changed.
    case changed = "changed"
    /// The `delete`-range signal is emitted to delete a range
    /// from a `GtkTextBuffer`.
    /// 
    /// Note that if your handler runs before the default handler it must not
    /// invalidate the `start` and `end` iters (or has to revalidate them).
    /// The default signal handler revalidates the `start` and `end` iters to
    /// both point to the location where text was deleted. Handlers
    /// which run after the default handler (see `g_signal_connect_after()`)
    /// do not have access to the deleted text.
    /// 
    /// See also: `gtk_text_buffer_delete()`.
    case deleteRange = "delete-range"
    /// The `end`-user-action signal is emitted at the end of a single
    /// user-visible operation on the `GtkTextBuffer`.
    /// 
    /// See also:
    /// `gtk_text_buffer_end_user_action()`,
    /// `gtk_text_buffer_insert_interactive()`,
    /// `gtk_text_buffer_insert_range_interactive()`,
    /// `gtk_text_buffer_delete_interactive()`,
    /// `gtk_text_buffer_backspace()`,
    /// `gtk_text_buffer_delete_selection()`,
    /// `gtk_text_buffer_backspace()`.
    case endUserAction = "end-user-action"
    /// The `insert`-child-anchor signal is emitted to insert a
    /// `GtkTextChildAnchor` in a `GtkTextBuffer`.
    /// Insertion actually occurs in the default handler.
    /// 
    /// Note that if your handler runs before the default handler it must
    /// not invalidate the `location` iter (or has to revalidate it).
    /// The default signal handler revalidates it to be placed after the
    /// inserted `anchor`.
    /// 
    /// See also: `gtk_text_buffer_insert_child_anchor()`.
    case insertChildAnchor = "insert-child-anchor"
    /// The `insert`-pixbuf signal is emitted to insert a `GdkPixbuf`
    /// in a `GtkTextBuffer`. Insertion actually occurs in the default handler.
    /// 
    /// Note that if your handler runs before the default handler it must not
    /// invalidate the `location` iter (or has to revalidate it).
    /// The default signal handler revalidates it to be placed after the
    /// inserted `pixbuf`.
    /// 
    /// See also: `gtk_text_buffer_insert_pixbuf()`.
    case insertPixbuf = "insert-pixbuf"
    /// The `insert`-text signal is emitted to insert text in a `GtkTextBuffer`.
    /// Insertion actually occurs in the default handler.
    /// 
    /// Note that if your handler runs before the default handler it must not
    /// invalidate the `location` iter (or has to revalidate it).
    /// The default signal handler revalidates it to point to the end of the
    /// inserted text.
    /// 
    /// See also:
    /// `gtk_text_buffer_insert()`,
    /// `gtk_text_buffer_insert_range()`.
    case insertText = "insert-text"
    /// The `mark`-deleted signal is emitted as notification
    /// after a `GtkTextMark` is deleted.
    /// 
    /// See also:
    /// `gtk_text_buffer_delete_mark()`.
    case markDeleted = "mark-deleted"
    /// The `mark`-set signal is emitted as notification
    /// after a `GtkTextMark` is set.
    /// 
    /// See also:
    /// `gtk_text_buffer_create_mark()`,
    /// `gtk_text_buffer_move_mark()`.
    case markSet = "mark-set"
    /// The `modified`-changed signal is emitted when the modified bit of a
    /// `GtkTextBuffer` flips.
    /// 
    /// See also:
    /// `gtk_text_buffer_set_modified()`.
    case modifiedChanged = "modified-changed"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The paste-done signal is emitted after paste operation has been completed.
    /// This is useful to properly scroll the view to the end of the pasted text.
    /// See `gtk_text_buffer_paste_clipboard()` for more details.
    case pasteDone = "paste-done"
    /// The `remove`-tag signal is emitted to remove all occurrences of `tag` from
    /// a range of text in a `GtkTextBuffer`.
    /// Removal actually occurs in the default handler.
    /// 
    /// Note that if your handler runs before the default handler it must not
    /// invalidate the `start` and `end` iters (or has to revalidate them).
    /// 
    /// See also:
    /// `gtk_text_buffer_remove_tag()`.
    case removeTag = "remove-tag"
    /// The list of targets this buffer supports for clipboard copying
    /// and as DND source.
    case notifyCopyTargetList = "notify::copy-target-list"
    /// The position of the insert mark (as offset from the beginning
    /// of the buffer). It is useful for getting notified when the
    /// cursor moves.
    case notifyCursorPosition = "notify::cursor-position"
    /// Whether the buffer has some text currently selected.
    case notifyHasSelection = "notify::has-selection"
    /// The list of targets this buffer supports for clipboard pasting
    /// and as DND destination.
    case notifyPasteTargetList = "notify::paste-target-list"
    case notifyTagTable = "notify::tag-table"
    /// The text content of the buffer. Without child widgets and images,
    /// see `gtk_text_buffer_get_text()` for more information.
    case notifyText = "notify::text"
}

public extension TextBufferProtocol {
    /// Connect a `TextBufferSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: TextBufferSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(text_buffer_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension TextBufferProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextBuffer` instance.
    var text_buffer_ptr: UnsafeMutablePointer<GtkTextBuffer> { return ptr.assumingMemoryBound(to: GtkTextBuffer.self) }

    /// Adds the mark at position `where`. The mark must not be added to
    /// another buffer, and if its name is not `nil` then there must not
    /// be another mark in the buffer with the same name.
    /// 
    /// Emits the `GtkTextBuffer::mark`-set signal as notification of the mark's
    /// initial placement.
    func add(mark: TextMarkProtocol, where_: TextIterProtocol) {
        gtk_text_buffer_add_mark(cast(text_buffer_ptr), cast(mark.ptr), cast(where_.ptr))
    
    }

    /// Adds `clipboard` to the list of clipboards in which the selection
    /// contents of `buffer` are available. In most cases, `clipboard` will be
    /// the `GtkClipboard` of type `GDK_SELECTION_PRIMARY` for a view of `buffer`.
    func addSelection(clipboard: ClipboardProtocol) {
        gtk_text_buffer_add_selection_clipboard(cast(text_buffer_ptr), cast(clipboard.ptr))
    
    }

    /// Emits the “apply-tag” signal on `buffer`. The default
    /// handler for the signal applies `tag` to the given range.
    /// `start` and `end` do not have to be in order.
    func apply(tag: TextTagProtocol, start: TextIterProtocol, end: TextIterProtocol) {
        gtk_text_buffer_apply_tag(cast(text_buffer_ptr), cast(tag.ptr), cast(start.ptr), cast(end.ptr))
    
    }

    /// Calls `gtk_text_tag_table_lookup()` on the buffer’s tag table to
    /// get a `GtkTextTag`, then calls `gtk_text_buffer_apply_tag()`.
    func applyTagBy(name: UnsafePointer<gchar>, start: TextIterProtocol, end: TextIterProtocol) {
        gtk_text_buffer_apply_tag_by_name(cast(text_buffer_ptr), name, cast(start.ptr), cast(end.ptr))
    
    }

    /// Performs the appropriate action as if the user hit the delete
    /// key with the cursor at the position specified by `iter`. In the
    /// normal case a single character will be deleted, but when
    /// combining accents are involved, more than one character can
    /// be deleted, and when precomposed character and accent combinations
    /// are involved, less than one character will be deleted.
    /// 
    /// Because the buffer is modified, all outstanding iterators become
    /// invalid after calling this function; however, the `iter` will be
    /// re-initialized to point to the location where text was deleted.
    func backspace(iter: TextIterProtocol, interactive: Bool, defaultEditable default_editable: Bool) -> Bool {
        let rv = gtk_text_buffer_backspace(cast(text_buffer_ptr), cast(iter.ptr), gboolean(interactive ? 1 : 0), gboolean(default_editable ? 1 : 0))
        return Bool(rv != 0)
    }

    /// Called to indicate that the buffer operations between here and a
    /// call to `gtk_text_buffer_end_user_action()` are part of a single
    /// user-visible operation. The operations between
    /// `gtk_text_buffer_begin_user_action()` and
    /// `gtk_text_buffer_end_user_action()` can then be grouped when creating
    /// an undo stack. `GtkTextBuffer` maintains a count of calls to
    /// `gtk_text_buffer_begin_user_action()` that have not been closed with
    /// a call to `gtk_text_buffer_end_user_action()`, and emits the
    /// “begin-user-action” and “end-user-action” signals only for the
    /// outermost pair of calls. This allows you to build user actions
    /// from other user actions.
    /// 
    /// The “interactive” buffer mutation functions, such as
    /// `gtk_text_buffer_insert_interactive()`, automatically call begin/end
    /// user action around the buffer operations they perform, so there's
    /// no need to add extra calls if you user action consists solely of a
    /// single call to one of those functions.
    func beginUserAction() {
        gtk_text_buffer_begin_user_action(cast(text_buffer_ptr))
    
    }

    /// Copies the currently-selected text to a clipboard.
    func copy(clipboard: ClipboardProtocol) {
        gtk_text_buffer_copy_clipboard(cast(text_buffer_ptr), cast(clipboard.ptr))
    
    }

    /// This is a convenience function which simply creates a child anchor
    /// with `gtk_text_child_anchor_new()` and inserts it into the buffer
    /// with `gtk_text_buffer_insert_child_anchor()`. The new anchor is
    /// owned by the buffer; no reference count is returned to
    /// the caller of `gtk_text_buffer_create_child_anchor()`.
    func createChildAnchor(iter: TextIterProtocol) -> UnsafeMutablePointer<GtkTextChildAnchor>! {
        let rv = gtk_text_buffer_create_child_anchor(cast(text_buffer_ptr), cast(iter.ptr))
        return cast(rv)
    }

    /// Creates a mark at position `where`. If `mark_name` is `nil`, the mark
    /// is anonymous; otherwise, the mark can be retrieved by name using
    /// `gtk_text_buffer_get_mark()`. If a mark has left gravity, and text is
    /// inserted at the mark’s current location, the mark will be moved to
    /// the left of the newly-inserted text. If the mark has right gravity
    /// (`left_gravity` = `false`), the mark will end up on the right of
    /// newly-inserted text. The standard left-to-right cursor is a mark
    /// with right gravity (when you type, the cursor stays on the right
    /// side of the text you’re typing).
    /// 
    /// The caller of this function does not own a
    /// reference to the returned `GtkTextMark`, so you can ignore the
    /// return value if you like. Marks are owned by the buffer and go
    /// away when the buffer does.
    /// 
    /// Emits the `GtkTextBuffer::mark`-set signal as notification of the mark's
    /// initial placement.
    func createMark(markName mark_name: UnsafePointer<gchar>, where_: TextIterProtocol, leftGravity left_gravity: Bool) -> UnsafeMutablePointer<GtkTextMark>! {
        let rv = gtk_text_buffer_create_mark(cast(text_buffer_ptr), mark_name, cast(where_.ptr), gboolean(left_gravity ? 1 : 0))
        return cast(rv)
    }


    // *** createTag() is not available because it has a varargs (...) parameter!


    /// Copies the currently-selected text to a clipboard, then deletes
    /// said text if it’s editable.
    func cut(clipboard: ClipboardProtocol, defaultEditable default_editable: Bool) {
        gtk_text_buffer_cut_clipboard(cast(text_buffer_ptr), cast(clipboard.ptr), gboolean(default_editable ? 1 : 0))
    
    }

    /// Deletes text between `start` and `end`. The order of `start` and `end`
    /// is not actually relevant; `gtk_text_buffer_delete()` will reorder
    /// them. This function actually emits the “delete-range” signal, and
    /// the default handler of that signal deletes the text. Because the
    /// buffer is modified, all outstanding iterators become invalid after
    /// calling this function; however, the `start` and `end` will be
    /// re-initialized to point to the location where text was deleted.
    func delete(start: TextIterProtocol, end: TextIterProtocol) {
        gtk_text_buffer_delete(cast(text_buffer_ptr), cast(start.ptr), cast(end.ptr))
    
    }

    /// Deletes all editable text in the given range.
    /// Calls `gtk_text_buffer_delete()` for each editable sub-range of
    /// [`start`,`end`). `start` and `end` are revalidated to point to
    /// the location of the last deleted range, or left untouched if
    /// no text was deleted.
    func deleteInteractive(startIter start_iter: TextIterProtocol, endIter end_iter: TextIterProtocol, defaultEditable default_editable: Bool) -> Bool {
        let rv = gtk_text_buffer_delete_interactive(cast(text_buffer_ptr), cast(start_iter.ptr), cast(end_iter.ptr), gboolean(default_editable ? 1 : 0))
        return Bool(rv != 0)
    }

    /// Deletes `mark`, so that it’s no longer located anywhere in the
    /// buffer. Removes the reference the buffer holds to the mark, so if
    /// you haven’t called `g_object_ref()` on the mark, it will be freed. Even
    /// if the mark isn’t freed, most operations on `mark` become
    /// invalid, until it gets added to a buffer again with
    /// `gtk_text_buffer_add_mark()`. Use `gtk_text_mark_get_deleted()` to
    /// find out if a mark has been removed from its buffer.
    /// The `GtkTextBuffer::mark`-deleted signal will be emitted as notification after
    /// the mark is deleted.
    func delete(mark: TextMarkProtocol) {
        gtk_text_buffer_delete_mark(cast(text_buffer_ptr), cast(mark.ptr))
    
    }

    /// Deletes the mark named `name`; the mark must exist. See
    /// `gtk_text_buffer_delete_mark()` for details.
    func deleteMarkBy(name: UnsafePointer<gchar>) {
        gtk_text_buffer_delete_mark_by_name(cast(text_buffer_ptr), name)
    
    }

    /// Deletes the range between the “insert” and “selection_bound” marks,
    /// that is, the currently-selected text. If `interactive` is `true`,
    /// the editability of the selection will be considered (users can’t delete
    /// uneditable text).
    func deleteSelection(interactive: Bool, defaultEditable default_editable: Bool) -> Bool {
        let rv = gtk_text_buffer_delete_selection(cast(text_buffer_ptr), gboolean(interactive ? 1 : 0), gboolean(default_editable ? 1 : 0))
        return Bool(rv != 0)
    }

    /// This function deserializes rich text in format `format` and inserts
    /// it at `iter`.
    /// 
    /// `formats` to be used must be registered using
    /// `gtk_text_buffer_register_deserialize_format()` or
    /// `gtk_text_buffer_register_deserialize_tagset()` beforehand.
    func deserialize(contentBuffer content_buffer: TextBufferProtocol, format: Gdk.Atom, iter: TextIterProtocol, data: UnsafePointer<UInt8>, length: Int) throws -> Bool {
        var error: Optional<UnsafeMutablePointer<GError>> = nil
        let rv = gtk_text_buffer_deserialize(cast(text_buffer_ptr), cast(content_buffer.ptr), cast(format.ptr), cast(iter.ptr), cast(data), gsize(length), &error)
        if let error = error {
                throw ErrorType(error)
        }
        return Bool(rv != 0)
    }

    /// This functions returns the value set with
    /// `gtk_text_buffer_deserialize_set_can_create_tags()`
    func deserializeGetCanCreateTags(format: Gdk.Atom) -> Bool {
        let rv = gtk_text_buffer_deserialize_get_can_create_tags(cast(text_buffer_ptr), cast(format.ptr))
        return Bool(rv != 0)
    }

    /// Use this function to allow a rich text deserialization function to
    /// create new tags in the receiving buffer. Note that using this
    /// function is almost always a bad idea, because the rich text
    /// functions you register should know how to map the rich text format
    /// they handler to your text buffers set of tags.
    /// 
    /// The ability of creating new (arbitrary!) tags in the receiving buffer
    /// is meant for special rich text formats like the internal one that
    /// is registered using `gtk_text_buffer_register_deserialize_tagset()`,
    /// because that format is essentially a dump of the internal structure
    /// of the source buffer, including its tag names.
    /// 
    /// You should allow creation of tags only if you know what you are
    /// doing, e.g. if you defined a tagset name for your application
    /// suite’s text buffers and you know that it’s fine to receive new
    /// tags from these buffers, because you know that your application can
    /// handle the newly created tags.
    func deserializeSetCanCreateTags(format: Gdk.Atom, canCreateTags can_create_tags: Bool) {
        gtk_text_buffer_deserialize_set_can_create_tags(cast(text_buffer_ptr), cast(format.ptr), gboolean(can_create_tags ? 1 : 0))
    
    }

    /// Should be paired with a call to `gtk_text_buffer_begin_user_action()`.
    /// See that function for a full explanation.
    func endUserAction() {
        gtk_text_buffer_end_user_action(cast(text_buffer_ptr))
    
    }

    /// Retrieves the first and last iterators in the buffer, i.e. the
    /// entire buffer lies within the range [`start`,`end`).
    func getBounds(start: TextIterProtocol, end: TextIterProtocol) {
        gtk_text_buffer_get_bounds(cast(text_buffer_ptr), cast(start.ptr), cast(end.ptr))
    
    }

    /// Gets the number of characters in the buffer; note that characters
    /// and bytes are not the same, you can’t e.g. expect the contents of
    /// the buffer in string form to be this many bytes long. The character
    /// count is cached, so this function is very fast.
    func getCharCount() -> CInt {
        let rv = gtk_text_buffer_get_char_count(cast(text_buffer_ptr))
        return CInt(rv)
    }

    /// This function returns the list of targets this text buffer can
    /// provide for copying and as DND source. The targets in the list are
    /// added with `info` values from the `GtkTextBufferTargetInfo` enum,
    /// using `gtk_target_list_add_rich_text_targets()` and
    /// `gtk_target_list_add_text_targets()`.
    func getCopyTargetList() -> UnsafeMutablePointer<GtkTargetList>! {
        let rv = gtk_text_buffer_get_copy_target_list(cast(text_buffer_ptr))
        return cast(rv)
    }

    /// This function returns the rich text deserialize formats registered
    /// with `buffer` using `gtk_text_buffer_register_deserialize_format()` or
    /// `gtk_text_buffer_register_deserialize_tagset()`
    func getDeserializeFormats(nFormats n_formats: UnsafeMutablePointer<CInt>) -> UnsafeMutablePointer<GdkAtom>! {
        let rv = gtk_text_buffer_get_deserialize_formats(cast(text_buffer_ptr), cast(n_formats))
        return cast(rv)
    }

    /// Initializes `iter` with the “end iterator,” one past the last valid
    /// character in the text buffer. If dereferenced with
    /// `gtk_text_iter_get_char()`, the end iterator has a character value of 0.
    /// The entire buffer lies in the range from the first position in
    /// the buffer (call `gtk_text_buffer_get_start_iter()` to get
    /// character position 0) to the end iterator.
    func getEnd(iter: TextIterProtocol) {
        gtk_text_buffer_get_end_iter(cast(text_buffer_ptr), cast(iter.ptr))
    
    }

    /// Indicates whether the buffer has some text currently selected.
    func getHasSelection() -> Bool {
        let rv = gtk_text_buffer_get_has_selection(cast(text_buffer_ptr))
        return Bool(rv != 0)
    }

    /// Returns the mark that represents the cursor (insertion point).
    /// Equivalent to calling `gtk_text_buffer_get_mark()` to get the mark
    /// named “insert”, but very slightly more efficient, and involves less
    /// typing.
    func getInsert() -> UnsafeMutablePointer<GtkTextMark>! {
        let rv = gtk_text_buffer_get_insert(cast(text_buffer_ptr))
        return cast(rv)
    }

    /// Obtains the location of `anchor` within `buffer`.
    func getIterAtChildAnchor(iter: TextIterProtocol, anchor: TextChildAnchorProtocol) {
        gtk_text_buffer_get_iter_at_child_anchor(cast(text_buffer_ptr), cast(iter.ptr), cast(anchor.ptr))
    
    }

    /// Initializes `iter` to the start of the given line. If `line_number` is greater
    /// than the number of lines in the `buffer`, the end iterator is returned.
    func getIterAtLine(iter: TextIterProtocol, lineNumber line_number: CInt) {
        gtk_text_buffer_get_iter_at_line(cast(text_buffer_ptr), cast(iter.ptr), gint(line_number))
    
    }

    /// Obtains an iterator pointing to `byte_index` within the given line.
    /// `byte_index` must be the start of a UTF-8 character. Note bytes, not
    /// characters; UTF-8 may encode one character as multiple bytes.
    /// 
    /// Before the 3.20 version, it was not allowed to pass an invalid location.
    /// 
    /// Since the 3.20 version, if `line_number` is greater than the number of lines
    /// in the `buffer`, the end iterator is returned. And if `byte_index` is off the
    /// end of the line, the iterator at the end of the line is returned.
    func getIterAtLineIndex(iter: TextIterProtocol, lineNumber line_number: CInt, byteIndex byte_index: CInt) {
        gtk_text_buffer_get_iter_at_line_index(cast(text_buffer_ptr), cast(iter.ptr), gint(line_number), gint(byte_index))
    
    }

    /// Obtains an iterator pointing to `char_offset` within the given line. Note
    /// characters, not bytes; UTF-8 may encode one character as multiple bytes.
    /// 
    /// Before the 3.20 version, it was not allowed to pass an invalid location.
    /// 
    /// Since the 3.20 version, if `line_number` is greater than the number of lines
    /// in the `buffer`, the end iterator is returned. And if `char_offset` is off the
    /// end of the line, the iterator at the end of the line is returned.
    func getIterAtLineOffset(iter: TextIterProtocol, lineNumber line_number: CInt, charOffset char_offset: CInt) {
        gtk_text_buffer_get_iter_at_line_offset(cast(text_buffer_ptr), cast(iter.ptr), gint(line_number), gint(char_offset))
    
    }

    /// Initializes `iter` with the current position of `mark`.
    func getIterAtMark(iter: TextIterProtocol, mark: TextMarkProtocol) {
        gtk_text_buffer_get_iter_at_mark(cast(text_buffer_ptr), cast(iter.ptr), cast(mark.ptr))
    
    }

    /// Initializes `iter` to a position `char_offset` chars from the start
    /// of the entire buffer. If `char_offset` is -1 or greater than the number
    /// of characters in the buffer, `iter` is initialized to the end iterator,
    /// the iterator one past the last valid character in the buffer.
    func getIterAtOffset(iter: TextIterProtocol, charOffset char_offset: CInt) {
        gtk_text_buffer_get_iter_at_offset(cast(text_buffer_ptr), cast(iter.ptr), gint(char_offset))
    
    }

    /// Obtains the number of lines in the buffer. This value is cached, so
    /// the function is very fast.
    func getLineCount() -> CInt {
        let rv = gtk_text_buffer_get_line_count(cast(text_buffer_ptr))
        return CInt(rv)
    }

    /// Returns the mark named `name` in buffer `buffer`, or `nil` if no such
    /// mark exists in the buffer.
    func getMark(name: UnsafePointer<gchar>) -> UnsafeMutablePointer<GtkTextMark>! {
        let rv = gtk_text_buffer_get_mark(cast(text_buffer_ptr), name)
        return cast(rv)
    }

    /// Indicates whether the buffer has been modified since the last call
    /// to `gtk_text_buffer_set_modified()` set the modification flag to
    /// `false`. Used for example to enable a “save” function in a text
    /// editor.
    func getModified() -> Bool {
        let rv = gtk_text_buffer_get_modified(cast(text_buffer_ptr))
        return Bool(rv != 0)
    }

    /// This function returns the list of targets this text buffer supports
    /// for pasting and as DND destination. The targets in the list are
    /// added with `info` values from the `GtkTextBufferTargetInfo` enum,
    /// using `gtk_target_list_add_rich_text_targets()` and
    /// `gtk_target_list_add_text_targets()`.
    func getPasteTargetList() -> UnsafeMutablePointer<GtkTargetList>! {
        let rv = gtk_text_buffer_get_paste_target_list(cast(text_buffer_ptr))
        return cast(rv)
    }

    /// Returns the mark that represents the selection bound.  Equivalent
    /// to calling `gtk_text_buffer_get_mark()` to get the mark named
    /// “selection_bound”, but very slightly more efficient, and involves
    /// less typing.
    /// 
    /// The currently-selected text in `buffer` is the region between the
    /// “selection_bound” and “insert” marks. If “selection_bound” and
    /// “insert” are in the same place, then there is no current selection.
    /// `gtk_text_buffer_get_selection_bounds()` is another convenient function
    /// for handling the selection, if you just want to know whether there’s a
    /// selection and what its bounds are.
    func getSelectionBound() -> UnsafeMutablePointer<GtkTextMark>! {
        let rv = gtk_text_buffer_get_selection_bound(cast(text_buffer_ptr))
        return cast(rv)
    }

    /// Returns `true` if some text is selected; places the bounds
    /// of the selection in `start` and `end` (if the selection has length 0,
    /// then `start` and `end` are filled in with the same value).
    /// `start` and `end` will be in ascending order. If `start` and `end` are
    /// NULL, then they are not filled in, but the return value still indicates
    /// whether text is selected.
    func getSelectionBounds(start: TextIterProtocol, end: TextIterProtocol) -> Bool {
        let rv = gtk_text_buffer_get_selection_bounds(cast(text_buffer_ptr), cast(start.ptr), cast(end.ptr))
        return Bool(rv != 0)
    }

    /// This function returns the rich text serialize formats registered
    /// with `buffer` using `gtk_text_buffer_register_serialize_format()` or
    /// `gtk_text_buffer_register_serialize_tagset()`
    func getSerializeFormats(nFormats n_formats: UnsafeMutablePointer<CInt>) -> UnsafeMutablePointer<GdkAtom>! {
        let rv = gtk_text_buffer_get_serialize_formats(cast(text_buffer_ptr), cast(n_formats))
        return cast(rv)
    }

    /// Returns the text in the range [`start`,`end`). Excludes undisplayed
    /// text (text marked with tags that set the invisibility attribute) if
    /// `include_hidden_chars` is `false`. The returned string includes a
    /// 0xFFFC character whenever the buffer contains
    /// embedded images, so byte and character indexes into
    /// the returned string do correspond to byte
    /// and character indexes into the buffer. Contrast with
    /// `gtk_text_buffer_get_text()`. Note that 0xFFFC can occur in normal
    /// text as well, so it is not a reliable indicator that a pixbuf or
    /// widget is in the buffer.
    func getSlice(start: TextIterProtocol, end: TextIterProtocol, includeHiddenChars include_hidden_chars: Bool) -> String! {
        let rv = gtk_text_buffer_get_slice(cast(text_buffer_ptr), cast(start.ptr), cast(end.ptr), gboolean(include_hidden_chars ? 1 : 0))
        return rv.map { String(cString: UnsafePointer<CChar>($0)) }
    }

    /// Initialized `iter` with the first position in the text buffer. This
    /// is the same as using `gtk_text_buffer_get_iter_at_offset()` to get
    /// the iter at character offset 0.
    func getStart(iter: TextIterProtocol) {
        gtk_text_buffer_get_start_iter(cast(text_buffer_ptr), cast(iter.ptr))
    
    }

    /// Get the `GtkTextTagTable` associated with this buffer.
    func getTagTable() -> UnsafeMutablePointer<GtkTextTagTable>! {
        let rv = gtk_text_buffer_get_tag_table(cast(text_buffer_ptr))
        return cast(rv)
    }

    /// Returns the text in the range [`start`,`end`). Excludes undisplayed
    /// text (text marked with tags that set the invisibility attribute) if
    /// `include_hidden_chars` is `false`. Does not include characters
    /// representing embedded images, so byte and character indexes into
    /// the returned string do not correspond to byte
    /// and character indexes into the buffer. Contrast with
    /// `gtk_text_buffer_get_slice()`.
    func getText(start: TextIterProtocol, end: TextIterProtocol, includeHiddenChars include_hidden_chars: Bool) -> String! {
        let rv = gtk_text_buffer_get_text(cast(text_buffer_ptr), cast(start.ptr), cast(end.ptr), gboolean(include_hidden_chars ? 1 : 0))
        return rv.map { String(cString: UnsafePointer<CChar>($0)) }
    }

    /// Inserts `len` bytes of `text` at position `iter`.  If `len` is -1,
    /// `text` must be nul-terminated and will be inserted in its
    /// entirety. Emits the “insert-text” signal; insertion actually occurs
    /// in the default handler for the signal. `iter` is invalidated when
    /// insertion occurs (because the buffer contents change), but the
    /// default signal handler revalidates it to point to the end of the
    /// inserted text.
    func insert(iter: TextIterProtocol, text: UnsafePointer<gchar>, len: CInt) {
        gtk_text_buffer_insert(cast(text_buffer_ptr), cast(iter.ptr), text, gint(len))
    
    }

    /// Simply calls `gtk_text_buffer_insert()`, using the current
    /// cursor position as the insertion point.
    func insertAtCursor(text: UnsafePointer<gchar>, len: CInt) {
        gtk_text_buffer_insert_at_cursor(cast(text_buffer_ptr), text, gint(len))
    
    }

    /// Inserts a child widget anchor into the text buffer at `iter`. The
    /// anchor will be counted as one character in character counts, and
    /// when obtaining the buffer contents as a string, will be represented
    /// by the Unicode “object replacement character” 0xFFFC. Note that the
    /// “slice” variants for obtaining portions of the buffer as a string
    /// include this character for child anchors, but the “text” variants do
    /// not. E.g. see `gtk_text_buffer_get_slice()` and
    /// `gtk_text_buffer_get_text()`. Consider
    /// `gtk_text_buffer_create_child_anchor()` as a more convenient
    /// alternative to this function. The buffer will add a reference to
    /// the anchor, so you can unref it after insertion.
    func insertChildAnchor(iter: TextIterProtocol, anchor: TextChildAnchorProtocol) {
        gtk_text_buffer_insert_child_anchor(cast(text_buffer_ptr), cast(iter.ptr), cast(anchor.ptr))
    
    }

    /// Like `gtk_text_buffer_insert()`, but the insertion will not occur if
    /// `iter` is at a non-editable location in the buffer. Usually you
    /// want to prevent insertions at ineditable locations if the insertion
    /// results from a user action (is interactive).
    /// 
    /// `default_editable` indicates the editability of text that doesn't
    /// have a tag affecting editability applied to it. Typically the
    /// result of `gtk_text_view_get_editable()` is appropriate here.
    func insertInteractive(iter: TextIterProtocol, text: UnsafePointer<gchar>, len: CInt, defaultEditable default_editable: Bool) -> Bool {
        let rv = gtk_text_buffer_insert_interactive(cast(text_buffer_ptr), cast(iter.ptr), text, gint(len), gboolean(default_editable ? 1 : 0))
        return Bool(rv != 0)
    }

    /// Calls `gtk_text_buffer_insert_interactive()` at the cursor
    /// position.
    /// 
    /// `default_editable` indicates the editability of text that doesn't
    /// have a tag affecting editability applied to it. Typically the
    /// result of `gtk_text_view_get_editable()` is appropriate here.
    func insertInteractiveAtCursor(text: UnsafePointer<gchar>, len: CInt, defaultEditable default_editable: Bool) -> Bool {
        let rv = gtk_text_buffer_insert_interactive_at_cursor(cast(text_buffer_ptr), text, gint(len), gboolean(default_editable ? 1 : 0))
        return Bool(rv != 0)
    }

    /// Inserts the text in `markup` at position `iter`. `markup` will be inserted
    /// in its entirety and must be nul-terminated and valid UTF-8. Emits the
    /// `GtkTextBuffer::insert`-text signal, possibly multiple times; insertion
    /// actually occurs in the default handler for the signal. `iter` will point
    /// to the end of the inserted text on return.
    func insertMarkup(iter: TextIterProtocol, markup: UnsafePointer<gchar>, len: CInt) {
        gtk_text_buffer_insert_markup(cast(text_buffer_ptr), cast(iter.ptr), markup, gint(len))
    
    }

    /// Inserts an image into the text buffer at `iter`. The image will be
    /// counted as one character in character counts, and when obtaining
    /// the buffer contents as a string, will be represented by the Unicode
    /// “object replacement character” 0xFFFC. Note that the “slice”
    /// variants for obtaining portions of the buffer as a string include
    /// this character for pixbufs, but the “text” variants do
    /// not. e.g. see `gtk_text_buffer_get_slice()` and
    /// `gtk_text_buffer_get_text()`.
    func insertPixbuf(iter: TextIterProtocol, pixbuf: PixbufProtocol) {
        gtk_text_buffer_insert_pixbuf(cast(text_buffer_ptr), cast(iter.ptr), cast(pixbuf.ptr))
    
    }

    /// Copies text, tags, and pixbufs between `start` and `end` (the order
    /// of `start` and `end` doesn’t matter) and inserts the copy at `iter`.
    /// Used instead of simply getting/inserting text because it preserves
    /// images and tags. If `start` and `end` are in a different buffer from
    /// `buffer`, the two buffers must share the same tag table.
    /// 
    /// Implemented via emissions of the insert_text and apply_tag signals,
    /// so expect those.
    func insertRange(iter: TextIterProtocol, start: TextIterProtocol, end: TextIterProtocol) {
        gtk_text_buffer_insert_range(cast(text_buffer_ptr), cast(iter.ptr), cast(start.ptr), cast(end.ptr))
    
    }

    /// Same as `gtk_text_buffer_insert_range()`, but does nothing if the
    /// insertion point isn’t editable. The `default_editable` parameter
    /// indicates whether the text is editable at `iter` if no tags
    /// enclosing `iter` affect editability. Typically the result of
    /// `gtk_text_view_get_editable()` is appropriate here.
    func insertRangeInteractive(iter: TextIterProtocol, start: TextIterProtocol, end: TextIterProtocol, defaultEditable default_editable: Bool) -> Bool {
        let rv = gtk_text_buffer_insert_range_interactive(cast(text_buffer_ptr), cast(iter.ptr), cast(start.ptr), cast(end.ptr), gboolean(default_editable ? 1 : 0))
        return Bool(rv != 0)
    }


    // *** insertWithTags() is not available because it has a varargs (...) parameter!



    // *** insertWithTagsByName() is not available because it has a varargs (...) parameter!


    /// Moves `mark` to the new location `where`. Emits the `GtkTextBuffer::mark`-set
    /// signal as notification of the move.
    func move(mark: TextMarkProtocol, where_: TextIterProtocol) {
        gtk_text_buffer_move_mark(cast(text_buffer_ptr), cast(mark.ptr), cast(where_.ptr))
    
    }

    /// Moves the mark named `name` (which must exist) to location `where`.
    /// See `gtk_text_buffer_move_mark()` for details.
    func moveMarkBy(name: UnsafePointer<gchar>, where_: TextIterProtocol) {
        gtk_text_buffer_move_mark_by_name(cast(text_buffer_ptr), name, cast(where_.ptr))
    
    }

    /// Pastes the contents of a clipboard. If `override_location` is `nil`, the
    /// pasted text will be inserted at the cursor position, or the buffer selection
    /// will be replaced if the selection is non-empty.
    /// 
    /// Note: pasting is asynchronous, that is, we’ll ask for the paste data and
    /// return, and at some point later after the main loop runs, the paste data will
    /// be inserted.
    func paste(clipboard: ClipboardProtocol, overrideLocation override_location: TextIterProtocol, defaultEditable default_editable: Bool) {
        gtk_text_buffer_paste_clipboard(cast(text_buffer_ptr), cast(clipboard.ptr), cast(override_location.ptr), gboolean(default_editable ? 1 : 0))
    
    }

    /// This function moves the “insert” and “selection_bound” marks
    /// simultaneously.  If you move them to the same place in two steps
    /// with `gtk_text_buffer_move_mark()`, you will temporarily select a
    /// region in between their old and new locations, which can be pretty
    /// inefficient since the temporarily-selected region will force stuff
    /// to be recalculated. This function moves them as a unit, which can
    /// be optimized.
    func placeCursor(where_: TextIterProtocol) {
        gtk_text_buffer_place_cursor(cast(text_buffer_ptr), cast(where_.ptr))
    
    }

    /// This function registers a rich text deserialization `function` along with
    /// its `mime_type` with the passed `buffer`.
    func registerDeserializeFormat(mimeType mime_type: UnsafePointer<gchar>, function: @escaping TextBufferDeserializeFunc, userData user_data: UnsafeMutableRawPointer, userDataDestroy user_data_destroy: @escaping GLib.DestroyNotify) -> GdkAtom! {
        let rv = gtk_text_buffer_register_deserialize_format(cast(text_buffer_ptr), mime_type, function, cast(user_data), user_data_destroy)
        return rv
    }

    /// This function registers GTK+’s internal rich text serialization
    /// format with the passed `buffer`. See
    /// `gtk_text_buffer_register_serialize_tagset()` for details.
    func registerDeserializeTagset(tagsetName tagset_name: UnsafePointer<gchar>) -> GdkAtom! {
        let rv = gtk_text_buffer_register_deserialize_tagset(cast(text_buffer_ptr), tagset_name)
        return rv
    }

    /// This function registers a rich text serialization `function` along with
    /// its `mime_type` with the passed `buffer`.
    func registerSerializeFormat(mimeType mime_type: UnsafePointer<gchar>, function: @escaping TextBufferSerializeFunc, userData user_data: UnsafeMutableRawPointer, userDataDestroy user_data_destroy: @escaping GLib.DestroyNotify) -> GdkAtom! {
        let rv = gtk_text_buffer_register_serialize_format(cast(text_buffer_ptr), mime_type, function, cast(user_data), user_data_destroy)
        return rv
    }

    /// This function registers GTK+’s internal rich text serialization
    /// format with the passed `buffer`. The internal format does not comply
    /// to any standard rich text format and only works between `GtkTextBuffer`
    /// instances. It is capable of serializing all of a text buffer’s tags
    /// and embedded pixbufs.
    /// 
    /// This function is just a wrapper around
    /// `gtk_text_buffer_register_serialize_format()`. The mime type used
    /// for registering is “application/x-gtk-text-buffer-rich-text”, or
    /// “application/x-gtk-text-buffer-rich-text;format=`tagset_name`” if a
    /// `tagset_name` was passed.
    /// 
    /// The `tagset_name` can be used to restrict the transfer of rich text
    /// to buffers with compatible sets of tags, in order to avoid unknown
    /// tags from being pasted. It is probably the common case to pass an
    /// identifier != `nil` here, since the `nil` tagset requires the
    /// receiving buffer to deal with with pasting of arbitrary tags.
    func registerSerializeTagset(tagsetName tagset_name: UnsafePointer<gchar>) -> GdkAtom! {
        let rv = gtk_text_buffer_register_serialize_tagset(cast(text_buffer_ptr), tagset_name)
        return rv
    }

    /// Removes all tags in the range between `start` and `end`.  Be careful
    /// with this function; it could remove tags added in code unrelated to
    /// the code you’re currently writing. That is, using this function is
    /// probably a bad idea if you have two or more unrelated code sections
    /// that add tags.
    func removeAllTags(start: TextIterProtocol, end: TextIterProtocol) {
        gtk_text_buffer_remove_all_tags(cast(text_buffer_ptr), cast(start.ptr), cast(end.ptr))
    
    }

    /// Removes a `GtkClipboard` added with
    /// `gtk_text_buffer_add_selection_clipboard()`.
    func removeSelection(clipboard: ClipboardProtocol) {
        gtk_text_buffer_remove_selection_clipboard(cast(text_buffer_ptr), cast(clipboard.ptr))
    
    }

    /// Emits the “remove-tag” signal. The default handler for the signal
    /// removes all occurrences of `tag` from the given range. `start` and
    /// `end` don’t have to be in order.
    func remove(tag: TextTagProtocol, start: TextIterProtocol, end: TextIterProtocol) {
        gtk_text_buffer_remove_tag(cast(text_buffer_ptr), cast(tag.ptr), cast(start.ptr), cast(end.ptr))
    
    }

    /// Calls `gtk_text_tag_table_lookup()` on the buffer’s tag table to
    /// get a `GtkTextTag`, then calls `gtk_text_buffer_remove_tag()`.
    func removeTagBy(name: UnsafePointer<gchar>, start: TextIterProtocol, end: TextIterProtocol) {
        gtk_text_buffer_remove_tag_by_name(cast(text_buffer_ptr), name, cast(start.ptr), cast(end.ptr))
    
    }

    /// This function moves the “insert” and “selection_bound” marks
    /// simultaneously.  If you move them in two steps
    /// with `gtk_text_buffer_move_mark()`, you will temporarily select a
    /// region in between their old and new locations, which can be pretty
    /// inefficient since the temporarily-selected region will force stuff
    /// to be recalculated. This function moves them as a unit, which can
    /// be optimized.
    func selectRange(ins: TextIterProtocol, bound: TextIterProtocol) {
        gtk_text_buffer_select_range(cast(text_buffer_ptr), cast(ins.ptr), cast(bound.ptr))
    
    }

    /// This function serializes the portion of text between `start`
    /// and `end` in the rich text format represented by `format`.
    /// 
    /// `formats` to be used must be registered using
    /// `gtk_text_buffer_register_serialize_format()` or
    /// `gtk_text_buffer_register_serialize_tagset()` beforehand.
    func serialize(contentBuffer content_buffer: TextBufferProtocol, format: Gdk.Atom, start: TextIterProtocol, end: TextIterProtocol, length: UnsafeMutablePointer<Int>) -> UnsafeMutablePointer<UInt8>! {
        let rv = gtk_text_buffer_serialize(cast(text_buffer_ptr), cast(content_buffer.ptr), cast(format.ptr), cast(start.ptr), cast(end.ptr), cast(length))
        return cast(rv)
    }

    /// Used to keep track of whether the buffer has been modified since the
    /// last time it was saved. Whenever the buffer is saved to disk, call
    /// gtk_text_buffer_set_modified (`buffer`, FALSE). When the buffer is modified,
    /// it will automatically toggled on the modified bit again. When the modified
    /// bit flips, the buffer emits the `GtkTextBuffer::modified`-changed signal.
    func setModified(setting: Bool) {
        gtk_text_buffer_set_modified(cast(text_buffer_ptr), gboolean(setting ? 1 : 0))
    
    }

    /// Deletes current contents of `buffer`, and inserts `text` instead. If
    /// `len` is -1, `text` must be nul-terminated. `text` must be valid UTF-8.
    func set(text: UnsafePointer<gchar>, len: CInt) {
        gtk_text_buffer_set_text(cast(text_buffer_ptr), text, gint(len))
    
    }

    /// This function unregisters a rich text format that was previously
    /// registered using `gtk_text_buffer_register_deserialize_format()` or
    /// `gtk_text_buffer_register_deserialize_tagset()`.
    func unregisterDeserialize(format: Gdk.Atom) {
        gtk_text_buffer_unregister_deserialize_format(cast(text_buffer_ptr), cast(format.ptr))
    
    }

    /// This function unregisters a rich text format that was previously
    /// registered using `gtk_text_buffer_register_serialize_format()` or
    /// `gtk_text_buffer_register_serialize_tagset()`
    func unregisterSerialize(format: Gdk.Atom) {
        gtk_text_buffer_unregister_serialize_format(cast(text_buffer_ptr), cast(format.ptr))
    
    }

    /// Determines if any of the targets in `targets` can be used to
    /// provide rich text.
    func targetsIncludeRichText(targets: UnsafeMutablePointer<GdkAtom>, nTargets n_targets: CInt) -> Bool {
        let rv = gtk_targets_include_rich_text(cast(targets), gint(n_targets), cast(text_buffer_ptr))
        return Bool(rv != 0)
    }
    /// Gets the number of characters in the buffer; note that characters
    /// and bytes are not the same, you can’t e.g. expect the contents of
    /// the buffer in string form to be this many bytes long. The character
    /// count is cached, so this function is very fast.
    var charCount: CInt {
        /// Gets the number of characters in the buffer; note that characters
        /// and bytes are not the same, you can’t e.g. expect the contents of
        /// the buffer in string form to be this many bytes long. The character
        /// count is cached, so this function is very fast.
        get {
            let rv = gtk_text_buffer_get_char_count(cast(text_buffer_ptr))
            return CInt(rv)
        }
    }

    /// This function returns the list of targets this text buffer can
    /// provide for copying and as DND source. The targets in the list are
    /// added with `info` values from the `GtkTextBufferTargetInfo` enum,
    /// using `gtk_target_list_add_rich_text_targets()` and
    /// `gtk_target_list_add_text_targets()`.
    var copyTargetList: UnsafeMutablePointer<GtkTargetList>! {
        /// This function returns the list of targets this text buffer can
        /// provide for copying and as DND source. The targets in the list are
        /// added with `info` values from the `GtkTextBufferTargetInfo` enum,
        /// using `gtk_target_list_add_rich_text_targets()` and
        /// `gtk_target_list_add_text_targets()`.
        get {
            let rv = gtk_text_buffer_get_copy_target_list(cast(text_buffer_ptr))
            return cast(rv)
        }
    }

    /// Indicates whether the buffer has some text currently selected.
    var hasSelection: Bool {
        /// Indicates whether the buffer has some text currently selected.
        get {
            let rv = gtk_text_buffer_get_has_selection(cast(text_buffer_ptr))
            return Bool(rv != 0)
        }
    }

    /// Returns the mark that represents the cursor (insertion point).
    /// Equivalent to calling `gtk_text_buffer_get_mark()` to get the mark
    /// named “insert”, but very slightly more efficient, and involves less
    /// typing.
    var insert: UnsafeMutablePointer<GtkTextMark>! {
        /// Returns the mark that represents the cursor (insertion point).
        /// Equivalent to calling `gtk_text_buffer_get_mark()` to get the mark
        /// named “insert”, but very slightly more efficient, and involves less
        /// typing.
        get {
            let rv = gtk_text_buffer_get_insert(cast(text_buffer_ptr))
            return cast(rv)
        }
    }

    /// Obtains the number of lines in the buffer. This value is cached, so
    /// the function is very fast.
    var lineCount: CInt {
        /// Obtains the number of lines in the buffer. This value is cached, so
        /// the function is very fast.
        get {
            let rv = gtk_text_buffer_get_line_count(cast(text_buffer_ptr))
            return CInt(rv)
        }
    }

    /// Indicates whether the buffer has been modified since the last call
    /// to `gtk_text_buffer_set_modified()` set the modification flag to
    /// `false`. Used for example to enable a “save” function in a text
    /// editor.
    var modified: Bool {
        /// Indicates whether the buffer has been modified since the last call
        /// to `gtk_text_buffer_set_modified()` set the modification flag to
        /// `false`. Used for example to enable a “save” function in a text
        /// editor.
        get {
            let rv = gtk_text_buffer_get_modified(cast(text_buffer_ptr))
            return Bool(rv != 0)
        }
        /// Used to keep track of whether the buffer has been modified since the
        /// last time it was saved. Whenever the buffer is saved to disk, call
        /// gtk_text_buffer_set_modified (`buffer`, FALSE). When the buffer is modified,
        /// it will automatically toggled on the modified bit again. When the modified
        /// bit flips, the buffer emits the `GtkTextBuffer::modified`-changed signal.
        nonmutating set {
            gtk_text_buffer_set_modified(cast(text_buffer_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// This function returns the list of targets this text buffer supports
    /// for pasting and as DND destination. The targets in the list are
    /// added with `info` values from the `GtkTextBufferTargetInfo` enum,
    /// using `gtk_target_list_add_rich_text_targets()` and
    /// `gtk_target_list_add_text_targets()`.
    var pasteTargetList: UnsafeMutablePointer<GtkTargetList>! {
        /// This function returns the list of targets this text buffer supports
        /// for pasting and as DND destination. The targets in the list are
        /// added with `info` values from the `GtkTextBufferTargetInfo` enum,
        /// using `gtk_target_list_add_rich_text_targets()` and
        /// `gtk_target_list_add_text_targets()`.
        get {
            let rv = gtk_text_buffer_get_paste_target_list(cast(text_buffer_ptr))
            return cast(rv)
        }
    }

    /// Returns the mark that represents the selection bound.  Equivalent
    /// to calling `gtk_text_buffer_get_mark()` to get the mark named
    /// “selection_bound”, but very slightly more efficient, and involves
    /// less typing.
    /// 
    /// The currently-selected text in `buffer` is the region between the
    /// “selection_bound” and “insert” marks. If “selection_bound” and
    /// “insert” are in the same place, then there is no current selection.
    /// `gtk_text_buffer_get_selection_bounds()` is another convenient function
    /// for handling the selection, if you just want to know whether there’s a
    /// selection and what its bounds are.
    var selectionBound: UnsafeMutablePointer<GtkTextMark>! {
        /// Returns the mark that represents the selection bound.  Equivalent
        /// to calling `gtk_text_buffer_get_mark()` to get the mark named
        /// “selection_bound”, but very slightly more efficient, and involves
        /// less typing.
        /// 
        /// The currently-selected text in `buffer` is the region between the
        /// “selection_bound” and “insert” marks. If “selection_bound” and
        /// “insert” are in the same place, then there is no current selection.
        /// `gtk_text_buffer_get_selection_bounds()` is another convenient function
        /// for handling the selection, if you just want to know whether there’s a
        /// selection and what its bounds are.
        get {
            let rv = gtk_text_buffer_get_selection_bound(cast(text_buffer_ptr))
            return cast(rv)
        }
    }

    /// Get the `GtkTextTagTable` associated with this buffer.
    var tagTable: UnsafeMutablePointer<GtkTextTagTable>! {
        /// Get the `GtkTextTagTable` associated with this buffer.
        get {
            let rv = gtk_text_buffer_get_tag_table(cast(text_buffer_ptr))
            return cast(rv)
        }
    }
}



// MARK: - TextCellAccessible Class

/// The `TextCellAccessibleProtocol` protocol exposes the methods and properties of an underlying `GtkTextCellAccessible` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextCellAccessible`.
/// Alternatively, use `TextCellAccessibleRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///

public protocol TextCellAccessibleProtocol: RendererCellAccessibleProtocol, Atk.TextProtocol {
    /// Untyped pointer to the underlying `GtkTextCellAccessible` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkTextCellAccessible` instance.
    var text_cell_accessible_ptr: UnsafeMutablePointer<GtkTextCellAccessible> { get }
}

/// The `TextCellAccessibleRef` type acts as a lightweight Swift reference to an underlying `GtkTextCellAccessible` instance.
/// It exposes methods that can operate on this data type through `TextCellAccessibleProtocol` conformance.
/// Use `TextCellAccessibleRef` only as an `unowned` reference to an existing `GtkTextCellAccessible` instance.
///

public struct TextCellAccessibleRef: TextCellAccessibleProtocol {
    /// Untyped pointer to the underlying `GtkTextCellAccessible` instance.
    /// For type-safe access, use the generated, typed pointer `text_cell_accessible_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension TextCellAccessibleRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkTextCellAccessible>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `TextCellAccessibleProtocol`
    init<T: TextCellAccessibleProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextCellAccessibleProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextCellAccessibleProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextCellAccessibleProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextCellAccessibleProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextCellAccessibleProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `TextCellAccessible` type acts as a reference-counted owner of an underlying `GtkTextCellAccessible` instance.
/// It provides the methods that can operate on this data type through `TextCellAccessibleProtocol` conformance.
/// Use `TextCellAccessible` as a strong reference or owner of a `GtkTextCellAccessible` instance.
///

open class TextCellAccessible: RendererCellAccessible, TextCellAccessibleProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `TextCellAccessible` instance.
    public init(_ op: UnsafeMutablePointer<GtkTextCellAccessible>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `TextCellAccessibleProtocol`
    /// Will retain `GtkTextCellAccessible`.
    public convenience init<T: TextCellAccessibleProtocol>(_ other: T) {
        self.init(cast(other.text_cell_accessible_ptr))
        g_object_ref(cast(text_cell_accessible_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextCellAccessibleProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkTextCellAccessible.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextCellAccessibleProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkTextCellAccessible.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextCellAccessibleProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkTextCellAccessible.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextCellAccessibleProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkTextCellAccessible>(opaquePointer))
    }



}

public enum TextCellAccessiblePropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case renderer = "renderer"
    case widget = "widget"
}

public extension TextCellAccessibleProtocol {
    /// Bind a `TextCellAccessiblePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TextCellAccessiblePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(text_cell_accessible_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum TextCellAccessibleSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyRenderer = "notify::renderer"
    case notifyWidget = "notify::widget"
}

public extension TextCellAccessibleProtocol {
    /// Connect a `TextCellAccessibleSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: TextCellAccessibleSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(text_cell_accessible_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension TextCellAccessibleProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextCellAccessible` instance.
    var text_cell_accessible_ptr: UnsafeMutablePointer<GtkTextCellAccessible> { return ptr.assumingMemoryBound(to: GtkTextCellAccessible.self) }

}



// MARK: - TextChildAnchor Class

/// The `TextChildAnchorProtocol` protocol exposes the methods and properties of an underlying `GtkTextChildAnchor` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextChildAnchor`.
/// Alternatively, use `TextChildAnchorRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkTextChildAnchor` is a spot in the buffer where child widgets can
/// be “anchored” (inserted inline, as if they were characters). The anchor
/// can have multiple widgets anchored, to allow for multiple views.
public protocol TextChildAnchorProtocol: GLibObject.ObjectProtocol {
    /// Untyped pointer to the underlying `GtkTextChildAnchor` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkTextChildAnchor` instance.
    var text_child_anchor_ptr: UnsafeMutablePointer<GtkTextChildAnchor> { get }
}

/// The `TextChildAnchorRef` type acts as a lightweight Swift reference to an underlying `GtkTextChildAnchor` instance.
/// It exposes methods that can operate on this data type through `TextChildAnchorProtocol` conformance.
/// Use `TextChildAnchorRef` only as an `unowned` reference to an existing `GtkTextChildAnchor` instance.
///
/// A `GtkTextChildAnchor` is a spot in the buffer where child widgets can
/// be “anchored” (inserted inline, as if they were characters). The anchor
/// can have multiple widgets anchored, to allow for multiple views.
public struct TextChildAnchorRef: TextChildAnchorProtocol {
    /// Untyped pointer to the underlying `GtkTextChildAnchor` instance.
    /// For type-safe access, use the generated, typed pointer `text_child_anchor_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension TextChildAnchorRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkTextChildAnchor>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `TextChildAnchorProtocol`
    init<T: TextChildAnchorProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkTextChildAnchor`. Usually you would then insert
    /// it into a `GtkTextBuffer` with `gtk_text_buffer_insert_child_anchor()`.
    /// To perform the creation and insertion in one step, use the
    /// convenience function `gtk_text_buffer_create_child_anchor()`.
    init() {
        let rv = gtk_text_child_anchor_new()
        self.init(cast(rv))
    }
}

/// The `TextChildAnchor` type acts as a reference-counted owner of an underlying `GtkTextChildAnchor` instance.
/// It provides the methods that can operate on this data type through `TextChildAnchorProtocol` conformance.
/// Use `TextChildAnchor` as a strong reference or owner of a `GtkTextChildAnchor` instance.
///
/// A `GtkTextChildAnchor` is a spot in the buffer where child widgets can
/// be “anchored” (inserted inline, as if they were characters). The anchor
/// can have multiple widgets anchored, to allow for multiple views.
open class TextChildAnchor: GLibObject.Object, TextChildAnchorProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `TextChildAnchor` instance.
    public init(_ op: UnsafeMutablePointer<GtkTextChildAnchor>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `TextChildAnchorProtocol`
    /// Will retain `GtkTextChildAnchor`.
    public convenience init<T: TextChildAnchorProtocol>(_ other: T) {
        self.init(cast(other.text_child_anchor_ptr))
        g_object_ref(cast(text_child_anchor_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkTextChildAnchor.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkTextChildAnchor.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkTextChildAnchor.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkTextChildAnchor>(opaquePointer))
    }

    /// Creates a new `GtkTextChildAnchor`. Usually you would then insert
    /// it into a `GtkTextBuffer` with `gtk_text_buffer_insert_child_anchor()`.
    /// To perform the creation and insertion in one step, use the
    /// convenience function `gtk_text_buffer_create_child_anchor()`.
    public convenience init() {
        let rv = gtk_text_child_anchor_new()
        self.init(cast(rv))
    }


}

// MARK: - no TextChildAnchor properties

public enum TextChildAnchorSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

public extension TextChildAnchorProtocol {
    /// Connect a `TextChildAnchorSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: TextChildAnchorSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(text_child_anchor_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension TextChildAnchorProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextChildAnchor` instance.
    var text_child_anchor_ptr: UnsafeMutablePointer<GtkTextChildAnchor> { return ptr.assumingMemoryBound(to: GtkTextChildAnchor.self) }

    /// Determines whether a child anchor has been deleted from
    /// the buffer. Keep in mind that the child anchor will be
    /// unreferenced when removed from the buffer, so you need to
    /// hold your own reference (with `g_object_ref()`) if you plan
    /// to use this function — otherwise all deleted child anchors
    /// will also be finalized.
    func getDeleted() -> Bool {
        let rv = gtk_text_child_anchor_get_deleted(cast(text_child_anchor_ptr))
        return Bool(rv != 0)
    }

    /// Gets a list of all widgets anchored at this child anchor.
    /// The returned list should be freed with `g_list_free()`.
    func getWidgets() -> UnsafeMutablePointer<GList>! {
        let rv = gtk_text_child_anchor_get_widgets(cast(text_child_anchor_ptr))
        return cast(rv)
    }
    /// Determines whether a child anchor has been deleted from
    /// the buffer. Keep in mind that the child anchor will be
    /// unreferenced when removed from the buffer, so you need to
    /// hold your own reference (with `g_object_ref()`) if you plan
    /// to use this function — otherwise all deleted child anchors
    /// will also be finalized.
    var deleted: Bool {
        /// Determines whether a child anchor has been deleted from
        /// the buffer. Keep in mind that the child anchor will be
        /// unreferenced when removed from the buffer, so you need to
        /// hold your own reference (with `g_object_ref()`) if you plan
        /// to use this function — otherwise all deleted child anchors
        /// will also be finalized.
        get {
            let rv = gtk_text_child_anchor_get_deleted(cast(text_child_anchor_ptr))
            return Bool(rv != 0)
        }
    }

    /// Gets a list of all widgets anchored at this child anchor.
    /// The returned list should be freed with `g_list_free()`.
    var widgets: UnsafeMutablePointer<GList>! {
        /// Gets a list of all widgets anchored at this child anchor.
        /// The returned list should be freed with `g_list_free()`.
        get {
            let rv = gtk_text_child_anchor_get_widgets(cast(text_child_anchor_ptr))
            return cast(rv)
        }
    }
}



// MARK: - TextMark Class

/// The `TextMarkProtocol` protocol exposes the methods and properties of an underlying `GtkTextMark` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextMark`.
/// Alternatively, use `TextMarkRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and data
/// types related to the text widget and how they work together.
/// 
/// A `GtkTextMark` is like a bookmark in a text buffer; it preserves a position in
/// the text. You can convert the mark to an iterator using
/// `gtk_text_buffer_get_iter_at_mark()`. Unlike iterators, marks remain valid across
/// buffer mutations, because their behavior is defined when text is inserted or
/// deleted. When text containing a mark is deleted, the mark remains in the
/// position originally occupied by the deleted text. When text is inserted at a
/// mark, a mark with “left gravity” will be moved to the
/// beginning of the newly-inserted text, and a mark with “right
/// gravity” will be moved to the end.
/// 
/// Note that “left” and “right” here refer to logical direction (left
/// is the toward the start of the buffer); in some languages such as
/// Hebrew the logically-leftmost text is not actually on the left when
/// displayed.
/// 
/// Marks are reference counted, but the reference count only controls the validity
/// of the memory; marks can be deleted from the buffer at any time with
/// `gtk_text_buffer_delete_mark()`. Once deleted from the buffer, a mark is
/// essentially useless.
/// 
/// Marks optionally have names; these can be convenient to avoid passing the
/// `GtkTextMark` object around.
/// 
/// Marks are typically created using the `gtk_text_buffer_create_mark()` function.
public protocol TextMarkProtocol: GLibObject.ObjectProtocol {
    /// Untyped pointer to the underlying `GtkTextMark` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkTextMark` instance.
    var text_mark_ptr: UnsafeMutablePointer<GtkTextMark> { get }
}

/// The `TextMarkRef` type acts as a lightweight Swift reference to an underlying `GtkTextMark` instance.
/// It exposes methods that can operate on this data type through `TextMarkProtocol` conformance.
/// Use `TextMarkRef` only as an `unowned` reference to an existing `GtkTextMark` instance.
///
/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and data
/// types related to the text widget and how they work together.
/// 
/// A `GtkTextMark` is like a bookmark in a text buffer; it preserves a position in
/// the text. You can convert the mark to an iterator using
/// `gtk_text_buffer_get_iter_at_mark()`. Unlike iterators, marks remain valid across
/// buffer mutations, because their behavior is defined when text is inserted or
/// deleted. When text containing a mark is deleted, the mark remains in the
/// position originally occupied by the deleted text. When text is inserted at a
/// mark, a mark with “left gravity” will be moved to the
/// beginning of the newly-inserted text, and a mark with “right
/// gravity” will be moved to the end.
/// 
/// Note that “left” and “right” here refer to logical direction (left
/// is the toward the start of the buffer); in some languages such as
/// Hebrew the logically-leftmost text is not actually on the left when
/// displayed.
/// 
/// Marks are reference counted, but the reference count only controls the validity
/// of the memory; marks can be deleted from the buffer at any time with
/// `gtk_text_buffer_delete_mark()`. Once deleted from the buffer, a mark is
/// essentially useless.
/// 
/// Marks optionally have names; these can be convenient to avoid passing the
/// `GtkTextMark` object around.
/// 
/// Marks are typically created using the `gtk_text_buffer_create_mark()` function.
public struct TextMarkRef: TextMarkProtocol {
    /// Untyped pointer to the underlying `GtkTextMark` instance.
    /// For type-safe access, use the generated, typed pointer `text_mark_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension TextMarkRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkTextMark>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `TextMarkProtocol`
    init<T: TextMarkProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a text mark. Add it to a buffer using `gtk_text_buffer_add_mark()`.
    /// If `name` is `nil`, the mark is anonymous; otherwise, the mark can be
    /// retrieved by name using `gtk_text_buffer_get_mark()`. If a mark has left
    /// gravity, and text is inserted at the mark’s current location, the mark
    /// will be moved to the left of the newly-inserted text. If the mark has
    /// right gravity (`left_gravity` = `false`), the mark will end up on the
    /// right of newly-inserted text. The standard left-to-right cursor is a
    /// mark with right gravity (when you type, the cursor stays on the right
    /// side of the text you’re typing).
    init( name: UnsafePointer<gchar>, leftGravity left_gravity: Bool) {
        let rv = gtk_text_mark_new(name, gboolean(left_gravity ? 1 : 0))
        self.init(cast(rv))
    }
}

/// The `TextMark` type acts as a reference-counted owner of an underlying `GtkTextMark` instance.
/// It provides the methods that can operate on this data type through `TextMarkProtocol` conformance.
/// Use `TextMark` as a strong reference or owner of a `GtkTextMark` instance.
///
/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and data
/// types related to the text widget and how they work together.
/// 
/// A `GtkTextMark` is like a bookmark in a text buffer; it preserves a position in
/// the text. You can convert the mark to an iterator using
/// `gtk_text_buffer_get_iter_at_mark()`. Unlike iterators, marks remain valid across
/// buffer mutations, because their behavior is defined when text is inserted or
/// deleted. When text containing a mark is deleted, the mark remains in the
/// position originally occupied by the deleted text. When text is inserted at a
/// mark, a mark with “left gravity” will be moved to the
/// beginning of the newly-inserted text, and a mark with “right
/// gravity” will be moved to the end.
/// 
/// Note that “left” and “right” here refer to logical direction (left
/// is the toward the start of the buffer); in some languages such as
/// Hebrew the logically-leftmost text is not actually on the left when
/// displayed.
/// 
/// Marks are reference counted, but the reference count only controls the validity
/// of the memory; marks can be deleted from the buffer at any time with
/// `gtk_text_buffer_delete_mark()`. Once deleted from the buffer, a mark is
/// essentially useless.
/// 
/// Marks optionally have names; these can be convenient to avoid passing the
/// `GtkTextMark` object around.
/// 
/// Marks are typically created using the `gtk_text_buffer_create_mark()` function.
open class TextMark: GLibObject.Object, TextMarkProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `TextMark` instance.
    public init(_ op: UnsafeMutablePointer<GtkTextMark>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `TextMarkProtocol`
    /// Will retain `GtkTextMark`.
    public convenience init<T: TextMarkProtocol>(_ other: T) {
        self.init(cast(other.text_mark_ptr))
        g_object_ref(cast(text_mark_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkTextMark.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkTextMark.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkTextMark.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkTextMark>(opaquePointer))
    }

    /// Creates a text mark. Add it to a buffer using `gtk_text_buffer_add_mark()`.
    /// If `name` is `nil`, the mark is anonymous; otherwise, the mark can be
    /// retrieved by name using `gtk_text_buffer_get_mark()`. If a mark has left
    /// gravity, and text is inserted at the mark’s current location, the mark
    /// will be moved to the left of the newly-inserted text. If the mark has
    /// right gravity (`left_gravity` = `false`), the mark will end up on the
    /// right of newly-inserted text. The standard left-to-right cursor is a
    /// mark with right gravity (when you type, the cursor stays on the right
    /// side of the text you’re typing).
    public convenience init( name: UnsafePointer<gchar>, leftGravity left_gravity: Bool) {
        let rv = gtk_text_mark_new(name, gboolean(left_gravity ? 1 : 0))
        self.init(cast(rv))
    }


}

public enum TextMarkPropertyName: String, PropertyNameProtocol {
    /// Whether the mark has left gravity. When text is inserted at the mark’s
    /// current location, if the mark has left gravity it will be moved
    /// to the left of the newly-inserted text, otherwise to the right.
    case leftGravity = "left-gravity"
    /// The name of the mark or `nil` if the mark is anonymous.
    case name = "name"
}

public extension TextMarkProtocol {
    /// Bind a `TextMarkPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TextMarkPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(text_mark_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum TextMarkSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Whether the mark has left gravity. When text is inserted at the mark’s
    /// current location, if the mark has left gravity it will be moved
    /// to the left of the newly-inserted text, otherwise to the right.
    case notifyLeftGravity = "notify::left-gravity"
    /// The name of the mark or `nil` if the mark is anonymous.
    case notifyName = "notify::name"
}

public extension TextMarkProtocol {
    /// Connect a `TextMarkSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: TextMarkSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(text_mark_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension TextMarkProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextMark` instance.
    var text_mark_ptr: UnsafeMutablePointer<GtkTextMark> { return ptr.assumingMemoryBound(to: GtkTextMark.self) }

    /// Gets the buffer this mark is located inside,
    /// or `nil` if the mark is deleted.
    func getBuffer() -> UnsafeMutablePointer<GtkTextBuffer>! {
        let rv = gtk_text_mark_get_buffer(cast(text_mark_ptr))
        return cast(rv)
    }

    /// Returns `true` if the mark has been removed from its buffer
    /// with `gtk_text_buffer_delete_mark()`. See `gtk_text_buffer_add_mark()`
    /// for a way to add it to a buffer again.
    func getDeleted() -> Bool {
        let rv = gtk_text_mark_get_deleted(cast(text_mark_ptr))
        return Bool(rv != 0)
    }

    /// Determines whether the mark has left gravity.
    func getLeftGravity() -> Bool {
        let rv = gtk_text_mark_get_left_gravity(cast(text_mark_ptr))
        return Bool(rv != 0)
    }

    /// Returns the mark name; returns NULL for anonymous marks.
    func getName() -> String! {
        let rv = gtk_text_mark_get_name(cast(text_mark_ptr))
        return rv.map { String(cString: UnsafePointer<CChar>($0)) }
    }

    /// Returns `true` if the mark is visible (i.e. a cursor is displayed
    /// for it).
    func getVisible() -> Bool {
        let rv = gtk_text_mark_get_visible(cast(text_mark_ptr))
        return Bool(rv != 0)
    }

    /// Sets the visibility of `mark`; the insertion point is normally
    /// visible, i.e. you can see it as a vertical bar. Also, the text
    /// widget uses a visible mark to indicate where a drop will occur when
    /// dragging-and-dropping text. Most other marks are not visible.
    /// Marks are not visible by default.
    func setVisible(setting: Bool) {
        gtk_text_mark_set_visible(cast(text_mark_ptr), gboolean(setting ? 1 : 0))
    
    }
    /// Gets the buffer this mark is located inside,
    /// or `nil` if the mark is deleted.
    var buffer: UnsafeMutablePointer<GtkTextBuffer>! {
        /// Gets the buffer this mark is located inside,
        /// or `nil` if the mark is deleted.
        get {
            let rv = gtk_text_mark_get_buffer(cast(text_mark_ptr))
            return cast(rv)
        }
    }

    /// Returns `true` if the mark has been removed from its buffer
    /// with `gtk_text_buffer_delete_mark()`. See `gtk_text_buffer_add_mark()`
    /// for a way to add it to a buffer again.
    var deleted: Bool {
        /// Returns `true` if the mark has been removed from its buffer
        /// with `gtk_text_buffer_delete_mark()`. See `gtk_text_buffer_add_mark()`
        /// for a way to add it to a buffer again.
        get {
            let rv = gtk_text_mark_get_deleted(cast(text_mark_ptr))
            return Bool(rv != 0)
        }
    }

    /// Determines whether the mark has left gravity.
    var leftGravity: Bool {
        /// Determines whether the mark has left gravity.
        get {
            let rv = gtk_text_mark_get_left_gravity(cast(text_mark_ptr))
            return Bool(rv != 0)
        }
    }

    /// The name of the mark or `nil` if the mark is anonymous.
    var name: String! {
        /// Returns the mark name; returns NULL for anonymous marks.
        get {
            let rv = gtk_text_mark_get_name(cast(text_mark_ptr))
            return rv.map { String(cString: UnsafePointer<CChar>($0)) }
        }
    }

    /// Returns `true` if the mark is visible (i.e. a cursor is displayed
    /// for it).
    var visible: Bool {
        /// Returns `true` if the mark is visible (i.e. a cursor is displayed
        /// for it).
        get {
            let rv = gtk_text_mark_get_visible(cast(text_mark_ptr))
            return Bool(rv != 0)
        }
        /// Sets the visibility of `mark`; the insertion point is normally
        /// visible, i.e. you can see it as a vertical bar. Also, the text
        /// widget uses a visible mark to indicate where a drop will occur when
        /// dragging-and-dropping text. Most other marks are not visible.
        /// Marks are not visible by default.
        nonmutating set {
            gtk_text_mark_set_visible(cast(text_mark_ptr), gboolean(newValue ? 1 : 0))
        }
    }
}



// MARK: - TextTag Class

/// The `TextTagProtocol` protocol exposes the methods and properties of an underlying `GtkTextTag` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextTag`.
/// Alternatively, use `TextTagRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and
/// data types related to the text widget and how they work together.
/// 
/// Tags should be in the `GtkTextTagTable` for a given `GtkTextBuffer`
/// before using them with that buffer.
/// 
/// `gtk_text_buffer_create_tag()` is the best way to create tags.
/// See “gtk3-demo” for numerous examples.
/// 
/// For each property of `GtkTextTag`, there is a “set” property, e.g.
/// “font-set” corresponds to “font”. These “set” properties reflect
/// whether a property has been set or not.
/// They are maintained by GTK+ and you should not set them independently.
public protocol TextTagProtocol: GLibObject.ObjectProtocol {
    /// Untyped pointer to the underlying `GtkTextTag` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkTextTag` instance.
    var text_tag_ptr: UnsafeMutablePointer<GtkTextTag> { get }
}

/// The `TextTagRef` type acts as a lightweight Swift reference to an underlying `GtkTextTag` instance.
/// It exposes methods that can operate on this data type through `TextTagProtocol` conformance.
/// Use `TextTagRef` only as an `unowned` reference to an existing `GtkTextTag` instance.
///
/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and
/// data types related to the text widget and how they work together.
/// 
/// Tags should be in the `GtkTextTagTable` for a given `GtkTextBuffer`
/// before using them with that buffer.
/// 
/// `gtk_text_buffer_create_tag()` is the best way to create tags.
/// See “gtk3-demo” for numerous examples.
/// 
/// For each property of `GtkTextTag`, there is a “set” property, e.g.
/// “font-set” corresponds to “font”. These “set” properties reflect
/// whether a property has been set or not.
/// They are maintained by GTK+ and you should not set them independently.
public struct TextTagRef: TextTagProtocol {
    /// Untyped pointer to the underlying `GtkTextTag` instance.
    /// For type-safe access, use the generated, typed pointer `text_tag_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension TextTagRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkTextTag>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `TextTagProtocol`
    init<T: TextTagProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a `GtkTextTag`. Configure the tag using object arguments,
    /// i.e. using `g_object_set()`.
    init( name: UnsafePointer<gchar>) {
        let rv = gtk_text_tag_new(name)
        self.init(cast(rv))
    }
}

/// The `TextTag` type acts as a reference-counted owner of an underlying `GtkTextTag` instance.
/// It provides the methods that can operate on this data type through `TextTagProtocol` conformance.
/// Use `TextTag` as a strong reference or owner of a `GtkTextTag` instance.
///
/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and
/// data types related to the text widget and how they work together.
/// 
/// Tags should be in the `GtkTextTagTable` for a given `GtkTextBuffer`
/// before using them with that buffer.
/// 
/// `gtk_text_buffer_create_tag()` is the best way to create tags.
/// See “gtk3-demo” for numerous examples.
/// 
/// For each property of `GtkTextTag`, there is a “set” property, e.g.
/// “font-set” corresponds to “font”. These “set” properties reflect
/// whether a property has been set or not.
/// They are maintained by GTK+ and you should not set them independently.
open class TextTag: GLibObject.Object, TextTagProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `TextTag` instance.
    public init(_ op: UnsafeMutablePointer<GtkTextTag>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `TextTagProtocol`
    /// Will retain `GtkTextTag`.
    public convenience init<T: TextTagProtocol>(_ other: T) {
        self.init(cast(other.text_tag_ptr))
        g_object_ref(cast(text_tag_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkTextTag.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkTextTag.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkTextTag.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkTextTag>(opaquePointer))
    }

    /// Creates a `GtkTextTag`. Configure the tag using object arguments,
    /// i.e. using `g_object_set()`.
    public convenience init( name: UnsafePointer<gchar>) {
        let rv = gtk_text_tag_new(name)
        self.init(cast(rv))
    }


}

public enum TextTagPropertyName: String, PropertyNameProtocol {
    /// Whether the margins accumulate or override each other.
    /// 
    /// When set to `true` the margins of this tag are added to the margins
    /// of any other non-accumulative margins present. When set to `false`
    /// the margins override one another (the default).
    case accumulativeMargin = "accumulative-margin"
    case background = "background"
    case backgroundFullHeight = "background-full-height"
    case backgroundFullHeightSet = "background-full-height-set"
    /// Background color as a `GdkColor`.
    ///
    /// **background-gdk is deprecated:**
    /// Use #GtkTextTag:background-rgba instead.
    case backgroundGdk = "background-gdk"
    /// Background color as a `GdkRGBA`.
    case backgroundRGBA = "background-rgba"
    case backgroundSet = "background-set"
    case direction = "direction"
    case editable = "editable"
    case editableSet = "editable-set"
    /// Whether font fallback is enabled.
    /// 
    /// When set to `true`, other fonts will be substituted
    /// where the current font is missing glyphs.
    case fallback = "fallback"
    case fallbackSet = "fallback-set"
    case family = "family"
    case familySet = "family-set"
    /// Font description as string, e.g. \"Sans Italic 12\".
    /// 
    /// Note that the initial value of this property depends on
    /// the internals of `PangoFontDescription`.
    case font = "font"
    case fontDesc = "font-desc"
    /// OpenType font features, as a string.
    case fontFeatures = "font-features"
    case fontFeaturesSet = "font-features-set"
    case foreground = "foreground"
    /// Foreground color as a `GdkColor`.
    ///
    /// **foreground-gdk is deprecated:**
    /// Use #GtkTextTag:foreground-rgba instead.
    case foregroundGdk = "foreground-gdk"
    /// Foreground color as a `GdkRGBA`.
    case foregroundRGBA = "foreground-rgba"
    case foregroundSet = "foreground-set"
    case indent = "indent"
    case indentSet = "indent-set"
    /// Whether this text is hidden.
    /// 
    /// Note that there may still be problems with the support for invisible
    /// text, in particular when navigating programmatically inside a buffer
    /// containing invisible segments.
    case invisible = "invisible"
    case invisibleSet = "invisible-set"
    case justification = "justification"
    case justificationSet = "justification-set"
    /// The language this text is in, as an ISO code. Pango can use this as a
    /// hint when rendering the text. If not set, an appropriate default will be
    /// used.
    /// 
    /// Note that the initial value of this property depends on the current
    /// locale, see also `gtk_get_default_language()`.
    case language = "language"
    case languageSet = "language-set"
    case leftMargin = "left-margin"
    case leftMarginSet = "left-margin-set"
    /// Extra spacing between graphemes, in Pango units.
    case letterSpacing = "letter-spacing"
    case letterSpacingSet = "letter-spacing-set"
    case name = "name"
    /// The paragraph background color as a string.
    case paragraphBackground = "paragraph-background"
    /// The paragraph background color as a `GdkColor`.
    ///
    /// **paragraph-background-gdk is deprecated:**
    /// Use #GtkTextTag:paragraph-background-rgba instead.
    case paragraphBackgroundGdk = "paragraph-background-gdk"
    /// The paragraph background color as a `GdkRGBA`.
    case paragraphBackgroundRGBA = "paragraph-background-rgba"
    case paragraphBackgroundSet = "paragraph-background-set"
    case pixelsAboveLines = "pixels-above-lines"
    case pixelsAboveLinesSet = "pixels-above-lines-set"
    case pixelsBelowLines = "pixels-below-lines"
    case pixelsBelowLinesSet = "pixels-below-lines-set"
    case pixelsInsideWrap = "pixels-inside-wrap"
    case pixelsInsideWrapSet = "pixels-inside-wrap-set"
    case rightMargin = "right-margin"
    case rightMarginSet = "right-margin-set"
    case rise = "rise"
    case riseSet = "rise-set"
    case scale = "scale"
    case scaleSet = "scale-set"
    case size = "size"
    case sizePoints = "size-points"
    case sizeSet = "size-set"
    case stretch = "stretch"
    case stretchSet = "stretch-set"
    case strikethrough = "strikethrough"
    /// This property modifies the color of strikeouts. If not set, strikeouts
    /// will use the forground color.
    case strikethroughRGBA = "strikethrough-rgba"
    /// If the `GtkTextTag:strikethrough`-rgba property has been set.
    case strikethroughRGBASet = "strikethrough-rgba-set"
    case strikethroughSet = "strikethrough-set"
    case style = "style"
    case styleSet = "style-set"
    case tabs = "tabs"
    case tabsSet = "tabs-set"
    case underline = "underline"
    /// This property modifies the color of underlines. If not set, underlines
    /// will use the forground color.
    /// 
    /// If `GtkTextTag:underline` is set to `PANGO_UNDERLINE_ERROR`, an alternate
    /// color may be applied instead of the foreground. Setting this property
    /// will always override those defaults.
    case underlineRGBA = "underline-rgba"
    /// If the `GtkTextTag:underline`-rgba property has been set.
    case underlineRGBASet = "underline-rgba-set"
    case underlineSet = "underline-set"
    case variant = "variant"
    case variantSet = "variant-set"
    case weight = "weight"
    case weightSet = "weight-set"
    case wrapMode = "wrap-mode"
    case wrapModeSet = "wrap-mode-set"
}

public extension TextTagProtocol {
    /// Bind a `TextTagPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TextTagPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(text_tag_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum TextTagSignalName: String, SignalNameProtocol {
    /// The `event` signal is emitted when an event occurs on a region of the
    /// buffer marked with this tag.
    case event = "event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Whether the margins accumulate or override each other.
    /// 
    /// When set to `true` the margins of this tag are added to the margins
    /// of any other non-accumulative margins present. When set to `false`
    /// the margins override one another (the default).
    case notifyAccumulativeMargin = "notify::accumulative-margin"
    case notifyBackground = "notify::background"
    case notifyBackgroundFullHeight = "notify::background-full-height"
    case notifyBackgroundFullHeightSet = "notify::background-full-height-set"
    /// Background color as a `GdkColor`.
    ///
    /// **background-gdk is deprecated:**
    /// Use #GtkTextTag:background-rgba instead.
    case notifyBackgroundGdk = "notify::background-gdk"
    /// Background color as a `GdkRGBA`.
    case notifyBackgroundRGBA = "notify::background-rgba"
    case notifyBackgroundSet = "notify::background-set"
    case notifyDirection = "notify::direction"
    case notifyEditable = "notify::editable"
    case notifyEditableSet = "notify::editable-set"
    /// Whether font fallback is enabled.
    /// 
    /// When set to `true`, other fonts will be substituted
    /// where the current font is missing glyphs.
    case notifyFallback = "notify::fallback"
    case notifyFallbackSet = "notify::fallback-set"
    case notifyFamily = "notify::family"
    case notifyFamilySet = "notify::family-set"
    /// Font description as string, e.g. \"Sans Italic 12\".
    /// 
    /// Note that the initial value of this property depends on
    /// the internals of `PangoFontDescription`.
    case notifyFont = "notify::font"
    case notifyFontDesc = "notify::font-desc"
    /// OpenType font features, as a string.
    case notifyFontFeatures = "notify::font-features"
    case notifyFontFeaturesSet = "notify::font-features-set"
    case notifyForeground = "notify::foreground"
    /// Foreground color as a `GdkColor`.
    ///
    /// **foreground-gdk is deprecated:**
    /// Use #GtkTextTag:foreground-rgba instead.
    case notifyForegroundGdk = "notify::foreground-gdk"
    /// Foreground color as a `GdkRGBA`.
    case notifyForegroundRGBA = "notify::foreground-rgba"
    case notifyForegroundSet = "notify::foreground-set"
    case notifyIndent = "notify::indent"
    case notifyIndentSet = "notify::indent-set"
    /// Whether this text is hidden.
    /// 
    /// Note that there may still be problems with the support for invisible
    /// text, in particular when navigating programmatically inside a buffer
    /// containing invisible segments.
    case notifyInvisible = "notify::invisible"
    case notifyInvisibleSet = "notify::invisible-set"
    case notifyJustification = "notify::justification"
    case notifyJustificationSet = "notify::justification-set"
    /// The language this text is in, as an ISO code. Pango can use this as a
    /// hint when rendering the text. If not set, an appropriate default will be
    /// used.
    /// 
    /// Note that the initial value of this property depends on the current
    /// locale, see also `gtk_get_default_language()`.
    case notifyLanguage = "notify::language"
    case notifyLanguageSet = "notify::language-set"
    case notifyLeftMargin = "notify::left-margin"
    case notifyLeftMarginSet = "notify::left-margin-set"
    /// Extra spacing between graphemes, in Pango units.
    case notifyLetterSpacing = "notify::letter-spacing"
    case notifyLetterSpacingSet = "notify::letter-spacing-set"
    case notifyName = "notify::name"
    /// The paragraph background color as a string.
    case notifyParagraphBackground = "notify::paragraph-background"
    /// The paragraph background color as a `GdkColor`.
    ///
    /// **paragraph-background-gdk is deprecated:**
    /// Use #GtkTextTag:paragraph-background-rgba instead.
    case notifyParagraphBackgroundGdk = "notify::paragraph-background-gdk"
    /// The paragraph background color as a `GdkRGBA`.
    case notifyParagraphBackgroundRGBA = "notify::paragraph-background-rgba"
    case notifyParagraphBackgroundSet = "notify::paragraph-background-set"
    case notifyPixelsAboveLines = "notify::pixels-above-lines"
    case notifyPixelsAboveLinesSet = "notify::pixels-above-lines-set"
    case notifyPixelsBelowLines = "notify::pixels-below-lines"
    case notifyPixelsBelowLinesSet = "notify::pixels-below-lines-set"
    case notifyPixelsInsideWrap = "notify::pixels-inside-wrap"
    case notifyPixelsInsideWrapSet = "notify::pixels-inside-wrap-set"
    case notifyRightMargin = "notify::right-margin"
    case notifyRightMarginSet = "notify::right-margin-set"
    case notifyRise = "notify::rise"
    case notifyRiseSet = "notify::rise-set"
    case notifyScale = "notify::scale"
    case notifyScaleSet = "notify::scale-set"
    case notifySize = "notify::size"
    case notifySizePoints = "notify::size-points"
    case notifySizeSet = "notify::size-set"
    case notifyStretch = "notify::stretch"
    case notifyStretchSet = "notify::stretch-set"
    case notifyStrikethrough = "notify::strikethrough"
    /// This property modifies the color of strikeouts. If not set, strikeouts
    /// will use the forground color.
    case notifyStrikethroughRGBA = "notify::strikethrough-rgba"
    /// If the `GtkTextTag:strikethrough`-rgba property has been set.
    case notifyStrikethroughRGBASet = "notify::strikethrough-rgba-set"
    case notifyStrikethroughSet = "notify::strikethrough-set"
    case notifyStyle = "notify::style"
    case notifyStyleSet = "notify::style-set"
    case notifyTabs = "notify::tabs"
    case notifyTabsSet = "notify::tabs-set"
    case notifyUnderline = "notify::underline"
    /// This property modifies the color of underlines. If not set, underlines
    /// will use the forground color.
    /// 
    /// If `GtkTextTag:underline` is set to `PANGO_UNDERLINE_ERROR`, an alternate
    /// color may be applied instead of the foreground. Setting this property
    /// will always override those defaults.
    case notifyUnderlineRGBA = "notify::underline-rgba"
    /// If the `GtkTextTag:underline`-rgba property has been set.
    case notifyUnderlineRGBASet = "notify::underline-rgba-set"
    case notifyUnderlineSet = "notify::underline-set"
    case notifyVariant = "notify::variant"
    case notifyVariantSet = "notify::variant-set"
    case notifyWeight = "notify::weight"
    case notifyWeightSet = "notify::weight-set"
    case notifyWrapMode = "notify::wrap-mode"
    case notifyWrapModeSet = "notify::wrap-mode-set"
}

public extension TextTagProtocol {
    /// Connect a `TextTagSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: TextTagSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(text_tag_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension TextTagProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextTag` instance.
    var text_tag_ptr: UnsafeMutablePointer<GtkTextTag> { return ptr.assumingMemoryBound(to: GtkTextTag.self) }

    /// Emits the `GtkTextTagTable::tag`-changed signal on the `GtkTextTagTable` where
    /// the tag is included.
    /// 
    /// The signal is already emitted when setting a `GtkTextTag` property. This
    /// function is useful for a `GtkTextTag` subclass.
    func changed(sizeChanged size_changed: Bool) {
        gtk_text_tag_changed(cast(text_tag_ptr), gboolean(size_changed ? 1 : 0))
    
    }

    /// Emits the “event” signal on the `GtkTextTag`.
    func event(eventObject event_object: GLibObject.ObjectProtocol, event: UnsafeMutablePointer<GdkEvent>, iter: TextIterProtocol) -> Bool {
        let rv = gtk_text_tag_event(cast(text_tag_ptr), cast(event_object.ptr), cast(event), cast(iter.ptr))
        return Bool(rv != 0)
    }

    /// Get the tag priority.
    func getPriority() -> CInt {
        let rv = gtk_text_tag_get_priority(cast(text_tag_ptr))
        return CInt(rv)
    }

    /// Sets the priority of a `GtkTextTag`. Valid priorities
    /// start at 0 and go to one less than `gtk_text_tag_table_get_size()`.
    /// Each tag in a table has a unique priority; setting the priority
    /// of one tag shifts the priorities of all the other tags in the
    /// table to maintain a unique priority for each tag. Higher priority
    /// tags “win” if two tags both set the same text attribute. When adding
    /// a tag to a tag table, it will be assigned the highest priority in
    /// the table by default; so normally the precedence of a set of tags
    /// is the order in which they were added to the table, or created with
    /// `gtk_text_buffer_create_tag()`, which adds the tag to the buffer’s table
    /// automatically.
    func set(priority: CInt) {
        gtk_text_tag_set_priority(cast(text_tag_ptr), gint(priority))
    
    }
    /// Get the tag priority.
    var priority: CInt {
        /// Get the tag priority.
        get {
            let rv = gtk_text_tag_get_priority(cast(text_tag_ptr))
            return CInt(rv)
        }
        /// Sets the priority of a `GtkTextTag`. Valid priorities
        /// start at 0 and go to one less than `gtk_text_tag_table_get_size()`.
        /// Each tag in a table has a unique priority; setting the priority
        /// of one tag shifts the priorities of all the other tags in the
        /// table to maintain a unique priority for each tag. Higher priority
        /// tags “win” if two tags both set the same text attribute. When adding
        /// a tag to a tag table, it will be assigned the highest priority in
        /// the table by default; so normally the precedence of a set of tags
        /// is the order in which they were added to the table, or created with
        /// `gtk_text_buffer_create_tag()`, which adds the tag to the buffer’s table
        /// automatically.
        nonmutating set {
            gtk_text_tag_set_priority(cast(text_tag_ptr), gint(newValue))
        }
    }
}



// MARK: - TextTagTable Class

/// The `TextTagTableProtocol` protocol exposes the methods and properties of an underlying `GtkTextTagTable` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextTagTable`.
/// Alternatively, use `TextTagTableRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and
/// data types related to the text widget and how they work together.
/// 
/// # GtkTextTagTables as GtkBuildable
/// 
/// The GtkTextTagTable implementation of the GtkBuildable interface
/// supports adding tags by specifying “tag” as the “type” attribute
/// of a <child> element.
/// 
/// An example of a UI definition fragment specifying tags:
/// ```
/// <object class="GtkTextTagTable">
///  <child type="tag">
///    <object class="GtkTextTag"/>
///  </child>
/// </object>
/// ```
/// 
public protocol TextTagTableProtocol: GLibObject.ObjectProtocol, BuildableProtocol {
    /// Untyped pointer to the underlying `GtkTextTagTable` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkTextTagTable` instance.
    var text_tag_table_ptr: UnsafeMutablePointer<GtkTextTagTable> { get }
}

/// The `TextTagTableRef` type acts as a lightweight Swift reference to an underlying `GtkTextTagTable` instance.
/// It exposes methods that can operate on this data type through `TextTagTableProtocol` conformance.
/// Use `TextTagTableRef` only as an `unowned` reference to an existing `GtkTextTagTable` instance.
///
/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and
/// data types related to the text widget and how they work together.
/// 
/// # GtkTextTagTables as GtkBuildable
/// 
/// The GtkTextTagTable implementation of the GtkBuildable interface
/// supports adding tags by specifying “tag” as the “type” attribute
/// of a <child> element.
/// 
/// An example of a UI definition fragment specifying tags:
/// ```
/// <object class="GtkTextTagTable">
///  <child type="tag">
///    <object class="GtkTextTag"/>
///  </child>
/// </object>
/// ```
/// 
public struct TextTagTableRef: TextTagTableProtocol {
    /// Untyped pointer to the underlying `GtkTextTagTable` instance.
    /// For type-safe access, use the generated, typed pointer `text_tag_table_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension TextTagTableRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkTextTagTable>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `TextTagTableProtocol`
    init<T: TextTagTableProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkTextTagTable`. The table contains no tags by
    /// default.
    init() {
        let rv = gtk_text_tag_table_new()
        self.init(cast(rv))
    }
}

/// The `TextTagTable` type acts as a reference-counted owner of an underlying `GtkTextTagTable` instance.
/// It provides the methods that can operate on this data type through `TextTagTableProtocol` conformance.
/// Use `TextTagTable` as a strong reference or owner of a `GtkTextTagTable` instance.
///
/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and
/// data types related to the text widget and how they work together.
/// 
/// # GtkTextTagTables as GtkBuildable
/// 
/// The GtkTextTagTable implementation of the GtkBuildable interface
/// supports adding tags by specifying “tag” as the “type” attribute
/// of a <child> element.
/// 
/// An example of a UI definition fragment specifying tags:
/// ```
/// <object class="GtkTextTagTable">
///  <child type="tag">
///    <object class="GtkTextTag"/>
///  </child>
/// </object>
/// ```
/// 
open class TextTagTable: GLibObject.Object, TextTagTableProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `TextTagTable` instance.
    public init(_ op: UnsafeMutablePointer<GtkTextTagTable>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `TextTagTableProtocol`
    /// Will retain `GtkTextTagTable`.
    public convenience init<T: TextTagTableProtocol>(_ other: T) {
        self.init(cast(other.text_tag_table_ptr))
        g_object_ref(cast(text_tag_table_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkTextTagTable.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkTextTagTable.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkTextTagTable.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkTextTagTable>(opaquePointer))
    }

    /// Creates a new `GtkTextTagTable`. The table contains no tags by
    /// default.
    public convenience init() {
        let rv = gtk_text_tag_table_new()
        self.init(cast(rv))
    }


}

// MARK: - no TextTagTable properties

public enum TextTagTableSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case tagAdded = "tag-added"
    case tagChanged = "tag-changed"
    case tagRemoved = "tag-removed"

}

public extension TextTagTableProtocol {
    /// Connect a `TextTagTableSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: TextTagTableSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(text_tag_table_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension TextTagTableProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextTagTable` instance.
    var text_tag_table_ptr: UnsafeMutablePointer<GtkTextTagTable> { return ptr.assumingMemoryBound(to: GtkTextTagTable.self) }

    /// Add a tag to the table. The tag is assigned the highest priority
    /// in the table.
    /// 
    /// `tag` must not be in a tag table already, and may not have
    /// the same name as an already-added tag.
    func add(tag: TextTagProtocol) -> Bool {
        let rv = gtk_text_tag_table_add(cast(text_tag_table_ptr), cast(tag.ptr))
        return Bool(rv != 0)
    }

    /// Calls `func` on each tag in `table`, with user data `data`.
    /// Note that the table may not be modified while iterating
    /// over it (you can’t add/remove tags).
    func foreach(_ func_: @escaping TextTagTableForeach, data: UnsafeMutableRawPointer) {
        gtk_text_tag_table_foreach(cast(text_tag_table_ptr), func_, cast(data))
    
    }

    /// Returns the size of the table (number of tags)
    func getSize() -> CInt {
        let rv = gtk_text_tag_table_get_size(cast(text_tag_table_ptr))
        return CInt(rv)
    }

    /// Look up a named tag.
    func lookup(name: UnsafePointer<gchar>) -> UnsafeMutablePointer<GtkTextTag>! {
        let rv = gtk_text_tag_table_lookup(cast(text_tag_table_ptr), name)
        return cast(rv)
    }

    /// Remove a tag from the table. If a `GtkTextBuffer` has `table` as its tag table,
    /// the tag is removed from the buffer. The table’s reference to the tag is
    /// removed, so the tag will end up destroyed if you don’t have a reference to
    /// it.
    func remove(tag: TextTagProtocol) {
        gtk_text_tag_table_remove(cast(text_tag_table_ptr), cast(tag.ptr))
    
    }
    /// Returns the size of the table (number of tags)
    var size: CInt {
        /// Returns the size of the table (number of tags)
        get {
            let rv = gtk_text_tag_table_get_size(cast(text_tag_table_ptr))
            return CInt(rv)
        }
    }
}



// MARK: - TextView Class

/// The `TextViewProtocol` protocol exposes the methods and properties of an underlying `GtkTextView` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextView`.
/// Alternatively, use `TextViewRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and data
/// types related to the text widget and how they work together.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// textview.view
/// ├── border.top
/// ├── border.left
/// ├── text
/// │   ╰── [selection]
/// ├── border.right
/// ├── border.bottom
/// ╰── [window.popup]
/// ```
/// 
/// GtkTextView has a main css node with name textview and style class .view,
/// and subnodes for each of the border windows, and the main text area,
/// with names border and text, respectively. The border nodes each get
/// one of the style classes .left, .right, .top or .bottom.
/// 
/// A node representing the selection will appear below the text node.
/// 
/// If a context menu is opened, the window node will appear as a subnode
/// of the main node.
public protocol TextViewProtocol: ContainerProtocol, ScrollableProtocol {
    /// Untyped pointer to the underlying `GtkTextView` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkTextView` instance.
    var text_view_ptr: UnsafeMutablePointer<GtkTextView> { get }
}

/// The `TextViewRef` type acts as a lightweight Swift reference to an underlying `GtkTextView` instance.
/// It exposes methods that can operate on this data type through `TextViewProtocol` conformance.
/// Use `TextViewRef` only as an `unowned` reference to an existing `GtkTextView` instance.
///
/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and data
/// types related to the text widget and how they work together.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// textview.view
/// ├── border.top
/// ├── border.left
/// ├── text
/// │   ╰── [selection]
/// ├── border.right
/// ├── border.bottom
/// ╰── [window.popup]
/// ```
/// 
/// GtkTextView has a main css node with name textview and style class .view,
/// and subnodes for each of the border windows, and the main text area,
/// with names border and text, respectively. The border nodes each get
/// one of the style classes .left, .right, .top or .bottom.
/// 
/// A node representing the selection will appear below the text node.
/// 
/// If a context menu is opened, the window node will appear as a subnode
/// of the main node.
public struct TextViewRef: TextViewProtocol {
    /// Untyped pointer to the underlying `GtkTextView` instance.
    /// For type-safe access, use the generated, typed pointer `text_view_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension TextViewRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkTextView>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `TextViewProtocol`
    init<T: TextViewProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkTextView`. If you don’t call `gtk_text_view_set_buffer()`
    /// before using the text view, an empty default buffer will be created
    /// for you. Get the buffer with `gtk_text_view_get_buffer()`. If you want
    /// to specify your own buffer, consider `gtk_text_view_new_with_buffer()`.
    init() {
        let rv = gtk_text_view_new()
        self.init(cast(rv))
    }

    /// Creates a new `GtkTextView` widget displaying the buffer
    /// `buffer`. One buffer can be shared among many widgets.
    /// `buffer` may be `nil` to create a default buffer, in which case
    /// this function is equivalent to `gtk_text_view_new()`. The
    /// text view adds its own reference count to the buffer; it does not
    /// take over an existing reference.
    init(buffer: TextBufferProtocol) {
        let rv = gtk_text_view_new_with_buffer(cast(buffer.ptr))
        self.init(cast(rv))
    }
    /// Creates a new `GtkTextView` widget displaying the buffer
    /// `buffer`. One buffer can be shared among many widgets.
    /// `buffer` may be `nil` to create a default buffer, in which case
    /// this function is equivalent to `gtk_text_view_new()`. The
    /// text view adds its own reference count to the buffer; it does not
    /// take over an existing reference.
    static func newWith(buffer: TextBufferProtocol) -> TextViewRef! {
        let rv = gtk_text_view_new_with_buffer(cast(buffer.ptr))
        return rv.map { TextViewRef(cast($0)) }
    }
}

/// The `TextView` type acts as a reference-counted owner of an underlying `GtkTextView` instance.
/// It provides the methods that can operate on this data type through `TextViewProtocol` conformance.
/// Use `TextView` as a strong reference or owner of a `GtkTextView` instance.
///
/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and data
/// types related to the text widget and how they work together.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// textview.view
/// ├── border.top
/// ├── border.left
/// ├── text
/// │   ╰── [selection]
/// ├── border.right
/// ├── border.bottom
/// ╰── [window.popup]
/// ```
/// 
/// GtkTextView has a main css node with name textview and style class .view,
/// and subnodes for each of the border windows, and the main text area,
/// with names border and text, respectively. The border nodes each get
/// one of the style classes .left, .right, .top or .bottom.
/// 
/// A node representing the selection will appear below the text node.
/// 
/// If a context menu is opened, the window node will appear as a subnode
/// of the main node.
open class TextView: Container, TextViewProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `TextView` instance.
    public init(_ op: UnsafeMutablePointer<GtkTextView>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `TextViewProtocol`
    /// Will retain `GtkTextView`.
    public convenience init<T: TextViewProtocol>(_ other: T) {
        self.init(cast(other.text_view_ptr))
        g_object_ref(cast(text_view_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkTextView.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkTextView.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkTextView.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkTextView>(opaquePointer))
    }

    /// Creates a new `GtkTextView`. If you don’t call `gtk_text_view_set_buffer()`
    /// before using the text view, an empty default buffer will be created
    /// for you. Get the buffer with `gtk_text_view_get_buffer()`. If you want
    /// to specify your own buffer, consider `gtk_text_view_new_with_buffer()`.
    public convenience init() {
        let rv = gtk_text_view_new()
        self.init(cast(rv))
    }

    /// Creates a new `GtkTextView` widget displaying the buffer
    /// `buffer`. One buffer can be shared among many widgets.
    /// `buffer` may be `nil` to create a default buffer, in which case
    /// this function is equivalent to `gtk_text_view_new()`. The
    /// text view adds its own reference count to the buffer; it does not
    /// take over an existing reference.
    public convenience init(buffer: TextBufferProtocol) {
        let rv = gtk_text_view_new_with_buffer(cast(buffer.ptr))
        self.init(cast(rv))
    }

    /// Creates a new `GtkTextView` widget displaying the buffer
    /// `buffer`. One buffer can be shared among many widgets.
    /// `buffer` may be `nil` to create a default buffer, in which case
    /// this function is equivalent to `gtk_text_view_new()`. The
    /// text view adds its own reference count to the buffer; it does not
    /// take over an existing reference.
    public static func newWith(buffer: TextBufferProtocol) -> TextView! {
        let rv = gtk_text_view_new_with_buffer(cast(buffer.ptr))
        return rv.map { TextView(cast($0)) }
    }

}

public enum TextViewPropertyName: String, PropertyNameProtocol {
    case acceptsTab = "accepts-tab"
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case appPaintable = "app-paintable"
    case borderWidth = "border-width"
    /// The bottom margin for text in the text view.
    /// 
    /// Note that this property is confusingly named. In CSS terms,
    /// the value set here is padding, and it is applied in addition
    /// to the padding from the theme.
    /// 
    /// Don't confuse this property with `GtkWidget:margin`-bottom.
    case bottomMargin = "bottom-margin"
    case buffer = "buffer"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case compositeChild = "composite-child"
    case cursorVisible = "cursor-visible"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case editable = "editable"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// Which IM (input method) module should be used for this text_view.
    /// See `GtkIMContext`.
    /// 
    /// Setting this to a non-`nil` value overrides the
    /// system-wide IM module setting. See the GtkSettings
    /// `GtkSettings:gtk`-im-module property.
    case imModule = "im-module"
    case indent = "indent"
    /// Additional hints (beyond `GtkTextView:input`-purpose) that
    /// allow input methods to fine-tune their behaviour.
    case inputHints = "input-hints"
    /// The purpose of this text field.
    /// 
    /// This property can be used by on-screen keyboards and other input
    /// methods to adjust their behaviour.
    case inputPurpose = "input-purpose"
    case isFocus = "is-focus"
    case justification = "justification"
    /// The default left margin for text in the text view.
    /// Tags in the buffer may override the default.
    /// 
    /// Note that this property is confusingly named. In CSS terms,
    /// the value set here is padding, and it is applied in addition
    /// to the padding from the theme.
    /// 
    /// Don't confuse this property with `GtkWidget:margin`-left.
    case leftMargin = "left-margin"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case monospace = "monospace"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case overwrite = "overwrite"
    case parent = "parent"
    case pixelsAboveLines = "pixels-above-lines"
    case pixelsBelowLines = "pixels-below-lines"
    case pixelsInsideWrap = "pixels-inside-wrap"
    /// If :populate-all is `true`, the `GtkTextView::populate`-popup
    /// signal is also emitted for touch popups.
    case populateAll = "populate-all"
    case receivesDefault = "receives-default"
    case resizeMode = "resize-mode"
    /// The default right margin for text in the text view.
    /// Tags in the buffer may override the default.
    /// 
    /// Note that this property is confusingly named. In CSS terms,
    /// the value set here is padding, and it is applied in addition
    /// to the padding from the theme.
    /// 
    /// Don't confuse this property with `GtkWidget:margin`-right.
    case rightMargin = "right-margin"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    case tabs = "tabs"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// The top margin for text in the text view.
    /// 
    /// Note that this property is confusingly named. In CSS terms,
    /// the value set here is padding, and it is applied in addition
    /// to the padding from the theme.
    /// 
    /// Don't confuse this property with `GtkWidget:margin`-top.
    case topMargin = "top-margin"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
    case wrapMode = "wrap-mode"
}

public extension TextViewProtocol {
    /// Bind a `TextViewPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TextViewPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(text_view_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum TextViewSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    case add = "add"
    /// The `backspace` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user asks for it.
    /// 
    /// The default bindings for this signal are
    /// Backspace and Shift-Backspace.
    case backspace = "backspace"
    /// The `button`-press-event signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button`-release-event signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child`-notify signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The `composited`-changed signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure`-event signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// The `copy`-clipboard signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to copy the selection to the clipboard.
    /// 
    /// The default bindings for this signal are
    /// Ctrl-c and Ctrl-Insert.
    case copyClipboard = "copy-clipboard"
    /// The `cut`-clipboard signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to cut the selection to the clipboard.
    /// 
    /// The default bindings for this signal are
    /// Ctrl-x and Shift-Delete.
    case cutClipboard = "cut-clipboard"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete`-event signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// The `delete`-from-cursor signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user initiates a text deletion.
    /// 
    /// If the `type` is `GTK_DELETE_CHARS`, GTK+ deletes the selection
    /// if there is one, otherwise it deletes the requested number
    /// of characters.
    /// 
    /// The default bindings for this signal are
    /// Delete for deleting a character, Ctrl-Delete for
    /// deleting a word and Ctrl-Backspace for deleting a word
    /// backwords.
    case deleteFromCursor = "delete-from-cursor"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy`-event signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag`-begin signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag`-data-delete signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag`-data-get signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag`-data-received signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag`-drop signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag`-drop signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag`-data-received handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag`-end signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag`-begin.
    case dragEnd = "drag-end"
    /// The `drag`-failed signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag`-leave signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag`-motion, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag`-leave signal is also emitted before the
    /// `drag`-drop signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag`-motion signal handler.
    case dragLeave = "drag-leave"
    /// The `drag`-motion signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag`-data-received
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag`-leave and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enter`-notify-event will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key`-press-event) and finally a generic
    /// `GtkWidget::event`-after signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event`-after will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    /// The `extend`-selection signal is emitted when the selection needs to be
    /// extended at `location`.
    case extendSelection = "extend-selection"
    case focus = "focus"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `focus`-in-event signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus`-out-event signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab`-notify signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy`-changed signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `insert`-at-cursor signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user initiates the insertion of a
    /// fixed string at the cursor.
    /// 
    /// This signal has no default bindings.
    case insertAtCursor = "insert-at-cursor"
    /// The `insert`-emoji signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to present the Emoji chooser for the `text_view`.
    /// 
    /// The default bindings for this signal are Ctrl-. and Ctrl-;
    case insertEmoji = "insert-emoji"
    /// The `key`-press-event signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key`-release-event signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `leave`-notify-event will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map`-event will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map`-event signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion`-notify-event signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    /// The `move`-cursor signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user initiates a cursor movement.
    /// If the cursor is not visible in `text_view`, this signal causes
    /// the viewport to be moved instead.
    /// 
    /// Applications should not connect to it, but may emit it with
    /// `g_signal_emit_by_name()` if they need to control the cursor
    /// programmatically.
    /// 
    /// The default bindings for this signal come in two variants,
    /// the variant with the Shift modifier extends the selection,
    /// the variant without the Shift modifer does not.
    /// There are too many key combinations to list them all here.
    /// - Arrow keys move by individual characters/lines
    /// - Ctrl-arrow key combinations move by words/paragraphs
    /// - Home/End keys move to the ends of the buffer
    /// - PageUp/PageDown keys move vertically by pages
    /// - Ctrl-PageUp/PageDown keys move horizontally by pages
    case moveCursor = "move-cursor"
    case moveFocus = "move-focus"
    /// The `move`-viewport signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which can be bound to key combinations to allow the user
    /// to move the viewport, i.e. change what part of the text view
    /// is visible in a containing scrolled window.
    /// 
    /// There are no default bindings for this signal.
    case moveViewport = "move-viewport"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent`-set signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// The `paste`-clipboard signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to paste the contents of the clipboard
    /// into the text view.
    /// 
    /// The default bindings for this signal are
    /// Ctrl-v and Shift-Insert.
    case pasteClipboard = "paste-clipboard"
    /// The `populate`-popup signal gets emitted before showing the
    /// context menu of the text view.
    /// 
    /// If you need to add items to the context menu, connect
    /// to this signal and append your items to the `popup`, which
    /// will be a `GtkMenu` in this case.
    /// 
    /// If `GtkTextView:populate`-all is `true`, this signal will
    /// also be emitted to populate touch popups. In this case,
    /// `popup` will be a different container, e.g. a `GtkToolbar`.
    /// 
    /// The signal handler should not make assumptions about the
    /// type of `widget`, but check whether `popup` is a `GtkMenu`
    /// or `GtkToolbar` or another kind of container.
    case populatePopup = "populate-popup"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// If an input method is used, the typed text will not immediately
    /// be committed to the buffer. So if you are interested in the text,
    /// connect to this signal.
    /// 
    /// This signal is only emitted if the text at the given position
    /// is actually editable.
    case preeditChanged = "preedit-changed"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The `property`-notify-event signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// The `screen`-changed signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll`-event signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `select`-all signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to select or unselect the complete
    /// contents of the text view.
    /// 
    /// The default bindings for this signal are Ctrl-a and Ctrl-/
    /// for selecting and Shift-Ctrl-a and Ctrl-\ for unselecting.
    case selectAll = "select-all"
    /// The `selection`-clear-event signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection`-request-event signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    /// The `set`-anchor signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user initiates setting the "anchor"
    /// mark. The "anchor" mark gets placed at the same position as the
    /// "insert" mark.
    /// 
    /// This signal has no default bindings.
    case setAnchor = "set-anchor"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-changed signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style`-set signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style`-updated signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style`-updated signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    /// The `toggle`-cursor-visible signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to toggle the `GtkTextView:cursor`-visible
    /// property.
    /// 
    /// The default binding for this signal is F7.
    case toggleCursorVisible = "toggle-cursor-visible"
    /// The `toggle`-overwrite signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to toggle the overwrite mode of the text view.
    /// 
    /// The default bindings for this signal is Insert.
    case toggleOverwrite = "toggle-overwrite"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap`-event signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility`-notify-event will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    /// The `window`-state-event will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    case notifyAcceptsTab = "notify::accepts-tab"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBorderWidth = "notify::border-width"
    /// The bottom margin for text in the text view.
    /// 
    /// Note that this property is confusingly named. In CSS terms,
    /// the value set here is padding, and it is applied in addition
    /// to the padding from the theme.
    /// 
    /// Don't confuse this property with `GtkWidget:margin`-bottom.
    case notifyBottomMargin = "notify::bottom-margin"
    case notifyBuffer = "notify::buffer"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCompositeChild = "notify::composite-child"
    case notifyCursorVisible = "notify::cursor-visible"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyEditable = "notify::editable"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// Which IM (input method) module should be used for this text_view.
    /// See `GtkIMContext`.
    /// 
    /// Setting this to a non-`nil` value overrides the
    /// system-wide IM module setting. See the GtkSettings
    /// `GtkSettings:gtk`-im-module property.
    case notifyImModule = "notify::im-module"
    case notifyIndent = "notify::indent"
    /// Additional hints (beyond `GtkTextView:input`-purpose) that
    /// allow input methods to fine-tune their behaviour.
    case notifyInputHints = "notify::input-hints"
    /// The purpose of this text field.
    /// 
    /// This property can be used by on-screen keyboards and other input
    /// methods to adjust their behaviour.
    case notifyInputPurpose = "notify::input-purpose"
    case notifyIsFocus = "notify::is-focus"
    case notifyJustification = "notify::justification"
    /// The default left margin for text in the text view.
    /// Tags in the buffer may override the default.
    /// 
    /// Note that this property is confusingly named. In CSS terms,
    /// the value set here is padding, and it is applied in addition
    /// to the padding from the theme.
    /// 
    /// Don't confuse this property with `GtkWidget:margin`-left.
    case notifyLeftMargin = "notify::left-margin"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyMonospace = "notify::monospace"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyOverwrite = "notify::overwrite"
    case notifyParent = "notify::parent"
    case notifyPixelsAboveLines = "notify::pixels-above-lines"
    case notifyPixelsBelowLines = "notify::pixels-below-lines"
    case notifyPixelsInsideWrap = "notify::pixels-inside-wrap"
    /// If :populate-all is `true`, the `GtkTextView::populate`-popup
    /// signal is also emitted for touch popups.
    case notifyPopulateAll = "notify::populate-all"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizeMode = "notify::resize-mode"
    /// The default right margin for text in the text view.
    /// Tags in the buffer may override the default.
    /// 
    /// Note that this property is confusingly named. In CSS terms,
    /// the value set here is padding, and it is applied in addition
    /// to the padding from the theme.
    /// 
    /// Don't confuse this property with `GtkWidget:margin`-right.
    case notifyRightMargin = "notify::right-margin"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    case notifyTabs = "notify::tabs"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// The top margin for text in the text view.
    /// 
    /// Note that this property is confusingly named. In CSS terms,
    /// the value set here is padding, and it is applied in addition
    /// to the padding from the theme.
    /// 
    /// Don't confuse this property with `GtkWidget:margin`-top.
    case notifyTopMargin = "notify::top-margin"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
    case notifyWrapMode = "notify::wrap-mode"
}

public extension TextViewProtocol {
    /// Connect a `TextViewSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: TextViewSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(text_view_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension TextViewProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextView` instance.
    var text_view_ptr: UnsafeMutablePointer<GtkTextView> { return ptr.assumingMemoryBound(to: GtkTextView.self) }

    /// Adds a child widget in the text buffer, at the given `anchor`.
    func addChildAtAnchor(child: WidgetProtocol, anchor: TextChildAnchorProtocol) {
        gtk_text_view_add_child_at_anchor(cast(text_view_ptr), cast(child.ptr), cast(anchor.ptr))
    
    }

    /// Adds a child at fixed coordinates in one of the text widget's
    /// windows.
    /// 
    /// The window must have nonzero size (see
    /// `gtk_text_view_set_border_window_size()`). Note that the child
    /// coordinates are given relative to scrolling. When
    /// placing a child in `GTK_TEXT_WINDOW_WIDGET`, scrolling is
    /// irrelevant, the child floats above all scrollable areas. But when
    /// placing a child in one of the scrollable windows (border windows or
    /// text window) it will move with the scrolling as needed.
    func addChildInWindow(child: WidgetProtocol, whichWindow which_window: TextWindowType, xpos: CInt, ypos: CInt) {
        gtk_text_view_add_child_in_window(cast(text_view_ptr), cast(child.ptr), which_window, gint(xpos), gint(ypos))
    
    }

    /// Moves the given `iter` backward by one display (wrapped) line.
    /// A display line is different from a paragraph. Paragraphs are
    /// separated by newlines or other paragraph separator characters.
    /// Display lines are created by line-wrapping a paragraph. If
    /// wrapping is turned off, display lines and paragraphs will be the
    /// same. Display lines are divided differently for each view, since
    /// they depend on the view’s width; paragraphs are the same in all
    /// views, since they depend on the contents of the `GtkTextBuffer`.
    func backwardDisplayLine(iter: TextIterProtocol) -> Bool {
        let rv = gtk_text_view_backward_display_line(cast(text_view_ptr), cast(iter.ptr))
        return Bool(rv != 0)
    }

    /// Moves the given `iter` backward to the next display line start.
    /// A display line is different from a paragraph. Paragraphs are
    /// separated by newlines or other paragraph separator characters.
    /// Display lines are created by line-wrapping a paragraph. If
    /// wrapping is turned off, display lines and paragraphs will be the
    /// same. Display lines are divided differently for each view, since
    /// they depend on the view’s width; paragraphs are the same in all
    /// views, since they depend on the contents of the `GtkTextBuffer`.
    func backwardDisplayLineStart(iter: TextIterProtocol) -> Bool {
        let rv = gtk_text_view_backward_display_line_start(cast(text_view_ptr), cast(iter.ptr))
        return Bool(rv != 0)
    }

    /// Converts coordinate (`buffer_x`, `buffer_y`) to coordinates for the window
    /// `win`, and stores the result in (`window_x`, `window_y`).
    /// 
    /// Note that you can’t convert coordinates for a nonexisting window (see
    /// `gtk_text_view_set_border_window_size()`).
    func bufferToWindowCoords(win: TextWindowType, bufferX buffer_x: CInt, bufferY buffer_y: CInt, windowX window_x: UnsafeMutablePointer<CInt>, windowY window_y: UnsafeMutablePointer<CInt>) {
        gtk_text_view_buffer_to_window_coords(cast(text_view_ptr), win, gint(buffer_x), gint(buffer_y), cast(window_x), cast(window_y))
    
    }

    /// Moves the given `iter` forward by one display (wrapped) line.
    /// A display line is different from a paragraph. Paragraphs are
    /// separated by newlines or other paragraph separator characters.
    /// Display lines are created by line-wrapping a paragraph. If
    /// wrapping is turned off, display lines and paragraphs will be the
    /// same. Display lines are divided differently for each view, since
    /// they depend on the view’s width; paragraphs are the same in all
    /// views, since they depend on the contents of the `GtkTextBuffer`.
    func forwardDisplayLine(iter: TextIterProtocol) -> Bool {
        let rv = gtk_text_view_forward_display_line(cast(text_view_ptr), cast(iter.ptr))
        return Bool(rv != 0)
    }

    /// Moves the given `iter` forward to the next display line end.
    /// A display line is different from a paragraph. Paragraphs are
    /// separated by newlines or other paragraph separator characters.
    /// Display lines are created by line-wrapping a paragraph. If
    /// wrapping is turned off, display lines and paragraphs will be the
    /// same. Display lines are divided differently for each view, since
    /// they depend on the view’s width; paragraphs are the same in all
    /// views, since they depend on the contents of the `GtkTextBuffer`.
    func forwardDisplayLineEnd(iter: TextIterProtocol) -> Bool {
        let rv = gtk_text_view_forward_display_line_end(cast(text_view_ptr), cast(iter.ptr))
        return Bool(rv != 0)
    }

    /// Returns whether pressing the Tab key inserts a tab characters.
    /// `gtk_text_view_set_accepts_tab()`.
    func getAcceptsTab() -> Bool {
        let rv = gtk_text_view_get_accepts_tab(cast(text_view_ptr))
        return Bool(rv != 0)
    }

    /// Gets the width of the specified border window. See
    /// `gtk_text_view_set_border_window_size()`.
    func getBorderWindowSize(type: TextWindowType) -> CInt {
        let rv = gtk_text_view_get_border_window_size(cast(text_view_ptr), type)
        return CInt(rv)
    }

    /// Gets the bottom margin for text in the `text_view`.
    func getBottomMargin() -> CInt {
        let rv = gtk_text_view_get_bottom_margin(cast(text_view_ptr))
        return CInt(rv)
    }

    /// Returns the `GtkTextBuffer` being displayed by this text view.
    /// The reference count on the buffer is not incremented; the caller
    /// of this function won’t own a new reference.
    func getBuffer() -> UnsafeMutablePointer<GtkTextBuffer>! {
        let rv = gtk_text_view_get_buffer(cast(text_view_ptr))
        return cast(rv)
    }

    /// Given an `iter` within a text layout, determine the positions of the
    /// strong and weak cursors if the insertion point is at that
    /// iterator. The position of each cursor is stored as a zero-width
    /// rectangle. The strong cursor location is the location where
    /// characters of the directionality equal to the base direction of the
    /// paragraph are inserted.  The weak cursor location is the location
    /// where characters of the directionality opposite to the base
    /// direction of the paragraph are inserted.
    /// 
    /// If `iter` is `nil`, the actual cursor position is used.
    /// 
    /// Note that if `iter` happens to be the actual cursor position, and
    /// there is currently an IM preedit sequence being entered, the
    /// returned locations will be adjusted to account for the preedit
    /// cursor’s offset within the preedit sequence.
    /// 
    /// The rectangle position is in buffer coordinates; use
    /// `gtk_text_view_buffer_to_window_coords()` to convert these
    /// coordinates to coordinates for one of the windows in the text view.
    func getCursorLocations(iter: TextIterProtocol, strong: Gdk.RectangleProtocol, weak_: Gdk.RectangleProtocol) {
        gtk_text_view_get_cursor_locations(cast(text_view_ptr), cast(iter.ptr), cast(strong.ptr), cast(weak_.ptr))
    
    }

    /// Find out whether the cursor should be displayed.
    func getCursorVisible() -> Bool {
        let rv = gtk_text_view_get_cursor_visible(cast(text_view_ptr))
        return Bool(rv != 0)
    }

    /// Obtains a copy of the default text attributes. These are the
    /// attributes used for text unless a tag overrides them.
    /// You’d typically pass the default attributes in to
    /// `gtk_text_iter_get_attributes()` in order to get the
    /// attributes in effect at a given text position.
    /// 
    /// The return value is a copy owned by the caller of this function,
    /// and should be freed with `gtk_text_attributes_unref()`.
    func getDefaultAttributes() -> UnsafeMutablePointer<GtkTextAttributes>! {
        let rv = gtk_text_view_get_default_attributes(cast(text_view_ptr))
        return cast(rv)
    }

    /// Returns the default editability of the `GtkTextView`. Tags in the
    /// buffer may override this setting for some ranges of text.
    func getEditable() -> Bool {
        let rv = gtk_text_view_get_editable(cast(text_view_ptr))
        return Bool(rv != 0)
    }

    /// Gets the horizontal-scrolling `GtkAdjustment`.
    ///
    /// **get_hadjustment is deprecated:**
    /// Use gtk_scrollable_get_hadjustment()
    @available(*, deprecated) func getHadjustment() -> UnsafeMutablePointer<GtkAdjustment>! {
        let rv = gtk_text_view_get_hadjustment(cast(text_view_ptr))
        return cast(rv)
    }

    /// Gets the default indentation of paragraphs in `text_view`.
    /// Tags in the view’s buffer may override the default.
    /// The indentation may be negative.
    func getIndent() -> CInt {
        let rv = gtk_text_view_get_indent(cast(text_view_ptr))
        return CInt(rv)
    }

    /// Gets the value of the `GtkTextView:input`-hints property.
    func getInputHints() -> GtkInputHints {
        let rv = gtk_text_view_get_input_hints(cast(text_view_ptr))
        return rv
    }

    /// Gets the value of the `GtkTextView:input`-purpose property.
    func getInputPurpose() -> GtkInputPurpose {
        let rv = gtk_text_view_get_input_purpose(cast(text_view_ptr))
        return rv
    }

    /// Retrieves the iterator at buffer coordinates `x` and `y`. Buffer
    /// coordinates are coordinates for the entire buffer, not just the
    /// currently-displayed portion.  If you have coordinates from an
    /// event, you have to convert those to buffer coordinates with
    /// `gtk_text_view_window_to_buffer_coords()`.
    func getIterAtLocation(iter: TextIterProtocol, x: CInt, y: CInt) -> Bool {
        let rv = gtk_text_view_get_iter_at_location(cast(text_view_ptr), cast(iter.ptr), gint(x), gint(y))
        return Bool(rv != 0)
    }

    /// Retrieves the iterator pointing to the character at buffer
    /// coordinates `x` and `y`. Buffer coordinates are coordinates for
    /// the entire buffer, not just the currently-displayed portion.
    /// If you have coordinates from an event, you have to convert
    /// those to buffer coordinates with
    /// `gtk_text_view_window_to_buffer_coords()`.
    /// 
    /// Note that this is different from `gtk_text_view_get_iter_at_location()`,
    /// which returns cursor locations, i.e. positions between
    /// characters.
    func getIterAtPosition(iter: TextIterProtocol, trailing: UnsafeMutablePointer<CInt>, x: CInt, y: CInt) -> Bool {
        let rv = gtk_text_view_get_iter_at_position(cast(text_view_ptr), cast(iter.ptr), cast(trailing), gint(x), gint(y))
        return Bool(rv != 0)
    }

    /// Gets a rectangle which roughly contains the character at `iter`.
    /// The rectangle position is in buffer coordinates; use
    /// `gtk_text_view_buffer_to_window_coords()` to convert these
    /// coordinates to coordinates for one of the windows in the text view.
    func getIterLocation(iter: TextIterProtocol, location: Gdk.RectangleProtocol) {
        gtk_text_view_get_iter_location(cast(text_view_ptr), cast(iter.ptr), cast(location.ptr))
    
    }

    /// Gets the default justification of paragraphs in `text_view`.
    /// Tags in the buffer may override the default.
    func getJustification() -> GtkJustification {
        let rv = gtk_text_view_get_justification(cast(text_view_ptr))
        return rv
    }

    /// Gets the default left margin size of paragraphs in the `text_view`.
    /// Tags in the buffer may override the default.
    func getLeftMargin() -> CInt {
        let rv = gtk_text_view_get_left_margin(cast(text_view_ptr))
        return CInt(rv)
    }

    /// Gets the `GtkTextIter` at the start of the line containing
    /// the coordinate `y`. `y` is in buffer coordinates, convert from
    /// window coordinates with `gtk_text_view_window_to_buffer_coords()`.
    /// If non-`nil`, `line_top` will be filled with the coordinate of the top
    /// edge of the line.
    func getLineAtY(targetIter target_iter: TextIterProtocol, y: CInt, lineTop line_top: UnsafeMutablePointer<CInt>) {
        gtk_text_view_get_line_at_y(cast(text_view_ptr), cast(target_iter.ptr), gint(y), cast(line_top))
    
    }

    /// Gets the y coordinate of the top of the line containing `iter`,
    /// and the height of the line. The coordinate is a buffer coordinate;
    /// convert to window coordinates with `gtk_text_view_buffer_to_window_coords()`.
    func getLineYrange(iter: TextIterProtocol, y: UnsafeMutablePointer<CInt>, height: UnsafeMutablePointer<CInt>) {
        gtk_text_view_get_line_yrange(cast(text_view_ptr), cast(iter.ptr), cast(y), cast(height))
    
    }

    /// Gets the value of the `GtkTextView:monospace` property.
    func getMonospace() -> Bool {
        let rv = gtk_text_view_get_monospace(cast(text_view_ptr))
        return Bool(rv != 0)
    }

    /// Returns whether the `GtkTextView` is in overwrite mode or not.
    func getOverwrite() -> Bool {
        let rv = gtk_text_view_get_overwrite(cast(text_view_ptr))
        return Bool(rv != 0)
    }

    /// Gets the default number of pixels to put above paragraphs.
    /// Adding this function with `gtk_text_view_get_pixels_below_lines()`
    /// is equal to the line space between each paragraph.
    func getPixelsAboveLines() -> CInt {
        let rv = gtk_text_view_get_pixels_above_lines(cast(text_view_ptr))
        return CInt(rv)
    }

    /// Gets the value set by `gtk_text_view_set_pixels_below_lines()`.
    /// 
    /// The line space is the sum of the value returned by this function and the
    /// value returned by `gtk_text_view_get_pixels_above_lines()`.
    func getPixelsBelowLines() -> CInt {
        let rv = gtk_text_view_get_pixels_below_lines(cast(text_view_ptr))
        return CInt(rv)
    }

    /// Gets the value set by `gtk_text_view_set_pixels_inside_wrap()`.
    func getPixelsInsideWrap() -> CInt {
        let rv = gtk_text_view_get_pixels_inside_wrap(cast(text_view_ptr))
        return CInt(rv)
    }

    /// Gets the default right margin for text in `text_view`. Tags
    /// in the buffer may override the default.
    func getRightMargin() -> CInt {
        let rv = gtk_text_view_get_right_margin(cast(text_view_ptr))
        return CInt(rv)
    }

    /// Gets the default tabs for `text_view`. Tags in the buffer may
    /// override the defaults. The returned array will be `nil` if
    /// “standard” (8-space) tabs are used. Free the return value
    /// with `pango_tab_array_free()`.
    func getTabs() -> UnsafeMutablePointer<PangoTabArray>! {
        let rv = gtk_text_view_get_tabs(cast(text_view_ptr))
        return cast(rv)
    }

    /// Gets the top margin for text in the `text_view`.
    func getTopMargin() -> CInt {
        let rv = gtk_text_view_get_top_margin(cast(text_view_ptr))
        return CInt(rv)
    }

    /// Gets the vertical-scrolling `GtkAdjustment`.
    ///
    /// **get_vadjustment is deprecated:**
    /// Use gtk_scrollable_get_vadjustment()
    @available(*, deprecated) func getVadjustment() -> UnsafeMutablePointer<GtkAdjustment>! {
        let rv = gtk_text_view_get_vadjustment(cast(text_view_ptr))
        return cast(rv)
    }

    /// Fills `visible_rect` with the currently-visible
    /// region of the buffer, in buffer coordinates. Convert to window coordinates
    /// with `gtk_text_view_buffer_to_window_coords()`.
    func get(visibleRect visible_rect: Gdk.RectangleProtocol) {
        gtk_text_view_get_visible_rect(cast(text_view_ptr), cast(visible_rect.ptr))
    
    }

    /// Retrieves the `GdkWindow` corresponding to an area of the text view;
    /// possible windows include the overall widget window, child windows
    /// on the left, right, top, bottom, and the window that displays the
    /// text buffer. Windows are `nil` and nonexistent if their width or
    /// height is 0, and are nonexistent before the widget has been
    /// realized.
    func getWindow(win: TextWindowType) -> UnsafeMutablePointer<GdkWindow>! {
        let rv = gtk_text_view_get_window(cast(text_view_ptr), win)
        return cast(rv)
    }

    /// Usually used to find out which window an event corresponds to.
    /// 
    /// If you connect to an event signal on `text_view`, this function
    /// should be called on `event->window` to see which window it was.
    func getWindowType(window: WindowProtocol) -> GtkTextWindowType {
        let rv = gtk_text_view_get_window_type(cast(text_view_ptr), cast(window.ptr))
        return rv
    }

    /// Gets the line wrapping for the view.
    func getWrapMode() -> GtkWrapMode {
        let rv = gtk_text_view_get_wrap_mode(cast(text_view_ptr))
        return rv
    }

    /// Allow the `GtkTextView` input method to internally handle key press
    /// and release events. If this function returns `true`, then no further
    /// processing should be done for this key event. See
    /// `gtk_im_context_filter_keypress()`.
    /// 
    /// Note that you are expected to call this function from your handler
    /// when overriding key event handling. This is needed in the case when
    /// you need to insert your own key handling between the input method
    /// and the default key event handling of the `GtkTextView`.
    /// 
    /// (C Language Example):
    /// ```C
    /// static gboolean
    /// gtk_foo_bar_key_press_event (GtkWidget   *widget,
    ///                              GdkEventKey *event)
    /// {
    ///   guint keyval;
    /// 
    ///   gdk_event_get_keyval ((GdkEvent*)event, &keyval);
    /// 
    ///   if (keyval == GDK_KEY_Return || keyval == GDK_KEY_KP_Enter)
    ///     {
    ///       if (gtk_text_view_im_context_filter_keypress (GTK_TEXT_VIEW (widget), event))
    ///         return TRUE;
    ///     }
    /// 
    ///   // Do some stuff
    /// 
    ///   return GTK_WIDGET_CLASS (gtk_foo_bar_parent_class)->key_press_event (widget, event);
    /// }
    /// ```
    /// 
    func imContextFilterKeypress(event: EventKeyProtocol) -> Bool {
        let rv = gtk_text_view_im_context_filter_keypress(cast(text_view_ptr), cast(event.ptr))
        return Bool(rv != 0)
    }

    /// Updates the position of a child, as for `gtk_text_view_add_child_in_window()`.
    func move(child: WidgetProtocol, xpos: CInt, ypos: CInt) {
        gtk_text_view_move_child(cast(text_view_ptr), cast(child.ptr), gint(xpos), gint(ypos))
    
    }

    /// Moves a mark within the buffer so that it's
    /// located within the currently-visible text area.
    func moveMarkOnscreen(mark: TextMarkProtocol) -> Bool {
        let rv = gtk_text_view_move_mark_onscreen(cast(text_view_ptr), cast(mark.ptr))
        return Bool(rv != 0)
    }

    /// Move the iterator a given number of characters visually, treating
    /// it as the strong cursor position. If `count` is positive, then the
    /// new strong cursor position will be `count` positions to the right of
    /// the old cursor position. If `count` is negative then the new strong
    /// cursor position will be `count` positions to the left of the old
    /// cursor position.
    /// 
    /// In the presence of bi-directional text, the correspondence
    /// between logical and visual order will depend on the direction
    /// of the current run, and there may be jumps when the cursor
    /// is moved off of the end of a run.
    func moveVisually(iter: TextIterProtocol, count: CInt) -> Bool {
        let rv = gtk_text_view_move_visually(cast(text_view_ptr), cast(iter.ptr), gint(count))
        return Bool(rv != 0)
    }

    /// Moves the cursor to the currently visible region of the
    /// buffer, it it isn’t there already.
    func placeCursorOnscreen() -> Bool {
        let rv = gtk_text_view_place_cursor_onscreen(cast(text_view_ptr))
        return Bool(rv != 0)
    }

    /// Ensures that the cursor is shown (i.e. not in an 'off' blink
    /// interval) and resets the time that it will stay blinking (or
    /// visible, in case blinking is disabled).
    /// 
    /// This function should be called in response to user input
    /// (e.g. from derived classes that override the textview's
    /// `GtkWidget::key`-press-event handler).
    func resetCursorBlink() {
        gtk_text_view_reset_cursor_blink(cast(text_view_ptr))
    
    }

    /// Reset the input method context of the text view if needed.
    /// 
    /// This can be necessary in the case where modifying the buffer
    /// would confuse on-going input method behavior.
    func resetImContext() {
        gtk_text_view_reset_im_context(cast(text_view_ptr))
    
    }

    /// Scrolls `text_view` the minimum distance such that `mark` is contained
    /// within the visible area of the widget.
    func scrollMarkOnscreen(mark: TextMarkProtocol) {
        gtk_text_view_scroll_mark_onscreen(cast(text_view_ptr), cast(mark.ptr))
    
    }

    /// Scrolls `text_view` so that `iter` is on the screen in the position
    /// indicated by `xalign` and `yalign`. An alignment of 0.0 indicates
    /// left or top, 1.0 indicates right or bottom, 0.5 means center.
    /// If `use_align` is `false`, the text scrolls the minimal distance to
    /// get the mark onscreen, possibly not scrolling at all. The effective
    /// screen for purposes of this function is reduced by a margin of size
    /// `within_margin`.
    /// 
    /// Note that this function uses the currently-computed height of the
    /// lines in the text buffer. Line heights are computed in an idle
    /// handler; so this function may not have the desired effect if it’s
    /// called before the height computations. To avoid oddness, consider
    /// using `gtk_text_view_scroll_to_mark()` which saves a point to be
    /// scrolled to after line validation.
    func scrollTo(iter: TextIterProtocol, withinMargin within_margin: gdouble, useAlign use_align: Bool, xalign: gdouble, yalign: gdouble) -> Bool {
        let rv = gtk_text_view_scroll_to_iter(cast(text_view_ptr), cast(iter.ptr), within_margin, gboolean(use_align ? 1 : 0), xalign, yalign)
        return Bool(rv != 0)
    }

    /// Scrolls `text_view` so that `mark` is on the screen in the position
    /// indicated by `xalign` and `yalign`. An alignment of 0.0 indicates
    /// left or top, 1.0 indicates right or bottom, 0.5 means center.
    /// If `use_align` is `false`, the text scrolls the minimal distance to
    /// get the mark onscreen, possibly not scrolling at all. The effective
    /// screen for purposes of this function is reduced by a margin of size
    /// `within_margin`.
    func scrollTo(mark: TextMarkProtocol, withinMargin within_margin: gdouble, useAlign use_align: Bool, xalign: gdouble, yalign: gdouble) {
        gtk_text_view_scroll_to_mark(cast(text_view_ptr), cast(mark.ptr), within_margin, gboolean(use_align ? 1 : 0), xalign, yalign)
    
    }

    /// Sets the behavior of the text widget when the Tab key is pressed.
    /// If `accepts_tab` is `true`, a tab character is inserted. If `accepts_tab`
    /// is `false` the keyboard focus is moved to the next widget in the focus
    /// chain.
    func set(acceptsTab accepts_tab: Bool) {
        gtk_text_view_set_accepts_tab(cast(text_view_ptr), gboolean(accepts_tab ? 1 : 0))
    
    }

    /// Sets the width of `GTK_TEXT_WINDOW_LEFT` or `GTK_TEXT_WINDOW_RIGHT`,
    /// or the height of `GTK_TEXT_WINDOW_TOP` or `GTK_TEXT_WINDOW_BOTTOM`.
    /// Automatically destroys the corresponding window if the size is set
    /// to 0, and creates the window if the size is set to non-zero.  This
    /// function can only be used for the “border windows”, and it won’t
    /// work with `GTK_TEXT_WINDOW_WIDGET`, `GTK_TEXT_WINDOW_TEXT`, or
    /// `GTK_TEXT_WINDOW_PRIVATE`.
    func setBorderWindowSize(type: TextWindowType, size: CInt) {
        gtk_text_view_set_border_window_size(cast(text_view_ptr), type, gint(size))
    
    }

    /// Sets the bottom margin for text in `text_view`.
    /// 
    /// Note that this function is confusingly named.
    /// In CSS terms, the value set here is padding.
    func set(bottomMargin bottom_margin: CInt) {
        gtk_text_view_set_bottom_margin(cast(text_view_ptr), gint(bottom_margin))
    
    }

    /// Sets `buffer` as the buffer being displayed by `text_view`. The previous
    /// buffer displayed by the text view is unreferenced, and a reference is
    /// added to `buffer`. If you owned a reference to `buffer` before passing it
    /// to this function, you must remove that reference yourself; `GtkTextView`
    /// will not “adopt” it.
    func set(buffer: TextBufferProtocol) {
        gtk_text_view_set_buffer(cast(text_view_ptr), cast(buffer.ptr))
    
    }

    /// Toggles whether the insertion point should be displayed. A buffer with
    /// no editable text probably shouldn’t have a visible cursor, so you may
    /// want to turn the cursor off.
    /// 
    /// Note that this property may be overridden by the
    /// `GtkSettings:gtk`-keynave-use-caret settings.
    func setCursorVisible(setting: Bool) {
        gtk_text_view_set_cursor_visible(cast(text_view_ptr), gboolean(setting ? 1 : 0))
    
    }

    /// Sets the default editability of the `GtkTextView`. You can override
    /// this default setting with tags in the buffer, using the “editable”
    /// attribute of tags.
    func setEditable(setting: Bool) {
        gtk_text_view_set_editable(cast(text_view_ptr), gboolean(setting ? 1 : 0))
    
    }

    /// Sets the default indentation for paragraphs in `text_view`.
    /// Tags in the buffer may override the default.
    func set(indent: CInt) {
        gtk_text_view_set_indent(cast(text_view_ptr), gint(indent))
    
    }

    /// Sets the `GtkTextView:input`-hints property, which
    /// allows input methods to fine-tune their behaviour.
    func setInput(hints: InputHints) {
        gtk_text_view_set_input_hints(cast(text_view_ptr), hints)
    
    }

    /// Sets the `GtkTextView:input`-purpose property which
    /// can be used by on-screen keyboards and other input
    /// methods to adjust their behaviour.
    func setInput(purpose: InputPurpose) {
        gtk_text_view_set_input_purpose(cast(text_view_ptr), purpose)
    
    }

    /// Sets the default justification of text in `text_view`.
    /// Tags in the view’s buffer may override the default.
    func set(justification: Justification) {
        gtk_text_view_set_justification(cast(text_view_ptr), justification)
    
    }

    /// Sets the default left margin for text in `text_view`.
    /// Tags in the buffer may override the default.
    /// 
    /// Note that this function is confusingly named.
    /// In CSS terms, the value set here is padding.
    func set(leftMargin left_margin: CInt) {
        gtk_text_view_set_left_margin(cast(text_view_ptr), gint(left_margin))
    
    }

    /// Sets the `GtkTextView:monospace` property, which
    /// indicates that the text view should use monospace
    /// fonts.
    func set(monospace: Bool) {
        gtk_text_view_set_monospace(cast(text_view_ptr), gboolean(monospace ? 1 : 0))
    
    }

    /// Changes the `GtkTextView` overwrite mode.
    func set(overwrite: Bool) {
        gtk_text_view_set_overwrite(cast(text_view_ptr), gboolean(overwrite ? 1 : 0))
    
    }

    /// Sets the default number of blank pixels above paragraphs in `text_view`.
    /// Tags in the buffer for `text_view` may override the defaults.
    func set(pixelsAboveLines pixels_above_lines: CInt) {
        gtk_text_view_set_pixels_above_lines(cast(text_view_ptr), gint(pixels_above_lines))
    
    }

    /// Sets the default number of pixels of blank space
    /// to put below paragraphs in `text_view`. May be overridden
    /// by tags applied to `text_view`’s buffer.
    func set(pixelsBelowLines pixels_below_lines: CInt) {
        gtk_text_view_set_pixels_below_lines(cast(text_view_ptr), gint(pixels_below_lines))
    
    }

    /// Sets the default number of pixels of blank space to leave between
    /// display/wrapped lines within a paragraph. May be overridden by
    /// tags in `text_view`’s buffer.
    func set(pixelsInsideWrap pixels_inside_wrap: CInt) {
        gtk_text_view_set_pixels_inside_wrap(cast(text_view_ptr), gint(pixels_inside_wrap))
    
    }

    /// Sets the default right margin for text in the text view.
    /// Tags in the buffer may override the default.
    /// 
    /// Note that this function is confusingly named.
    /// In CSS terms, the value set here is padding.
    func set(rightMargin right_margin: CInt) {
        gtk_text_view_set_right_margin(cast(text_view_ptr), gint(right_margin))
    
    }

    /// Sets the default tab stops for paragraphs in `text_view`.
    /// Tags in the buffer may override the default.
    func set(tabs: TabArrayProtocol) {
        gtk_text_view_set_tabs(cast(text_view_ptr), cast(tabs.ptr))
    
    }

    /// Sets the top margin for text in `text_view`.
    /// 
    /// Note that this function is confusingly named.
    /// In CSS terms, the value set here is padding.
    func set(topMargin top_margin: CInt) {
        gtk_text_view_set_top_margin(cast(text_view_ptr), gint(top_margin))
    
    }

    /// Sets the line wrapping for the view.
    func set(wrapMode wrap_mode: WrapMode) {
        gtk_text_view_set_wrap_mode(cast(text_view_ptr), wrap_mode)
    
    }

    /// Determines whether `iter` is at the start of a display line.
    /// See `gtk_text_view_forward_display_line()` for an explanation of
    /// display lines vs. paragraphs.
    func startsDisplayLine(iter: TextIterProtocol) -> Bool {
        let rv = gtk_text_view_starts_display_line(cast(text_view_ptr), cast(iter.ptr))
        return Bool(rv != 0)
    }

    /// Converts coordinates on the window identified by `win` to buffer
    /// coordinates, storing the result in (`buffer_x`,`buffer_y`).
    /// 
    /// Note that you can’t convert coordinates for a nonexisting window (see
    /// `gtk_text_view_set_border_window_size()`).
    func windowToBufferCoords(win: TextWindowType, windowX window_x: CInt, windowY window_y: CInt, bufferX buffer_x: UnsafeMutablePointer<CInt>, bufferY buffer_y: UnsafeMutablePointer<CInt>) {
        gtk_text_view_window_to_buffer_coords(cast(text_view_ptr), win, gint(window_x), gint(window_y), cast(buffer_x), cast(buffer_y))
    
    }
    /// Returns whether pressing the Tab key inserts a tab characters.
    /// `gtk_text_view_set_accepts_tab()`.
    var acceptsTab: Bool {
        /// Returns whether pressing the Tab key inserts a tab characters.
        /// `gtk_text_view_set_accepts_tab()`.
        get {
            let rv = gtk_text_view_get_accepts_tab(cast(text_view_ptr))
            return Bool(rv != 0)
        }
        /// Sets the behavior of the text widget when the Tab key is pressed.
        /// If `accepts_tab` is `true`, a tab character is inserted. If `accepts_tab`
        /// is `false` the keyboard focus is moved to the next widget in the focus
        /// chain.
        nonmutating set {
            gtk_text_view_set_accepts_tab(cast(text_view_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Gets the bottom margin for text in the `text_view`.
    var bottomMargin: CInt {
        /// Gets the bottom margin for text in the `text_view`.
        get {
            let rv = gtk_text_view_get_bottom_margin(cast(text_view_ptr))
            return CInt(rv)
        }
        /// Sets the bottom margin for text in `text_view`.
        /// 
        /// Note that this function is confusingly named.
        /// In CSS terms, the value set here is padding.
        nonmutating set {
            gtk_text_view_set_bottom_margin(cast(text_view_ptr), gint(newValue))
        }
    }

    var buffer: UnsafeMutablePointer<GtkTextBuffer>! {
        /// Returns the `GtkTextBuffer` being displayed by this text view.
        /// The reference count on the buffer is not incremented; the caller
        /// of this function won’t own a new reference.
        get {
            let rv = gtk_text_view_get_buffer(cast(text_view_ptr))
            return cast(rv)
        }
        /// Sets `buffer` as the buffer being displayed by `text_view`. The previous
        /// buffer displayed by the text view is unreferenced, and a reference is
        /// added to `buffer`. If you owned a reference to `buffer` before passing it
        /// to this function, you must remove that reference yourself; `GtkTextView`
        /// will not “adopt” it.
        nonmutating set {
            gtk_text_view_set_buffer(cast(text_view_ptr), cast(newValue))
        }
    }

    /// Find out whether the cursor should be displayed.
    var cursorVisible: Bool {
        /// Find out whether the cursor should be displayed.
        get {
            let rv = gtk_text_view_get_cursor_visible(cast(text_view_ptr))
            return Bool(rv != 0)
        }
        /// Toggles whether the insertion point should be displayed. A buffer with
        /// no editable text probably shouldn’t have a visible cursor, so you may
        /// want to turn the cursor off.
        /// 
        /// Note that this property may be overridden by the
        /// `GtkSettings:gtk`-keynave-use-caret settings.
        nonmutating set {
            gtk_text_view_set_cursor_visible(cast(text_view_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Obtains a copy of the default text attributes. These are the
    /// attributes used for text unless a tag overrides them.
    /// You’d typically pass the default attributes in to
    /// `gtk_text_iter_get_attributes()` in order to get the
    /// attributes in effect at a given text position.
    /// 
    /// The return value is a copy owned by the caller of this function,
    /// and should be freed with `gtk_text_attributes_unref()`.
    var defaultAttributes: UnsafeMutablePointer<GtkTextAttributes>! {
        /// Obtains a copy of the default text attributes. These are the
        /// attributes used for text unless a tag overrides them.
        /// You’d typically pass the default attributes in to
        /// `gtk_text_iter_get_attributes()` in order to get the
        /// attributes in effect at a given text position.
        /// 
        /// The return value is a copy owned by the caller of this function,
        /// and should be freed with `gtk_text_attributes_unref()`.
        get {
            let rv = gtk_text_view_get_default_attributes(cast(text_view_ptr))
            return cast(rv)
        }
    }

    var editable: Bool {
        /// Returns the default editability of the `GtkTextView`. Tags in the
        /// buffer may override this setting for some ranges of text.
        get {
            let rv = gtk_text_view_get_editable(cast(text_view_ptr))
            return Bool(rv != 0)
        }
        /// Sets the default editability of the `GtkTextView`. You can override
        /// this default setting with tags in the buffer, using the “editable”
        /// attribute of tags.
        nonmutating set {
            gtk_text_view_set_editable(cast(text_view_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Gets the horizontal-scrolling `GtkAdjustment`.
    ///
    /// **get_hadjustment is deprecated:**
    /// Use gtk_scrollable_get_hadjustment()
    var hadjustment: UnsafeMutablePointer<GtkAdjustment>! {
        /// Gets the horizontal-scrolling `GtkAdjustment`.
        ///
        /// **get_hadjustment is deprecated:**
        /// Use gtk_scrollable_get_hadjustment()
        @available(*, deprecated) get {
            let rv = gtk_text_view_get_hadjustment(cast(text_view_ptr))
            return cast(rv)
        }
    }

    var indent: CInt {
        /// Gets the default indentation of paragraphs in `text_view`.
        /// Tags in the view’s buffer may override the default.
        /// The indentation may be negative.
        get {
            let rv = gtk_text_view_get_indent(cast(text_view_ptr))
            return CInt(rv)
        }
        /// Sets the default indentation for paragraphs in `text_view`.
        /// Tags in the buffer may override the default.
        nonmutating set {
            gtk_text_view_set_indent(cast(text_view_ptr), gint(newValue))
        }
    }

    /// Gets the value of the `GtkTextView:input`-hints property.
    var inputHints: GtkInputHints {
        /// Gets the value of the `GtkTextView:input`-hints property.
        get {
            let rv = gtk_text_view_get_input_hints(cast(text_view_ptr))
            return rv
        }
        /// Sets the `GtkTextView:input`-hints property, which
        /// allows input methods to fine-tune their behaviour.
        nonmutating set {
            gtk_text_view_set_input_hints(cast(text_view_ptr), newValue)
        }
    }

    /// Gets the value of the `GtkTextView:input`-purpose property.
    var inputPurpose: GtkInputPurpose {
        /// Gets the value of the `GtkTextView:input`-purpose property.
        get {
            let rv = gtk_text_view_get_input_purpose(cast(text_view_ptr))
            return rv
        }
        /// Sets the `GtkTextView:input`-purpose property which
        /// can be used by on-screen keyboards and other input
        /// methods to adjust their behaviour.
        nonmutating set {
            gtk_text_view_set_input_purpose(cast(text_view_ptr), newValue)
        }
    }

    var justification: GtkJustification {
        /// Gets the default justification of paragraphs in `text_view`.
        /// Tags in the buffer may override the default.
        get {
            let rv = gtk_text_view_get_justification(cast(text_view_ptr))
            return rv
        }
        /// Sets the default justification of text in `text_view`.
        /// Tags in the view’s buffer may override the default.
        nonmutating set {
            gtk_text_view_set_justification(cast(text_view_ptr), newValue)
        }
    }

    /// Gets the default left margin size of paragraphs in the `text_view`.
    /// Tags in the buffer may override the default.
    var leftMargin: CInt {
        /// Gets the default left margin size of paragraphs in the `text_view`.
        /// Tags in the buffer may override the default.
        get {
            let rv = gtk_text_view_get_left_margin(cast(text_view_ptr))
            return CInt(rv)
        }
        /// Sets the default left margin for text in `text_view`.
        /// Tags in the buffer may override the default.
        /// 
        /// Note that this function is confusingly named.
        /// In CSS terms, the value set here is padding.
        nonmutating set {
            gtk_text_view_set_left_margin(cast(text_view_ptr), gint(newValue))
        }
    }

    var monospace: Bool {
        /// Gets the value of the `GtkTextView:monospace` property.
        get {
            let rv = gtk_text_view_get_monospace(cast(text_view_ptr))
            return Bool(rv != 0)
        }
        /// Sets the `GtkTextView:monospace` property, which
        /// indicates that the text view should use monospace
        /// fonts.
        nonmutating set {
            gtk_text_view_set_monospace(cast(text_view_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    var overwrite: Bool {
        /// Returns whether the `GtkTextView` is in overwrite mode or not.
        get {
            let rv = gtk_text_view_get_overwrite(cast(text_view_ptr))
            return Bool(rv != 0)
        }
        /// Changes the `GtkTextView` overwrite mode.
        nonmutating set {
            gtk_text_view_set_overwrite(cast(text_view_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Gets the default number of pixels to put above paragraphs.
    /// Adding this function with `gtk_text_view_get_pixels_below_lines()`
    /// is equal to the line space between each paragraph.
    var pixelsAboveLines: CInt {
        /// Gets the default number of pixels to put above paragraphs.
        /// Adding this function with `gtk_text_view_get_pixels_below_lines()`
        /// is equal to the line space between each paragraph.
        get {
            let rv = gtk_text_view_get_pixels_above_lines(cast(text_view_ptr))
            return CInt(rv)
        }
        /// Sets the default number of blank pixels above paragraphs in `text_view`.
        /// Tags in the buffer for `text_view` may override the defaults.
        nonmutating set {
            gtk_text_view_set_pixels_above_lines(cast(text_view_ptr), gint(newValue))
        }
    }

    /// Gets the value set by `gtk_text_view_set_pixels_below_lines()`.
    /// 
    /// The line space is the sum of the value returned by this function and the
    /// value returned by `gtk_text_view_get_pixels_above_lines()`.
    var pixelsBelowLines: CInt {
        /// Gets the value set by `gtk_text_view_set_pixels_below_lines()`.
        /// 
        /// The line space is the sum of the value returned by this function and the
        /// value returned by `gtk_text_view_get_pixels_above_lines()`.
        get {
            let rv = gtk_text_view_get_pixels_below_lines(cast(text_view_ptr))
            return CInt(rv)
        }
        /// Sets the default number of pixels of blank space
        /// to put below paragraphs in `text_view`. May be overridden
        /// by tags applied to `text_view`’s buffer.
        nonmutating set {
            gtk_text_view_set_pixels_below_lines(cast(text_view_ptr), gint(newValue))
        }
    }

    /// Gets the value set by `gtk_text_view_set_pixels_inside_wrap()`.
    var pixelsInsideWrap: CInt {
        /// Gets the value set by `gtk_text_view_set_pixels_inside_wrap()`.
        get {
            let rv = gtk_text_view_get_pixels_inside_wrap(cast(text_view_ptr))
            return CInt(rv)
        }
        /// Sets the default number of pixels of blank space to leave between
        /// display/wrapped lines within a paragraph. May be overridden by
        /// tags in `text_view`’s buffer.
        nonmutating set {
            gtk_text_view_set_pixels_inside_wrap(cast(text_view_ptr), gint(newValue))
        }
    }

    /// Gets the default right margin for text in `text_view`. Tags
    /// in the buffer may override the default.
    var rightMargin: CInt {
        /// Gets the default right margin for text in `text_view`. Tags
        /// in the buffer may override the default.
        get {
            let rv = gtk_text_view_get_right_margin(cast(text_view_ptr))
            return CInt(rv)
        }
        /// Sets the default right margin for text in the text view.
        /// Tags in the buffer may override the default.
        /// 
        /// Note that this function is confusingly named.
        /// In CSS terms, the value set here is padding.
        nonmutating set {
            gtk_text_view_set_right_margin(cast(text_view_ptr), gint(newValue))
        }
    }

    var tabs: UnsafeMutablePointer<PangoTabArray>! {
        /// Gets the default tabs for `text_view`. Tags in the buffer may
        /// override the defaults. The returned array will be `nil` if
        /// “standard” (8-space) tabs are used. Free the return value
        /// with `pango_tab_array_free()`.
        get {
            let rv = gtk_text_view_get_tabs(cast(text_view_ptr))
            return cast(rv)
        }
        /// Sets the default tab stops for paragraphs in `text_view`.
        /// Tags in the buffer may override the default.
        nonmutating set {
            gtk_text_view_set_tabs(cast(text_view_ptr), cast(newValue))
        }
    }

    /// Gets the top margin for text in the `text_view`.
    var topMargin: CInt {
        /// Gets the top margin for text in the `text_view`.
        get {
            let rv = gtk_text_view_get_top_margin(cast(text_view_ptr))
            return CInt(rv)
        }
        /// Sets the top margin for text in `text_view`.
        /// 
        /// Note that this function is confusingly named.
        /// In CSS terms, the value set here is padding.
        nonmutating set {
            gtk_text_view_set_top_margin(cast(text_view_ptr), gint(newValue))
        }
    }

    /// Gets the vertical-scrolling `GtkAdjustment`.
    ///
    /// **get_vadjustment is deprecated:**
    /// Use gtk_scrollable_get_vadjustment()
    var vadjustment: UnsafeMutablePointer<GtkAdjustment>! {
        /// Gets the vertical-scrolling `GtkAdjustment`.
        ///
        /// **get_vadjustment is deprecated:**
        /// Use gtk_scrollable_get_vadjustment()
        @available(*, deprecated) get {
            let rv = gtk_text_view_get_vadjustment(cast(text_view_ptr))
            return cast(rv)
        }
    }

    /// Gets the line wrapping for the view.
    var wrapMode: GtkWrapMode {
        /// Gets the line wrapping for the view.
        get {
            let rv = gtk_text_view_get_wrap_mode(cast(text_view_ptr))
            return rv
        }
        /// Sets the line wrapping for the view.
        nonmutating set {
            gtk_text_view_set_wrap_mode(cast(text_view_ptr), newValue)
        }
    }
}



// MARK: - TextViewAccessible Class

/// The `TextViewAccessibleProtocol` protocol exposes the methods and properties of an underlying `GtkTextViewAccessible` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextViewAccessible`.
/// Alternatively, use `TextViewAccessibleRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///

public protocol TextViewAccessibleProtocol: ContainerAccessibleProtocol, Atk.EditableTextProtocol, Atk.StreamableContentProtocol, Atk.TextProtocol {
    /// Untyped pointer to the underlying `GtkTextViewAccessible` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkTextViewAccessible` instance.
    var text_view_accessible_ptr: UnsafeMutablePointer<GtkTextViewAccessible> { get }
}

/// The `TextViewAccessibleRef` type acts as a lightweight Swift reference to an underlying `GtkTextViewAccessible` instance.
/// It exposes methods that can operate on this data type through `TextViewAccessibleProtocol` conformance.
/// Use `TextViewAccessibleRef` only as an `unowned` reference to an existing `GtkTextViewAccessible` instance.
///

public struct TextViewAccessibleRef: TextViewAccessibleProtocol {
    /// Untyped pointer to the underlying `GtkTextViewAccessible` instance.
    /// For type-safe access, use the generated, typed pointer `text_view_accessible_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension TextViewAccessibleRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkTextViewAccessible>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `TextViewAccessibleProtocol`
    init<T: TextViewAccessibleProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewAccessibleProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewAccessibleProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewAccessibleProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewAccessibleProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewAccessibleProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `TextViewAccessible` type acts as a reference-counted owner of an underlying `GtkTextViewAccessible` instance.
/// It provides the methods that can operate on this data type through `TextViewAccessibleProtocol` conformance.
/// Use `TextViewAccessible` as a strong reference or owner of a `GtkTextViewAccessible` instance.
///

open class TextViewAccessible: ContainerAccessible, TextViewAccessibleProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `TextViewAccessible` instance.
    public init(_ op: UnsafeMutablePointer<GtkTextViewAccessible>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `TextViewAccessibleProtocol`
    /// Will retain `GtkTextViewAccessible`.
    public convenience init<T: TextViewAccessibleProtocol>(_ other: T) {
        self.init(cast(other.text_view_accessible_ptr))
        g_object_ref(cast(text_view_accessible_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewAccessibleProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkTextViewAccessible.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewAccessibleProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkTextViewAccessible.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewAccessibleProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkTextViewAccessible.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewAccessibleProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkTextViewAccessible>(opaquePointer))
    }



}

public enum TextViewAccessiblePropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case widget = "widget"
}

public extension TextViewAccessibleProtocol {
    /// Bind a `TextViewAccessiblePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TextViewAccessiblePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(text_view_accessible_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum TextViewAccessibleSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyWidget = "notify::widget"
}

public extension TextViewAccessibleProtocol {
    /// Connect a `TextViewAccessibleSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: TextViewAccessibleSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(text_view_accessible_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension TextViewAccessibleProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextViewAccessible` instance.
    var text_view_accessible_ptr: UnsafeMutablePointer<GtkTextViewAccessible> { return ptr.assumingMemoryBound(to: GtkTextViewAccessible.self) }

}



// MARK: - ThemingEngine Class

/// The `ThemingEngineProtocol` protocol exposes the methods and properties of an underlying `GtkThemingEngine` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ThemingEngine`.
/// Alternatively, use `ThemingEngineRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkThemingEngine` was the object used for rendering themed content
/// in GTK+ widgets. It used to allow overriding GTK+'s default
/// implementation of rendering functions by allowing engines to be
/// loaded as modules.
/// 
/// `GtkThemingEngine` has been deprecated in GTK+ 3.14 and will be
/// ignored for rendering. The advancements in CSS theming are good
/// enough to allow themers to achieve their goals without the need
/// to modify source code.
public protocol ThemingEngineProtocol: GLibObject.ObjectProtocol {
    /// Untyped pointer to the underlying `GtkThemingEngine` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkThemingEngine` instance.
    var theming_engine_ptr: UnsafeMutablePointer<GtkThemingEngine> { get }
}

/// The `ThemingEngineRef` type acts as a lightweight Swift reference to an underlying `GtkThemingEngine` instance.
/// It exposes methods that can operate on this data type through `ThemingEngineProtocol` conformance.
/// Use `ThemingEngineRef` only as an `unowned` reference to an existing `GtkThemingEngine` instance.
///
/// `GtkThemingEngine` was the object used for rendering themed content
/// in GTK+ widgets. It used to allow overriding GTK+'s default
/// implementation of rendering functions by allowing engines to be
/// loaded as modules.
/// 
/// `GtkThemingEngine` has been deprecated in GTK+ 3.14 and will be
/// ignored for rendering. The advancements in CSS theming are good
/// enough to allow themers to achieve their goals without the need
/// to modify source code.
public struct ThemingEngineRef: ThemingEngineProtocol {
    /// Untyped pointer to the underlying `GtkThemingEngine` instance.
    /// For type-safe access, use the generated, typed pointer `theming_engine_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension ThemingEngineRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkThemingEngine>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `ThemingEngineProtocol`
    init<T: ThemingEngineProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ThemingEngineProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ThemingEngineProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ThemingEngineProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ThemingEngineProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ThemingEngineProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Loads and initializes a theming engine module from the
    /// standard directories.
    ///
    /// **load is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) static func load(name: UnsafePointer<gchar>) -> ThemingEngineRef! {
        let rv = gtk_theming_engine_load(name)
        return rv.map { ThemingEngineRef(cast($0)) }
    }
}

/// The `ThemingEngine` type acts as a reference-counted owner of an underlying `GtkThemingEngine` instance.
/// It provides the methods that can operate on this data type through `ThemingEngineProtocol` conformance.
/// Use `ThemingEngine` as a strong reference or owner of a `GtkThemingEngine` instance.
///
/// `GtkThemingEngine` was the object used for rendering themed content
/// in GTK+ widgets. It used to allow overriding GTK+'s default
/// implementation of rendering functions by allowing engines to be
/// loaded as modules.
/// 
/// `GtkThemingEngine` has been deprecated in GTK+ 3.14 and will be
/// ignored for rendering. The advancements in CSS theming are good
/// enough to allow themers to achieve their goals without the need
/// to modify source code.
open class ThemingEngine: GLibObject.Object, ThemingEngineProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `ThemingEngine` instance.
    public init(_ op: UnsafeMutablePointer<GtkThemingEngine>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `ThemingEngineProtocol`
    /// Will retain `GtkThemingEngine`.
    public convenience init<T: ThemingEngineProtocol>(_ other: T) {
        self.init(cast(other.theming_engine_ptr))
        g_object_ref(cast(theming_engine_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ThemingEngineProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkThemingEngine.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ThemingEngineProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkThemingEngine.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ThemingEngineProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkThemingEngine.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ThemingEngineProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkThemingEngine>(opaquePointer))
    }


    /// Loads and initializes a theming engine module from the
    /// standard directories.
    ///
    /// **load is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) public static func load(name: UnsafePointer<gchar>) -> ThemingEngine! {
        let rv = gtk_theming_engine_load(name)
        return rv.map { ThemingEngine(cast($0)) }
    }

}

public enum ThemingEnginePropertyName: String, PropertyNameProtocol {
    /// The theming engine name, this name will be used when registering
    /// custom properties, for a theming engine named "Clearlooks" registering
    /// a "glossy" custom property, it could be referenced in the CSS file as
    /// 
    /// ```
    /// -Clearlooks-glossy: true;
    /// ```
    /// 
    case name = "name"
}

public extension ThemingEngineProtocol {
    /// Bind a `ThemingEnginePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ThemingEnginePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(theming_engine_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum ThemingEngineSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The theming engine name, this name will be used when registering
    /// custom properties, for a theming engine named "Clearlooks" registering
    /// a "glossy" custom property, it could be referenced in the CSS file as
    /// 
    /// ```
    /// -Clearlooks-glossy: true;
    /// ```
    /// 
    case notifyName = "notify::name"
}

public extension ThemingEngineProtocol {
    /// Connect a `ThemingEngineSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: ThemingEngineSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(theming_engine_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension ThemingEngineProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkThemingEngine` instance.
    var theming_engine_ptr: UnsafeMutablePointer<GtkThemingEngine> { return ptr.assumingMemoryBound(to: GtkThemingEngine.self) }


    // *** get() is not available because it has a varargs (...) parameter!


    /// Gets the background color for a given state.
    ///
    /// **get_background_color is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func getBackgroundColor(state: StateFlags, color: RGBAProtocol) {
        gtk_theming_engine_get_background_color(cast(theming_engine_ptr), state, cast(color.ptr))
    
    }

    /// Gets the border for a given state as a `GtkBorder`.
    ///
    /// **get_border is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func getBorder(state: StateFlags, border: BorderProtocol) {
        gtk_theming_engine_get_border(cast(theming_engine_ptr), state, cast(border.ptr))
    
    }

    /// Gets the border color for a given state.
    ///
    /// **get_border_color is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func getBorderColor(state: StateFlags, color: RGBAProtocol) {
        gtk_theming_engine_get_border_color(cast(theming_engine_ptr), state, cast(color.ptr))
    
    }

    /// Gets the foreground color for a given state.
    ///
    /// **get_color is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func getColor(state: StateFlags, color: RGBAProtocol) {
        gtk_theming_engine_get_color(cast(theming_engine_ptr), state, cast(color.ptr))
    
    }

    /// Returns the widget direction used for rendering.
    ///
    /// **get_direction is deprecated:**
    /// Use gtk_theming_engine_get_state() and
    ///   check for #GTK_STATE_FLAG_DIR_LTR and
    ///   #GTK_STATE_FLAG_DIR_RTL instead.
    @available(*, deprecated) func getDirection() -> GtkTextDirection {
        let rv = gtk_theming_engine_get_direction(cast(theming_engine_ptr))
        return rv
    }

    /// Returns the font description for a given state.
    ///
    /// **get_font is deprecated:**
    /// Use gtk_theming_engine_get()
    @available(*, deprecated) func getFont(state: StateFlags) -> UnsafePointer<PangoFontDescription>! {
        let rv = gtk_theming_engine_get_font(cast(theming_engine_ptr), state)
        return cast(rv)
    }

    /// Returns the widget direction used for rendering.
    ///
    /// **get_junction_sides is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func getJunctionSides() -> GtkJunctionSides {
        let rv = gtk_theming_engine_get_junction_sides(cast(theming_engine_ptr))
        return rv
    }

    /// Gets the margin for a given state as a `GtkBorder`.
    ///
    /// **get_margin is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func getMargin(state: StateFlags, margin: BorderProtocol) {
        gtk_theming_engine_get_margin(cast(theming_engine_ptr), state, cast(margin.ptr))
    
    }

    /// Gets the padding for a given state as a `GtkBorder`.
    ///
    /// **get_padding is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func getPadding(state: StateFlags, padding: BorderProtocol) {
        gtk_theming_engine_get_padding(cast(theming_engine_ptr), state, cast(padding.ptr))
    
    }

    /// Returns the widget path used for style matching.
    ///
    /// **get_path is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func getPath() -> UnsafePointer<GtkWidgetPath>! {
        let rv = gtk_theming_engine_get_path(cast(theming_engine_ptr))
        return cast(rv)
    }

    /// Gets a property value as retrieved from the style settings that apply
    /// to the currently rendered element.
    ///
    /// **get_property is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func get(property: UnsafePointer<gchar>, state: StateFlags, value: GLibObject.ValueProtocol) {
        gtk_theming_engine_get_property(cast(theming_engine_ptr), property, state, cast(value.ptr))
    
    }

    /// Returns the `GdkScreen` to which `engine` currently rendering to.
    ///
    /// **get_screen is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func getScreen() -> UnsafeMutablePointer<GdkScreen>! {
        let rv = gtk_theming_engine_get_screen(cast(theming_engine_ptr))
        return cast(rv)
    }

    /// returns the state used when rendering.
    ///
    /// **get_state is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func getState() -> GtkStateFlags {
        let rv = gtk_theming_engine_get_state(cast(theming_engine_ptr))
        return rv
    }


    // *** getStyle() is not available because it has a varargs (...) parameter!


    /// Gets the value for a widget style property.
    ///
    /// **get_style_property is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func getStyleProperty(propertyName property_name: UnsafePointer<gchar>, value: GLibObject.ValueProtocol) {
        gtk_theming_engine_get_style_property(cast(theming_engine_ptr), property_name, cast(value.ptr))
    
    }

    /// Retrieves several widget style properties from `engine` according to the
    /// currently rendered content’s style.
    ///
    /// **get_style_valist is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func getStyleValist(args: CVaListPointer) {
        gtk_theming_engine_get_style_valist(cast(theming_engine_ptr), args)
    
    }

    /// Retrieves several style property values that apply to the currently
    /// rendered element.
    ///
    /// **get_valist is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func getValist(state: StateFlags, args: CVaListPointer) {
        gtk_theming_engine_get_valist(cast(theming_engine_ptr), state, args)
    
    }

    /// Returns `true` if the currently rendered contents have
    /// defined the given class name.
    ///
    /// **has_class is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func hasClass(styleClass style_class: UnsafePointer<gchar>) -> Bool {
        let rv = gtk_theming_engine_has_class(cast(theming_engine_ptr), style_class)
        return Bool(rv != 0)
    }

    /// Returns `true` if the currently rendered contents have the
    /// region defined. If `flags_return` is not `nil`, it is set
    /// to the flags affecting the region.
    ///
    /// **has_region is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func hasRegion(styleRegion style_region: UnsafePointer<gchar>, flags: UnsafeMutablePointer<GtkRegionFlags>) -> Bool {
        let rv = gtk_theming_engine_has_region(cast(theming_engine_ptr), style_region, cast(flags))
        return Bool(rv != 0)
    }

    /// Looks up and resolves a color name in the current style’s color map.
    ///
    /// **lookup_color is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func lookupColor(colorName color_name: UnsafePointer<gchar>, color: RGBAProtocol) -> Bool {
        let rv = gtk_theming_engine_lookup_color(cast(theming_engine_ptr), color_name, cast(color.ptr))
        return Bool(rv != 0)
    }

    /// Returns `true` if there is a transition animation running for the
    /// current region (see `gtk_style_context_push_animatable_region()`).
    /// 
    /// If `progress` is not `nil`, the animation progress will be returned
    /// there, 0.0 means the state is closest to being `false`, while 1.0 means
    /// it’s closest to being `true`. This means transition animations will
    /// run from 0 to 1 when `state` is being set to `true` and from 1 to 0 when
    /// it’s being set to `false`.
    ///
    /// **state_is_running is deprecated:**
    /// Always returns %FALSE
    @available(*, deprecated) func stateIsRunning(state: StateType, progress: UnsafeMutablePointer<gdouble>) -> Bool {
        let rv = gtk_theming_engine_state_is_running(cast(theming_engine_ptr), state, cast(progress))
        return Bool(rv != 0)
    }
    /// Returns the widget direction used for rendering.
    ///
    /// **get_direction is deprecated:**
    /// Use gtk_theming_engine_get_state() and
    ///   check for #GTK_STATE_FLAG_DIR_LTR and
    ///   #GTK_STATE_FLAG_DIR_RTL instead.
    var direction: GtkTextDirection {
        /// Returns the widget direction used for rendering.
        ///
        /// **get_direction is deprecated:**
        /// Use gtk_theming_engine_get_state() and
        ///   check for #GTK_STATE_FLAG_DIR_LTR and
        ///   #GTK_STATE_FLAG_DIR_RTL instead.
        @available(*, deprecated) get {
            let rv = gtk_theming_engine_get_direction(cast(theming_engine_ptr))
            return rv
        }
    }

    /// Returns the widget direction used for rendering.
    ///
    /// **get_junction_sides is deprecated:**
    /// This method is deprecated.
    var junctionSides: GtkJunctionSides {
        /// Returns the widget direction used for rendering.
        ///
        /// **get_junction_sides is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated) get {
            let rv = gtk_theming_engine_get_junction_sides(cast(theming_engine_ptr))
            return rv
        }
    }

    /// Returns the widget path used for style matching.
    ///
    /// **get_path is deprecated:**
    /// This method is deprecated.
    var path: UnsafePointer<GtkWidgetPath>! {
        /// Returns the widget path used for style matching.
        ///
        /// **get_path is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated) get {
            let rv = gtk_theming_engine_get_path(cast(theming_engine_ptr))
            return cast(rv)
        }
    }

    /// Returns the `GdkScreen` to which `engine` currently rendering to.
    ///
    /// **get_screen is deprecated:**
    /// This method is deprecated.
    var screen: UnsafeMutablePointer<GdkScreen>! {
        /// Returns the `GdkScreen` to which `engine` currently rendering to.
        ///
        /// **get_screen is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated) get {
            let rv = gtk_theming_engine_get_screen(cast(theming_engine_ptr))
            return cast(rv)
        }
    }

    /// returns the state used when rendering.
    ///
    /// **get_state is deprecated:**
    /// This method is deprecated.
    var state: GtkStateFlags {
        /// returns the state used when rendering.
        ///
        /// **get_state is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated) get {
            let rv = gtk_theming_engine_get_state(cast(theming_engine_ptr))
            return rv
        }
    }
}



// MARK: - ToggleAction Class

/// The `ToggleActionProtocol` protocol exposes the methods and properties of an underlying `GtkToggleAction` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ToggleAction`.
/// Alternatively, use `ToggleActionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkToggleAction` corresponds roughly to a `GtkCheckMenuItem`. It has an
/// “active” state specifying whether the action has been checked or not.
public protocol ToggleActionProtocol: ActionProtocol {
    /// Untyped pointer to the underlying `GtkToggleAction` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkToggleAction` instance.
    var toggle_action_ptr: UnsafeMutablePointer<GtkToggleAction> { get }
}

/// The `ToggleActionRef` type acts as a lightweight Swift reference to an underlying `GtkToggleAction` instance.
/// It exposes methods that can operate on this data type through `ToggleActionProtocol` conformance.
/// Use `ToggleActionRef` only as an `unowned` reference to an existing `GtkToggleAction` instance.
///
/// A `GtkToggleAction` corresponds roughly to a `GtkCheckMenuItem`. It has an
/// “active” state specifying whether the action has been checked or not.
public struct ToggleActionRef: ToggleActionProtocol {
    /// Untyped pointer to the underlying `GtkToggleAction` instance.
    /// For type-safe access, use the generated, typed pointer `toggle_action_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension ToggleActionRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkToggleAction>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `ToggleActionProtocol`
    init<T: ToggleActionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleActionProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleActionProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleActionProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleActionProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleActionProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkToggleAction` object. To add the action to
    /// a `GtkActionGroup` and set the accelerator for the action,
    /// call `gtk_action_group_add_action_with_accel()`.
    ///
    /// **new is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) init( name: UnsafePointer<gchar>, label: UnsafePointer<gchar>, tooltip: UnsafePointer<gchar>, stockID stock_id: UnsafePointer<gchar>) {
        let rv = gtk_toggle_action_new(name, label, tooltip, stock_id)
        self.init(cast(rv))
    }
}

/// The `ToggleAction` type acts as a reference-counted owner of an underlying `GtkToggleAction` instance.
/// It provides the methods that can operate on this data type through `ToggleActionProtocol` conformance.
/// Use `ToggleAction` as a strong reference or owner of a `GtkToggleAction` instance.
///
/// A `GtkToggleAction` corresponds roughly to a `GtkCheckMenuItem`. It has an
/// “active” state specifying whether the action has been checked or not.
open class ToggleAction: Action, ToggleActionProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `ToggleAction` instance.
    public init(_ op: UnsafeMutablePointer<GtkToggleAction>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `ToggleActionProtocol`
    /// Will retain `GtkToggleAction`.
    public convenience init<T: ToggleActionProtocol>(_ other: T) {
        self.init(cast(other.toggle_action_ptr))
        g_object_ref(cast(toggle_action_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleActionProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkToggleAction.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleActionProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkToggleAction.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleActionProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkToggleAction.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleActionProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkToggleAction>(opaquePointer))
    }

    /// Creates a new `GtkToggleAction` object. To add the action to
    /// a `GtkActionGroup` and set the accelerator for the action,
    /// call `gtk_action_group_add_action_with_accel()`.
    ///
    /// **new is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) public convenience init( name: UnsafePointer<gchar>, label: UnsafePointer<gchar>, tooltip: UnsafePointer<gchar>, stockID stock_id: UnsafePointer<gchar>) {
        let rv = gtk_toggle_action_new(name, label, tooltip, stock_id)
        self.init(cast(rv))
    }


}

public enum ToggleActionPropertyName: String, PropertyNameProtocol {
    /// The GtkActionGroup this GtkAction is associated with, or NULL
    /// (for internal use).
    ///
    /// **action-group is deprecated:**
    /// Lookup the #GAction using g_action_map_lookup_action()
    /// instead
    case actionGroup = "action-group"
    /// Whether the toggle action should be active.
    ///
    /// **active is deprecated:**
    /// This method is deprecated.
    case active = "active"
    /// If `true`, the action's menu item proxies will ignore the `GtkSettings:gtk`-menu-images
    /// setting and always show their image, if available.
    /// 
    /// Use this property if the menu item would be useless or hard to use
    /// without their image.
    ///
    /// **always-show-image is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case alwaysShowImage = "always-show-image"
    /// Whether the proxies for this action look like radio action proxies.
    /// 
    /// This is an appearance property and thus only applies if
    /// `GtkActivatable:use`-action-appearance is `true`.
    ///
    /// **draw-as-radio is deprecated:**
    /// This method is deprecated.
    case drawAsRadio = "draw-as-radio"
    /// The `GIcon` displayed in the `GtkAction`.
    /// 
    /// Note that the stock icon is preferred, if the `GtkAction:stock`-id
    /// property holds the id of an existing stock icon.
    /// 
    /// This is an appearance property and thus only applies if
    /// `GtkActivatable:use`-action-appearance is `true`.
    ///
    /// **gicon is deprecated:**
    /// Use the "icon" attribute on a #GMenuItem instead
    case gicon = "gicon"
    /// When TRUE, empty menu proxies for this action are hidden.
    ///
    /// **hide-if-empty is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case hideIfEmpty = "hide-if-empty"
    /// The name of the icon from the icon theme.
    /// 
    /// Note that the stock icon is preferred, if the `GtkAction:stock`-id
    /// property holds the id of an existing stock icon, and the `GIcon` is
    /// preferred if the `GtkAction:gicon` property is set.
    /// 
    /// This is an appearance property and thus only applies if
    /// `GtkActivatable:use`-action-appearance is `true`.
    ///
    /// **icon-name is deprecated:**
    /// Use the "icon" attribute on a #GMenuItem instead
    case iconName = "icon-name"
    /// Whether the action is considered important. When TRUE, toolitem
    /// proxies for this action show text in GTK_TOOLBAR_BOTH_HORIZ mode.
    ///
    /// **is-important is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case isImportant = "is-important"
    /// The label used for menu items and buttons that activate
    /// this action. If the label is `nil`, GTK+ uses the stock
    /// label specified via the stock-id property.
    /// 
    /// This is an appearance property and thus only applies if
    /// `GtkActivatable:use`-action-appearance is `true`.
    ///
    /// **label is deprecated:**
    /// Use the "label" attribute on #GMenuItem instead
    case label = "label"
    /// A unique name for the action.
    ///
    /// **name is deprecated:**
    /// Use #GAction:name instead
    case name = "name"
    /// Whether the action is enabled.
    ///
    /// **sensitive is deprecated:**
    /// Use #GAction:enabled and #GSimpleAction:enabled
    /// instead
    case sensitive = "sensitive"
    /// A shorter label that may be used on toolbar buttons.
    /// 
    /// This is an appearance property and thus only applies if
    /// `GtkActivatable:use`-action-appearance is `true`.
    ///
    /// **short-label is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case shortLabel = "short-label"
    /// The stock icon displayed in widgets representing this action.
    /// 
    /// This is an appearance property and thus only applies if
    /// `GtkActivatable:use`-action-appearance is `true`.
    ///
    /// **stock-id is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case stockID = "stock-id"
    /// A tooltip for this action.
    ///
    /// **tooltip is deprecated:**
    /// Use gtk_widget_set_tooltip_text() instead
    case tooltip = "tooltip"
    /// Whether the action is visible.
    ///
    /// **visible is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case visible = "visible"
    /// Whether the toolbar item is visible when the toolbar is in a horizontal orientation.
    ///
    /// **visible-horizontal is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case visibleHorizontal = "visible-horizontal"
    /// When `true`, toolitem proxies for this action are represented in the
    /// toolbar overflow menu.
    ///
    /// **visible-overflown is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case visibleOverflown = "visible-overflown"
    /// Whether the toolbar item is visible when the toolbar is in a vertical orientation.
    ///
    /// **visible-vertical is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case visibleVertical = "visible-vertical"
}

public extension ToggleActionProtocol {
    /// Bind a `ToggleActionPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ToggleActionPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(toggle_action_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum ToggleActionSignalName: String, SignalNameProtocol {
    /// The "activate" signal is emitted when the action is activated.
    ///
    /// **activate is deprecated:**
    /// Use #GSimpleAction::activate instead
    case activate = "activate"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Should be connected if you wish to perform an action
    /// whenever the `GtkToggleAction` state is changed.
    ///
    /// **toggled is deprecated:**
    /// This method is deprecated.
    case toggled = "toggled"
    /// The GtkActionGroup this GtkAction is associated with, or NULL
    /// (for internal use).
    ///
    /// **action-group is deprecated:**
    /// Lookup the #GAction using g_action_map_lookup_action()
    /// instead
    case notifyActionGroup = "notify::action-group"
    /// Whether the toggle action should be active.
    ///
    /// **active is deprecated:**
    /// This method is deprecated.
    case notifyActive = "notify::active"
    /// If `true`, the action's menu item proxies will ignore the `GtkSettings:gtk`-menu-images
    /// setting and always show their image, if available.
    /// 
    /// Use this property if the menu item would be useless or hard to use
    /// without their image.
    ///
    /// **always-show-image is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case notifyAlwaysShowImage = "notify::always-show-image"
    /// Whether the proxies for this action look like radio action proxies.
    /// 
    /// This is an appearance property and thus only applies if
    /// `GtkActivatable:use`-action-appearance is `true`.
    ///
    /// **draw-as-radio is deprecated:**
    /// This method is deprecated.
    case notifyDrawAsRadio = "notify::draw-as-radio"
    /// The `GIcon` displayed in the `GtkAction`.
    /// 
    /// Note that the stock icon is preferred, if the `GtkAction:stock`-id
    /// property holds the id of an existing stock icon.
    /// 
    /// This is an appearance property and thus only applies if
    /// `GtkActivatable:use`-action-appearance is `true`.
    ///
    /// **gicon is deprecated:**
    /// Use the "icon" attribute on a #GMenuItem instead
    case notifyIcon = "notify::gicon"
    /// When TRUE, empty menu proxies for this action are hidden.
    ///
    /// **hide-if-empty is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case notifyHideIfEmpty = "notify::hide-if-empty"
    /// The name of the icon from the icon theme.
    /// 
    /// Note that the stock icon is preferred, if the `GtkAction:stock`-id
    /// property holds the id of an existing stock icon, and the `GIcon` is
    /// preferred if the `GtkAction:gicon` property is set.
    /// 
    /// This is an appearance property and thus only applies if
    /// `GtkActivatable:use`-action-appearance is `true`.
    ///
    /// **icon-name is deprecated:**
    /// Use the "icon" attribute on a #GMenuItem instead
    case notifyIconName = "notify::icon-name"
    /// Whether the action is considered important. When TRUE, toolitem
    /// proxies for this action show text in GTK_TOOLBAR_BOTH_HORIZ mode.
    ///
    /// **is-important is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case notifyIsImportant = "notify::is-important"
    /// The label used for menu items and buttons that activate
    /// this action. If the label is `nil`, GTK+ uses the stock
    /// label specified via the stock-id property.
    /// 
    /// This is an appearance property and thus only applies if
    /// `GtkActivatable:use`-action-appearance is `true`.
    ///
    /// **label is deprecated:**
    /// Use the "label" attribute on #GMenuItem instead
    case notifyLabel = "notify::label"
    /// A unique name for the action.
    ///
    /// **name is deprecated:**
    /// Use #GAction:name instead
    case notifyName = "notify::name"
    /// Whether the action is enabled.
    ///
    /// **sensitive is deprecated:**
    /// Use #GAction:enabled and #GSimpleAction:enabled
    /// instead
    case notifySensitive = "notify::sensitive"
    /// A shorter label that may be used on toolbar buttons.
    /// 
    /// This is an appearance property and thus only applies if
    /// `GtkActivatable:use`-action-appearance is `true`.
    ///
    /// **short-label is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case notifyShortLabel = "notify::short-label"
    /// The stock icon displayed in widgets representing this action.
    /// 
    /// This is an appearance property and thus only applies if
    /// `GtkActivatable:use`-action-appearance is `true`.
    ///
    /// **stock-id is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case notifyStockID = "notify::stock-id"
    /// A tooltip for this action.
    ///
    /// **tooltip is deprecated:**
    /// Use gtk_widget_set_tooltip_text() instead
    case notifyTooltip = "notify::tooltip"
    /// Whether the action is visible.
    ///
    /// **visible is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case notifyVisible = "notify::visible"
    /// Whether the toolbar item is visible when the toolbar is in a horizontal orientation.
    ///
    /// **visible-horizontal is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case notifyVisibleHorizontal = "notify::visible-horizontal"
    /// When `true`, toolitem proxies for this action are represented in the
    /// toolbar overflow menu.
    ///
    /// **visible-overflown is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case notifyVisibleOverflown = "notify::visible-overflown"
    /// Whether the toolbar item is visible when the toolbar is in a vertical orientation.
    ///
    /// **visible-vertical is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case notifyVisibleVertical = "notify::visible-vertical"
}

public extension ToggleActionProtocol {
    /// Connect a `ToggleActionSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: ToggleActionSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(toggle_action_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension ToggleActionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkToggleAction` instance.
    var toggle_action_ptr: UnsafeMutablePointer<GtkToggleAction> { return ptr.assumingMemoryBound(to: GtkToggleAction.self) }

    /// Returns the checked state of the toggle action.
    ///
    /// **get_active is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func getActive() -> Bool {
        let rv = gtk_toggle_action_get_active(cast(toggle_action_ptr))
        return Bool(rv != 0)
    }

    /// Returns whether the action should have proxies like a radio action.
    ///
    /// **get_draw_as_radio is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func getDrawAsRadio() -> Bool {
        let rv = gtk_toggle_action_get_draw_as_radio(cast(toggle_action_ptr))
        return Bool(rv != 0)
    }

    /// Sets the checked state on the toggle action.
    ///
    /// **set_active is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func setActive(isActive is_active: Bool) {
        gtk_toggle_action_set_active(cast(toggle_action_ptr), gboolean(is_active ? 1 : 0))
    
    }

    /// Sets whether the action should have proxies like a radio action.
    ///
    /// **set_draw_as_radio is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func set(drawAsRadio draw_as_radio: Bool) {
        gtk_toggle_action_set_draw_as_radio(cast(toggle_action_ptr), gboolean(draw_as_radio ? 1 : 0))
    
    }

    /// Emits the “toggled” signal on the toggle action.
    ///
    /// **toggled is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func toggled() {
        gtk_toggle_action_toggled(cast(toggle_action_ptr))
    
    }
    /// Whether the toggle action should be active.
    ///
    /// **active is deprecated:**
    /// This method is deprecated.
    var active: Bool {
        /// Returns the checked state of the toggle action.
        ///
        /// **get_active is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated) get {
            let rv = gtk_toggle_action_get_active(cast(toggle_action_ptr))
            return Bool(rv != 0)
        }
        /// Sets the checked state on the toggle action.
        ///
        /// **set_active is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated) nonmutating set {
            gtk_toggle_action_set_active(cast(toggle_action_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Returns whether the action should have proxies like a radio action.
    ///
    /// **get_draw_as_radio is deprecated:**
    /// This method is deprecated.
    var drawAsRadio: Bool {
        /// Returns whether the action should have proxies like a radio action.
        ///
        /// **get_draw_as_radio is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated) get {
            let rv = gtk_toggle_action_get_draw_as_radio(cast(toggle_action_ptr))
            return Bool(rv != 0)
        }
        /// Sets whether the action should have proxies like a radio action.
        ///
        /// **set_draw_as_radio is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated) nonmutating set {
            gtk_toggle_action_set_draw_as_radio(cast(toggle_action_ptr), gboolean(newValue ? 1 : 0))
        }
    }
}



// MARK: - ToggleButton Class

/// The `ToggleButtonProtocol` protocol exposes the methods and properties of an underlying `GtkToggleButton` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ToggleButton`.
/// Alternatively, use `ToggleButtonRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkToggleButton` is a `GtkButton` which will remain “pressed-in” when
/// clicked. Clicking again will cause the toggle button to return to its
/// normal state.
/// 
/// A toggle button is created by calling either `gtk_toggle_button_new()` or
/// `gtk_toggle_button_new_with_label()`. If using the former, it is advisable to
/// pack a widget, (such as a `GtkLabel` and/or a `GtkImage`), into the toggle
/// button’s container. (See `GtkButton` for more information).
/// 
/// The state of a `GtkToggleButton` can be set specifically using
/// `gtk_toggle_button_set_active()`, and retrieved using
/// `gtk_toggle_button_get_active()`.
/// 
/// To simply switch the state of a toggle button, use `gtk_toggle_button_toggled()`.
/// 
/// # CSS nodes
/// 
/// GtkToggleButton has a single CSS node with name button. To differentiate
/// it from a plain `GtkButton`, it gets the .toggle style class.
/// 
/// ## Creating two `GtkToggleButton` widgets.
/// 
/// (C Language Example):
/// ```C
/// static void output_state (GtkToggleButton *source, gpointer user_data) {
///   printf ("Active: %d\n", gtk_toggle_button_get_active (source));
/// }
/// 
/// void make_toggles (void) {
///   GtkWidget *window, *toggle1, *toggle2;
///   GtkWidget *box;
///   const char *text;
/// 
///   window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
///   box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 12);
/// 
///   text = "Hi, I’m a toggle button.";
///   toggle1 = gtk_toggle_button_new_with_label (text);
/// 
///   // Makes this toggle button invisible
///   gtk_toggle_button_set_mode (GTK_TOGGLE_BUTTON (toggle1),
///                               TRUE);
/// 
///   g_signal_connect (toggle1, "toggled",
///                     G_CALLBACK (output_state),
///                     NULL);
///   gtk_container_add (GTK_CONTAINER (box), toggle1);
/// 
///   text = "Hi, I’m a toggle button.";
///   toggle2 = gtk_toggle_button_new_with_label (text);
///   gtk_toggle_button_set_mode (GTK_TOGGLE_BUTTON (toggle2),
///                               FALSE);
///   g_signal_connect (toggle2, "toggled",
///                     G_CALLBACK (output_state),
///                     NULL);
///   gtk_container_add (GTK_CONTAINER (box), toggle2);
/// 
///   gtk_container_add (GTK_CONTAINER (window), box);
///   gtk_widget_show_all (window);
/// }
/// ```
/// 
public protocol ToggleButtonProtocol: ButtonProtocol {
    /// Untyped pointer to the underlying `GtkToggleButton` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkToggleButton` instance.
    var toggle_button_ptr: UnsafeMutablePointer<GtkToggleButton> { get }
}

/// The `ToggleButtonRef` type acts as a lightweight Swift reference to an underlying `GtkToggleButton` instance.
/// It exposes methods that can operate on this data type through `ToggleButtonProtocol` conformance.
/// Use `ToggleButtonRef` only as an `unowned` reference to an existing `GtkToggleButton` instance.
///
/// A `GtkToggleButton` is a `GtkButton` which will remain “pressed-in” when
/// clicked. Clicking again will cause the toggle button to return to its
/// normal state.
/// 
/// A toggle button is created by calling either `gtk_toggle_button_new()` or
/// `gtk_toggle_button_new_with_label()`. If using the former, it is advisable to
/// pack a widget, (such as a `GtkLabel` and/or a `GtkImage`), into the toggle
/// button’s container. (See `GtkButton` for more information).
/// 
/// The state of a `GtkToggleButton` can be set specifically using
/// `gtk_toggle_button_set_active()`, and retrieved using
/// `gtk_toggle_button_get_active()`.
/// 
/// To simply switch the state of a toggle button, use `gtk_toggle_button_toggled()`.
/// 
/// # CSS nodes
/// 
/// GtkToggleButton has a single CSS node with name button. To differentiate
/// it from a plain `GtkButton`, it gets the .toggle style class.
/// 
/// ## Creating two `GtkToggleButton` widgets.
/// 
/// (C Language Example):
/// ```C
/// static void output_state (GtkToggleButton *source, gpointer user_data) {
///   printf ("Active: %d\n", gtk_toggle_button_get_active (source));
/// }
/// 
/// void make_toggles (void) {
///   GtkWidget *window, *toggle1, *toggle2;
///   GtkWidget *box;
///   const char *text;
/// 
///   window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
///   box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 12);
/// 
///   text = "Hi, I’m a toggle button.";
///   toggle1 = gtk_toggle_button_new_with_label (text);
/// 
///   // Makes this toggle button invisible
///   gtk_toggle_button_set_mode (GTK_TOGGLE_BUTTON (toggle1),
///                               TRUE);
/// 
///   g_signal_connect (toggle1, "toggled",
///                     G_CALLBACK (output_state),
///                     NULL);
///   gtk_container_add (GTK_CONTAINER (box), toggle1);
/// 
///   text = "Hi, I’m a toggle button.";
///   toggle2 = gtk_toggle_button_new_with_label (text);
///   gtk_toggle_button_set_mode (GTK_TOGGLE_BUTTON (toggle2),
///                               FALSE);
///   g_signal_connect (toggle2, "toggled",
///                     G_CALLBACK (output_state),
///                     NULL);
///   gtk_container_add (GTK_CONTAINER (box), toggle2);
/// 
///   gtk_container_add (GTK_CONTAINER (window), box);
///   gtk_widget_show_all (window);
/// }
/// ```
/// 
public struct ToggleButtonRef: ToggleButtonProtocol {
    /// Untyped pointer to the underlying `GtkToggleButton` instance.
    /// For type-safe access, use the generated, typed pointer `toggle_button_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension ToggleButtonRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkToggleButton>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `ToggleButtonProtocol`
    init<T: ToggleButtonProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new toggle button. A widget should be packed into the button, as in `gtk_button_new()`.
    init() {
        let rv = gtk_toggle_button_new()
        self.init(cast(rv))
    }

    /// Creates a new toggle button with a text label.
    init(label: UnsafePointer<gchar>) {
        let rv = gtk_toggle_button_new_with_label(label)
        self.init(cast(rv))
    }

    /// Creates a new `GtkToggleButton` containing a label. The label
    /// will be created using `gtk_label_new_with_mnemonic()`, so underscores
    /// in `label` indicate the mnemonic for the button.
    init(mnemonic label: UnsafePointer<gchar>) {
        let rv = gtk_toggle_button_new_with_mnemonic(label)
        self.init(cast(rv))
    }
    /// Creates a new toggle button with a text label.
    static func toggleButtonNewWith(label: UnsafePointer<gchar>) -> ToggleButtonRef! {
        let rv = gtk_toggle_button_new_with_label(label)
        return rv.map { ToggleButtonRef(cast($0)) }
    }

    /// Creates a new `GtkToggleButton` containing a label. The label
    /// will be created using `gtk_label_new_with_mnemonic()`, so underscores
    /// in `label` indicate the mnemonic for the button.
    static func toggleButtonNewWith(mnemonic label: UnsafePointer<gchar>) -> ToggleButtonRef! {
        let rv = gtk_toggle_button_new_with_mnemonic(label)
        return rv.map { ToggleButtonRef(cast($0)) }
    }
}

/// The `ToggleButton` type acts as a reference-counted owner of an underlying `GtkToggleButton` instance.
/// It provides the methods that can operate on this data type through `ToggleButtonProtocol` conformance.
/// Use `ToggleButton` as a strong reference or owner of a `GtkToggleButton` instance.
///
/// A `GtkToggleButton` is a `GtkButton` which will remain “pressed-in” when
/// clicked. Clicking again will cause the toggle button to return to its
/// normal state.
/// 
/// A toggle button is created by calling either `gtk_toggle_button_new()` or
/// `gtk_toggle_button_new_with_label()`. If using the former, it is advisable to
/// pack a widget, (such as a `GtkLabel` and/or a `GtkImage`), into the toggle
/// button’s container. (See `GtkButton` for more information).
/// 
/// The state of a `GtkToggleButton` can be set specifically using
/// `gtk_toggle_button_set_active()`, and retrieved using
/// `gtk_toggle_button_get_active()`.
/// 
/// To simply switch the state of a toggle button, use `gtk_toggle_button_toggled()`.
/// 
/// # CSS nodes
/// 
/// GtkToggleButton has a single CSS node with name button. To differentiate
/// it from a plain `GtkButton`, it gets the .toggle style class.
/// 
/// ## Creating two `GtkToggleButton` widgets.
/// 
/// (C Language Example):
/// ```C
/// static void output_state (GtkToggleButton *source, gpointer user_data) {
///   printf ("Active: %d\n", gtk_toggle_button_get_active (source));
/// }
/// 
/// void make_toggles (void) {
///   GtkWidget *window, *toggle1, *toggle2;
///   GtkWidget *box;
///   const char *text;
/// 
///   window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
///   box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 12);
/// 
///   text = "Hi, I’m a toggle button.";
///   toggle1 = gtk_toggle_button_new_with_label (text);
/// 
///   // Makes this toggle button invisible
///   gtk_toggle_button_set_mode (GTK_TOGGLE_BUTTON (toggle1),
///                               TRUE);
/// 
///   g_signal_connect (toggle1, "toggled",
///                     G_CALLBACK (output_state),
///                     NULL);
///   gtk_container_add (GTK_CONTAINER (box), toggle1);
/// 
///   text = "Hi, I’m a toggle button.";
///   toggle2 = gtk_toggle_button_new_with_label (text);
///   gtk_toggle_button_set_mode (GTK_TOGGLE_BUTTON (toggle2),
///                               FALSE);
///   g_signal_connect (toggle2, "toggled",
///                     G_CALLBACK (output_state),
///                     NULL);
///   gtk_container_add (GTK_CONTAINER (box), toggle2);
/// 
///   gtk_container_add (GTK_CONTAINER (window), box);
///   gtk_widget_show_all (window);
/// }
/// ```
/// 
open class ToggleButton: Button, ToggleButtonProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `ToggleButton` instance.
    public init(_ op: UnsafeMutablePointer<GtkToggleButton>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `ToggleButtonProtocol`
    /// Will retain `GtkToggleButton`.
    public convenience init<T: ToggleButtonProtocol>(_ other: T) {
        self.init(cast(other.toggle_button_ptr))
        g_object_ref(cast(toggle_button_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkToggleButton.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkToggleButton.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkToggleButton.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkToggleButton>(opaquePointer))
    }

    /// Creates a new toggle button. A widget should be packed into the button, as in `gtk_button_new()`.
    public convenience init() {
        let rv = gtk_toggle_button_new()
        self.init(cast(rv))
    }

    /// Creates a new toggle button with a text label.
    public convenience init(label: UnsafePointer<gchar>) {
        let rv = gtk_toggle_button_new_with_label(label)
        self.init(cast(rv))
    }

    /// Creates a new `GtkToggleButton` containing a label. The label
    /// will be created using `gtk_label_new_with_mnemonic()`, so underscores
    /// in `label` indicate the mnemonic for the button.
    public convenience init(mnemonic label: UnsafePointer<gchar>) {
        let rv = gtk_toggle_button_new_with_mnemonic(label)
        self.init(cast(rv))
    }

    /// Creates a new toggle button with a text label.
    public static func toggleButtonNewWith(label: UnsafePointer<gchar>) -> ToggleButton! {
        let rv = gtk_toggle_button_new_with_label(label)
        return rv.map { ToggleButton(cast($0)) }
    }

    /// Creates a new `GtkToggleButton` containing a label. The label
    /// will be created using `gtk_label_new_with_mnemonic()`, so underscores
    /// in `label` indicate the mnemonic for the button.
    public static func toggleButtonNewWith(mnemonic label: UnsafePointer<gchar>) -> ToggleButton! {
        let rv = gtk_toggle_button_new_with_mnemonic(label)
        return rv.map { ToggleButton(cast($0)) }
    }

}

public enum ToggleButtonPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case active = "active"
    /// If `true`, the button will ignore the `GtkSettings:gtk`-button-images
    /// setting and always show the image, if available.
    /// 
    /// Use this property if the button would be useless or hard to use
    /// without the image.
    case alwaysShowImage = "always-show-image"
    case appPaintable = "app-paintable"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case compositeChild = "composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case drawIndicator = "draw-indicator"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The child widget to appear next to the button text.
    case image = "image"
    /// The position of the image relative to the text inside the button.
    case imagePosition = "image-position"
    case inconsistent = "inconsistent"
    case isFocus = "is-focus"
    case label = "label"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case relief = "relief"
    case resizeMode = "resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"

    ///
    /// **use-stock is deprecated:**
    /// This method is deprecated.
    case useStock = "use-stock"
    case useUnderline = "use-underline"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
    /// If the child of the button is a `GtkMisc` or `GtkAlignment`, this property
    /// can be used to control its horizontal alignment. 0.0 is left aligned,
    /// 1.0 is right aligned.
    ///
    /// **xalign is deprecated:**
    /// Access the child widget directly if you need to control
    /// its alignment.
    case xalign = "xalign"
    /// If the child of the button is a `GtkMisc` or `GtkAlignment`, this property
    /// can be used to control its vertical alignment. 0.0 is top aligned,
    /// 1.0 is bottom aligned.
    ///
    /// **yalign is deprecated:**
    /// Access the child widget directly if you need to control
    /// its alignment.
    case yalign = "yalign"
}

public extension ToggleButtonProtocol {
    /// Bind a `ToggleButtonPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ToggleButtonPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(toggle_button_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum ToggleButtonSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    /// The `activate` signal on GtkButton is an action signal and
    /// emitting it causes the button to animate press then release.
    /// Applications should never connect to this signal, but use the
    /// `GtkButton::clicked` signal.
    case activate = "activate"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    case add = "add"
    /// The `button`-press-event signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button`-release-event signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child`-notify signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// Emitted when the button has been activated (pressed and released).
    case clicked = "clicked"
    /// The `composited`-changed signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure`-event signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete`-event signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy`-event signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag`-begin signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag`-data-delete signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag`-data-get signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag`-data-received signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag`-drop signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag`-drop signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag`-data-received handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag`-end signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag`-begin.
    case dragEnd = "drag-end"
    /// The `drag`-failed signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag`-leave signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag`-motion, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag`-leave signal is also emitted before the
    /// `drag`-drop signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag`-motion signal handler.
    case dragLeave = "drag-leave"
    /// The `drag`-motion signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag`-data-received
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag`-leave and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// Emitted when the pointer enters the button.
    ///
    /// **enter is deprecated:**
    /// Use the #GtkWidget::enter-notify-event signal.
    case enter = "enter"
    /// The `enter`-notify-event will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key`-press-event) and finally a generic
    /// `GtkWidget::event`-after signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event`-after will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `focus`-in-event signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus`-out-event signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab`-notify signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy`-changed signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key`-press-event signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key`-release-event signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when the pointer leaves the button.
    ///
    /// **leave is deprecated:**
    /// Use the #GtkWidget::leave-notify-event signal.
    case leave = "leave"
    /// The `leave`-notify-event will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map`-event will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map`-event signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion`-notify-event signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent`-set signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// Emitted when the button is pressed.
    ///
    /// **pressed is deprecated:**
    /// Use the #GtkWidget::button-press-event signal.
    case pressed = "pressed"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The `property`-notify-event signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when the button is released.
    ///
    /// **released is deprecated:**
    /// Use the #GtkWidget::button-release-event signal.
    case released = "released"
    case remove = "remove"
    /// The `screen`-changed signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll`-event signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `selection`-clear-event signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection`-request-event signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-changed signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style`-set signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style`-updated signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style`-updated signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    /// Should be connected if you wish to perform an action whenever the
    /// `GtkToggleButton`'s state is changed.
    case toggled = "toggled"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap`-event signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility`-notify-event will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    /// The `window`-state-event will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyActive = "notify::active"
    /// If `true`, the button will ignore the `GtkSettings:gtk`-button-images
    /// setting and always show the image, if available.
    /// 
    /// Use this property if the button would be useless or hard to use
    /// without the image.
    case notifyAlwaysShowImage = "notify::always-show-image"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyDrawIndicator = "notify::draw-indicator"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The child widget to appear next to the button text.
    case notifyImage = "notify::image"
    /// The position of the image relative to the text inside the button.
    case notifyImagePosition = "notify::image-position"
    case notifyInconsistent = "notify::inconsistent"
    case notifyIsFocus = "notify::is-focus"
    case notifyLabel = "notify::label"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyRelief = "notify::relief"
    case notifyResizeMode = "notify::resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"

    ///
    /// **use-stock is deprecated:**
    /// This method is deprecated.
    case notifyUseStock = "notify::use-stock"
    case notifyUseUnderline = "notify::use-underline"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
    /// If the child of the button is a `GtkMisc` or `GtkAlignment`, this property
    /// can be used to control its horizontal alignment. 0.0 is left aligned,
    /// 1.0 is right aligned.
    ///
    /// **xalign is deprecated:**
    /// Access the child widget directly if you need to control
    /// its alignment.
    case notifyXalign = "notify::xalign"
    /// If the child of the button is a `GtkMisc` or `GtkAlignment`, this property
    /// can be used to control its vertical alignment. 0.0 is top aligned,
    /// 1.0 is bottom aligned.
    ///
    /// **yalign is deprecated:**
    /// Access the child widget directly if you need to control
    /// its alignment.
    case notifyYalign = "notify::yalign"
}

public extension ToggleButtonProtocol {
    /// Connect a `ToggleButtonSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: ToggleButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(toggle_button_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension ToggleButtonProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkToggleButton` instance.
    var toggle_button_ptr: UnsafeMutablePointer<GtkToggleButton> { return ptr.assumingMemoryBound(to: GtkToggleButton.self) }

    /// Queries a `GtkToggleButton` and returns its current state. Returns `true` if
    /// the toggle button is pressed in and `false` if it is raised.
    func getActive() -> Bool {
        let rv = gtk_toggle_button_get_active(cast(toggle_button_ptr))
        return Bool(rv != 0)
    }

    /// Gets the value set by `gtk_toggle_button_set_inconsistent()`.
    func getInconsistent() -> Bool {
        let rv = gtk_toggle_button_get_inconsistent(cast(toggle_button_ptr))
        return Bool(rv != 0)
    }

    /// Retrieves whether the button is displayed as a separate indicator
    /// and label. See `gtk_toggle_button_set_mode()`.
    func getMode() -> Bool {
        let rv = gtk_toggle_button_get_mode(cast(toggle_button_ptr))
        return Bool(rv != 0)
    }

    /// Sets the status of the toggle button. Set to `true` if you want the
    /// GtkToggleButton to be “pressed in”, and `false` to raise it.
    /// This action causes the `GtkToggleButton::toggled` signal and the
    /// `GtkButton::clicked` signal to be emitted.
    func setActive(isActive is_active: Bool) {
        gtk_toggle_button_set_active(cast(toggle_button_ptr), gboolean(is_active ? 1 : 0))
    
    }

    /// If the user has selected a range of elements (such as some text or
    /// spreadsheet cells) that are affected by a toggle button, and the
    /// current values in that range are inconsistent, you may want to
    /// display the toggle in an “in between” state. This function turns on
    /// “in between” display.  Normally you would turn off the inconsistent
    /// state again if the user toggles the toggle button. This has to be
    /// done manually, `gtk_toggle_button_set_inconsistent()` only affects
    /// visual appearance, it doesn’t affect the semantics of the button.
    func setInconsistent(setting: Bool) {
        gtk_toggle_button_set_inconsistent(cast(toggle_button_ptr), gboolean(setting ? 1 : 0))
    
    }

    /// Sets whether the button is displayed as a separate indicator and label.
    /// You can call this function on a checkbutton or a radiobutton with
    /// `draw_indicator` = `false` to make the button look like a normal button.
    /// 
    /// This can be used to create linked strip of buttons that work like
    /// a `GtkStackSwitcher`.
    /// 
    /// This function only affects instances of classes like `GtkCheckButton`
    /// and `GtkRadioButton` that derive from `GtkToggleButton`,
    /// not instances of `GtkToggleButton` itself.
    func setMode(drawIndicator draw_indicator: Bool) {
        gtk_toggle_button_set_mode(cast(toggle_button_ptr), gboolean(draw_indicator ? 1 : 0))
    
    }

    /// Emits the `GtkToggleButton::toggled` signal on the
    /// `GtkToggleButton`. There is no good reason for an
    /// application ever to call this function.
    func toggled() {
        gtk_toggle_button_toggled(cast(toggle_button_ptr))
    
    }
    var active: Bool {
        /// Queries a `GtkToggleButton` and returns its current state. Returns `true` if
        /// the toggle button is pressed in and `false` if it is raised.
        get {
            let rv = gtk_toggle_button_get_active(cast(toggle_button_ptr))
            return Bool(rv != 0)
        }
        /// Sets the status of the toggle button. Set to `true` if you want the
        /// GtkToggleButton to be “pressed in”, and `false` to raise it.
        /// This action causes the `GtkToggleButton::toggled` signal and the
        /// `GtkButton::clicked` signal to be emitted.
        nonmutating set {
            gtk_toggle_button_set_active(cast(toggle_button_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    var inconsistent: Bool {
        /// Gets the value set by `gtk_toggle_button_set_inconsistent()`.
        get {
            let rv = gtk_toggle_button_get_inconsistent(cast(toggle_button_ptr))
            return Bool(rv != 0)
        }
        /// If the user has selected a range of elements (such as some text or
        /// spreadsheet cells) that are affected by a toggle button, and the
        /// current values in that range are inconsistent, you may want to
        /// display the toggle in an “in between” state. This function turns on
        /// “in between” display.  Normally you would turn off the inconsistent
        /// state again if the user toggles the toggle button. This has to be
        /// done manually, `gtk_toggle_button_set_inconsistent()` only affects
        /// visual appearance, it doesn’t affect the semantics of the button.
        nonmutating set {
            gtk_toggle_button_set_inconsistent(cast(toggle_button_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Retrieves whether the button is displayed as a separate indicator
    /// and label. See `gtk_toggle_button_set_mode()`.
    var mode: Bool {
        /// Retrieves whether the button is displayed as a separate indicator
        /// and label. See `gtk_toggle_button_set_mode()`.
        get {
            let rv = gtk_toggle_button_get_mode(cast(toggle_button_ptr))
            return Bool(rv != 0)
        }
        /// Sets whether the button is displayed as a separate indicator and label.
        /// You can call this function on a checkbutton or a radiobutton with
        /// `draw_indicator` = `false` to make the button look like a normal button.
        /// 
        /// This can be used to create linked strip of buttons that work like
        /// a `GtkStackSwitcher`.
        /// 
        /// This function only affects instances of classes like `GtkCheckButton`
        /// and `GtkRadioButton` that derive from `GtkToggleButton`,
        /// not instances of `GtkToggleButton` itself.
        nonmutating set {
            gtk_toggle_button_set_mode(cast(toggle_button_ptr), gboolean(newValue ? 1 : 0))
        }
    }
}



// MARK: - ToggleButtonAccessible Class

/// The `ToggleButtonAccessibleProtocol` protocol exposes the methods and properties of an underlying `GtkToggleButtonAccessible` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ToggleButtonAccessible`.
/// Alternatively, use `ToggleButtonAccessibleRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///

public protocol ToggleButtonAccessibleProtocol: ButtonAccessibleProtocol {
    /// Untyped pointer to the underlying `GtkToggleButtonAccessible` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkToggleButtonAccessible` instance.
    var toggle_button_accessible_ptr: UnsafeMutablePointer<GtkToggleButtonAccessible> { get }
}

/// The `ToggleButtonAccessibleRef` type acts as a lightweight Swift reference to an underlying `GtkToggleButtonAccessible` instance.
/// It exposes methods that can operate on this data type through `ToggleButtonAccessibleProtocol` conformance.
/// Use `ToggleButtonAccessibleRef` only as an `unowned` reference to an existing `GtkToggleButtonAccessible` instance.
///

public struct ToggleButtonAccessibleRef: ToggleButtonAccessibleProtocol {
    /// Untyped pointer to the underlying `GtkToggleButtonAccessible` instance.
    /// For type-safe access, use the generated, typed pointer `toggle_button_accessible_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension ToggleButtonAccessibleRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkToggleButtonAccessible>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `ToggleButtonAccessibleProtocol`
    init<T: ToggleButtonAccessibleProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonAccessibleProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonAccessibleProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonAccessibleProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonAccessibleProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonAccessibleProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `ToggleButtonAccessible` type acts as a reference-counted owner of an underlying `GtkToggleButtonAccessible` instance.
/// It provides the methods that can operate on this data type through `ToggleButtonAccessibleProtocol` conformance.
/// Use `ToggleButtonAccessible` as a strong reference or owner of a `GtkToggleButtonAccessible` instance.
///

open class ToggleButtonAccessible: ButtonAccessible, ToggleButtonAccessibleProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `ToggleButtonAccessible` instance.
    public init(_ op: UnsafeMutablePointer<GtkToggleButtonAccessible>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `ToggleButtonAccessibleProtocol`
    /// Will retain `GtkToggleButtonAccessible`.
    public convenience init<T: ToggleButtonAccessibleProtocol>(_ other: T) {
        self.init(cast(other.toggle_button_accessible_ptr))
        g_object_ref(cast(toggle_button_accessible_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonAccessibleProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkToggleButtonAccessible.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonAccessibleProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkToggleButtonAccessible.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonAccessibleProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkToggleButtonAccessible.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonAccessibleProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkToggleButtonAccessible>(opaquePointer))
    }



}

public enum ToggleButtonAccessiblePropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case widget = "widget"
}

public extension ToggleButtonAccessibleProtocol {
    /// Bind a `ToggleButtonAccessiblePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ToggleButtonAccessiblePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(toggle_button_accessible_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum ToggleButtonAccessibleSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyWidget = "notify::widget"
}

public extension ToggleButtonAccessibleProtocol {
    /// Connect a `ToggleButtonAccessibleSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: ToggleButtonAccessibleSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(toggle_button_accessible_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension ToggleButtonAccessibleProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkToggleButtonAccessible` instance.
    var toggle_button_accessible_ptr: UnsafeMutablePointer<GtkToggleButtonAccessible> { return ptr.assumingMemoryBound(to: GtkToggleButtonAccessible.self) }

}



// MARK: - ToggleToolButton Class

/// The `ToggleToolButtonProtocol` protocol exposes the methods and properties of an underlying `GtkToggleToolButton` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ToggleToolButton`.
/// Alternatively, use `ToggleToolButtonRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkToggleToolButton` is a `GtkToolItem` that contains a toggle
/// button.
/// 
/// Use `gtk_toggle_tool_button_new()` to create a new GtkToggleToolButton.
/// 
/// # CSS nodes
/// 
/// GtkToggleToolButton has a single CSS node with name togglebutton.
public protocol ToggleToolButtonProtocol: ToolButtonProtocol {
    /// Untyped pointer to the underlying `GtkToggleToolButton` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkToggleToolButton` instance.
    var toggle_tool_button_ptr: UnsafeMutablePointer<GtkToggleToolButton> { get }
}

/// The `ToggleToolButtonRef` type acts as a lightweight Swift reference to an underlying `GtkToggleToolButton` instance.
/// It exposes methods that can operate on this data type through `ToggleToolButtonProtocol` conformance.
/// Use `ToggleToolButtonRef` only as an `unowned` reference to an existing `GtkToggleToolButton` instance.
///
/// A `GtkToggleToolButton` is a `GtkToolItem` that contains a toggle
/// button.
/// 
/// Use `gtk_toggle_tool_button_new()` to create a new GtkToggleToolButton.
/// 
/// # CSS nodes
/// 
/// GtkToggleToolButton has a single CSS node with name togglebutton.
public struct ToggleToolButtonRef: ToggleToolButtonProtocol {
    /// Untyped pointer to the underlying `GtkToggleToolButton` instance.
    /// For type-safe access, use the generated, typed pointer `toggle_tool_button_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension ToggleToolButtonRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkToggleToolButton>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `ToggleToolButtonProtocol`
    init<T: ToggleToolButtonProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleToolButtonProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleToolButtonProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleToolButtonProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleToolButtonProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleToolButtonProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Returns a new `GtkToggleToolButton`
    init() {
        let rv = gtk_toggle_tool_button_new()
        self.init(cast(rv))
    }

    /// Creates a new `GtkToggleToolButton` containing the image and text from a
    /// stock item. Some stock ids have preprocessor macros like `GTK_STOCK_OK`
    /// and `GTK_STOCK_APPLY`.
    /// 
    /// It is an error if `stock_id` is not a name of a stock item.
    ///
    /// **new_from_stock is deprecated:**
    /// Use gtk_toggle_tool_button_new() instead.
    @available(*, deprecated) init(stock stock_id: UnsafePointer<gchar>) {
        let rv = gtk_toggle_tool_button_new_from_stock(stock_id)
        self.init(cast(rv))
    }
    /// Creates a new `GtkToggleToolButton` containing the image and text from a
    /// stock item. Some stock ids have preprocessor macros like `GTK_STOCK_OK`
    /// and `GTK_STOCK_APPLY`.
    /// 
    /// It is an error if `stock_id` is not a name of a stock item.
    ///
    /// **new_from_stock is deprecated:**
    /// Use gtk_toggle_tool_button_new() instead.
    @available(*, deprecated) static func toggleToolButtonNewFrom(stock stock_id: UnsafePointer<gchar>) -> ToggleToolButtonRef! {
        let rv = gtk_toggle_tool_button_new_from_stock(stock_id)
        return rv.map { ToggleToolButtonRef(cast($0)) }
    }
}

/// The `ToggleToolButton` type acts as a reference-counted owner of an underlying `GtkToggleToolButton` instance.
/// It provides the methods that can operate on this data type through `ToggleToolButtonProtocol` conformance.
/// Use `ToggleToolButton` as a strong reference or owner of a `GtkToggleToolButton` instance.
///
/// A `GtkToggleToolButton` is a `GtkToolItem` that contains a toggle
/// button.
/// 
/// Use `gtk_toggle_tool_button_new()` to create a new GtkToggleToolButton.
/// 
/// # CSS nodes
/// 
/// GtkToggleToolButton has a single CSS node with name togglebutton.
open class ToggleToolButton: ToolButton, ToggleToolButtonProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `ToggleToolButton` instance.
    public init(_ op: UnsafeMutablePointer<GtkToggleToolButton>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `ToggleToolButtonProtocol`
    /// Will retain `GtkToggleToolButton`.
    public convenience init<T: ToggleToolButtonProtocol>(_ other: T) {
        self.init(cast(other.toggle_tool_button_ptr))
        g_object_ref(cast(toggle_tool_button_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleToolButtonProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkToggleToolButton.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleToolButtonProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkToggleToolButton.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleToolButtonProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkToggleToolButton.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleToolButtonProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkToggleToolButton>(opaquePointer))
    }

    /// Returns a new `GtkToggleToolButton`
    public convenience init() {
        let rv = gtk_toggle_tool_button_new()
        self.init(cast(rv))
    }

    /// Creates a new `GtkToggleToolButton` containing the image and text from a
    /// stock item. Some stock ids have preprocessor macros like `GTK_STOCK_OK`
    /// and `GTK_STOCK_APPLY`.
    /// 
    /// It is an error if `stock_id` is not a name of a stock item.
    ///
    /// **new_from_stock is deprecated:**
    /// Use gtk_toggle_tool_button_new() instead.
    @available(*, deprecated) public convenience init(stock stock_id: UnsafePointer<gchar>) {
        let rv = gtk_toggle_tool_button_new_from_stock(stock_id)
        self.init(cast(rv))
    }

    /// Creates a new `GtkToggleToolButton` containing the image and text from a
    /// stock item. Some stock ids have preprocessor macros like `GTK_STOCK_OK`
    /// and `GTK_STOCK_APPLY`.
    /// 
    /// It is an error if `stock_id` is not a name of a stock item.
    ///
    /// **new_from_stock is deprecated:**
    /// Use gtk_toggle_tool_button_new() instead.
    @available(*, deprecated) public static func toggleToolButtonNewFrom(stock stock_id: UnsafePointer<gchar>) -> ToggleToolButton! {
        let rv = gtk_toggle_tool_button_new_from_stock(stock_id)
        return rv.map { ToggleToolButton(cast($0)) }
    }

}

public enum ToggleToolButtonPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    /// If the toggle tool button should be pressed in.
    case active = "active"
    case appPaintable = "app-paintable"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case compositeChild = "composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The name of the themed icon displayed on the item.
    /// This property only has an effect if not overridden by
    /// `GtkToolButton:label`-widget, `GtkToolButton:icon`-widget or
    /// `GtkToolButton:stock`-id properties.
    case iconName = "icon-name"
    case iconWidget = "icon-widget"
    case isFocus = "is-focus"
    case isImportant = "is-important"
    case label = "label"
    case labelWidget = "label-widget"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case resizeMode = "resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"

    ///
    /// **stock-id is deprecated:**
    /// Use #GtkToolButton:icon-name instead.
    case stockID = "stock-id"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    case useUnderline = "use-underline"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case visibleHorizontal = "visible-horizontal"
    case visibleVertical = "visible-vertical"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
}

public extension ToggleToolButtonProtocol {
    /// Bind a `ToggleToolButtonPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ToggleToolButtonPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(toggle_tool_button_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum ToggleToolButtonSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    case add = "add"
    /// The `button`-press-event signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button`-release-event signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child`-notify signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// This signal is emitted when the tool button is clicked with the mouse
    /// or activated with the keyboard.
    case clicked = "clicked"
    /// The `composited`-changed signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure`-event signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// This signal is emitted when the toolbar needs information from `tool_item`
    /// about whether the item should appear in the toolbar overflow menu. In
    /// response the tool item should either
    /// 
    /// - call `gtk_tool_item_set_proxy_menu_item()` with a `nil`
    ///   pointer and return `true` to indicate that the item should not appear
    ///   in the overflow menu
    /// 
    /// - call `gtk_tool_item_set_proxy_menu_item()` with a new menu
    ///   item and return `true`, or
    /// 
    /// - return `false` to indicate that the signal was not handled by the item.
    ///   This means that the item will not appear in the overflow menu unless
    ///   a later handler installs a menu item.
    /// 
    /// The toolbar may cache the result of this signal. When the tool item changes
    /// how it will respond to this signal it must call `gtk_tool_item_rebuild_menu()`
    /// to invalidate the cache and ensure that the toolbar rebuilds its overflow
    /// menu.
    case createMenuProxy = "create-menu-proxy"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete`-event signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy`-event signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag`-begin signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag`-data-delete signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag`-data-get signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag`-data-received signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag`-drop signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag`-drop signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag`-data-received handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag`-end signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag`-begin.
    case dragEnd = "drag-end"
    /// The `drag`-failed signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag`-leave signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag`-motion, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag`-leave signal is also emitted before the
    /// `drag`-drop signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag`-motion signal handler.
    case dragLeave = "drag-leave"
    /// The `drag`-motion signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag`-data-received
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag`-leave and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enter`-notify-event will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key`-press-event) and finally a generic
    /// `GtkWidget::event`-after signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event`-after will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `focus`-in-event signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus`-out-event signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab`-notify signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy`-changed signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key`-press-event signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key`-release-event signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `leave`-notify-event will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map`-event will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map`-event signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion`-notify-event signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent`-set signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The `property`-notify-event signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// The `screen`-changed signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll`-event signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `selection`-clear-event signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection`-request-event signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-changed signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style`-set signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style`-updated signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style`-updated signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    /// Emitted whenever the toggle tool button changes state.
    case toggled = "toggled"
    /// This signal is emitted when some property of the toolbar that the
    /// item is a child of changes. For custom subclasses of `GtkToolItem`,
    /// the default handler of this signal use the functions
    /// - `gtk_tool_shell_get_orientation()`
    /// - `gtk_tool_shell_get_style()`
    /// - `gtk_tool_shell_get_icon_size()`
    /// - `gtk_tool_shell_get_relief_style()`
    /// to find out what the toolbar should look like and change
    /// themselves accordingly.
    case toolbarReconfigured = "toolbar-reconfigured"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap`-event signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility`-notify-event will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    /// The `window`-state-event will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    /// If the toggle tool button should be pressed in.
    case notifyActive = "notify::active"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The name of the themed icon displayed on the item.
    /// This property only has an effect if not overridden by
    /// `GtkToolButton:label`-widget, `GtkToolButton:icon`-widget or
    /// `GtkToolButton:stock`-id properties.
    case notifyIconName = "notify::icon-name"
    case notifyIconWidget = "notify::icon-widget"
    case notifyIsFocus = "notify::is-focus"
    case notifyIsImportant = "notify::is-important"
    case notifyLabel = "notify::label"
    case notifyLabelWidget = "notify::label-widget"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizeMode = "notify::resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"

    ///
    /// **stock-id is deprecated:**
    /// Use #GtkToolButton:icon-name instead.
    case notifyStockID = "notify::stock-id"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    case notifyUseUnderline = "notify::use-underline"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyVisibleHorizontal = "notify::visible-horizontal"
    case notifyVisibleVertical = "notify::visible-vertical"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
}

public extension ToggleToolButtonProtocol {
    /// Connect a `ToggleToolButtonSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: ToggleToolButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(toggle_tool_button_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension ToggleToolButtonProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkToggleToolButton` instance.
    var toggle_tool_button_ptr: UnsafeMutablePointer<GtkToggleToolButton> { return ptr.assumingMemoryBound(to: GtkToggleToolButton.self) }

    /// Queries a `GtkToggleToolButton` and returns its current state.
    /// Returns `true` if the toggle button is pressed in and `false` if it is raised.
    func getActive() -> Bool {
        let rv = gtk_toggle_tool_button_get_active(cast(toggle_tool_button_ptr))
        return Bool(rv != 0)
    }

    /// Sets the status of the toggle tool button. Set to `true` if you
    /// want the GtkToggleButton to be “pressed in”, and `false` to raise it.
    /// This action causes the toggled signal to be emitted.
    func setActive(isActive is_active: Bool) {
        gtk_toggle_tool_button_set_active(cast(toggle_tool_button_ptr), gboolean(is_active ? 1 : 0))
    
    }
    /// If the toggle tool button should be pressed in.
    var active: Bool {
        /// Queries a `GtkToggleToolButton` and returns its current state.
        /// Returns `true` if the toggle button is pressed in and `false` if it is raised.
        get {
            let rv = gtk_toggle_tool_button_get_active(cast(toggle_tool_button_ptr))
            return Bool(rv != 0)
        }
        /// Sets the status of the toggle tool button. Set to `true` if you
        /// want the GtkToggleButton to be “pressed in”, and `false` to raise it.
        /// This action causes the toggled signal to be emitted.
        nonmutating set {
            gtk_toggle_tool_button_set_active(cast(toggle_tool_button_ptr), gboolean(newValue ? 1 : 0))
        }
    }
}



// MARK: - ToolButton Class

/// The `ToolButtonProtocol` protocol exposes the methods and properties of an underlying `GtkToolButton` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ToolButton`.
/// Alternatively, use `ToolButtonRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkToolButtons` are `GtkToolItems` containing buttons.
/// 
/// Use `gtk_tool_button_new()` to create a new `GtkToolButton`.
/// 
/// The label of a `GtkToolButton` is determined by the properties
/// `GtkToolButton:label`-widget, `GtkToolButton:label`, and
/// `GtkToolButton:stock`-id. If `GtkToolButton:label`-widget is
/// non-`nil`, then that widget is used as the label. Otherwise, if
/// `GtkToolButton:label` is non-`nil`, that string is used as the label.
/// Otherwise, if `GtkToolButton:stock`-id is non-`nil`, the label is
/// determined by the stock item. Otherwise, the button does not have a label.
/// 
/// The icon of a `GtkToolButton` is determined by the properties
/// `GtkToolButton:icon`-widget and `GtkToolButton:stock`-id. If
/// `GtkToolButton:icon`-widget is non-`nil`, then
/// that widget is used as the icon. Otherwise, if `GtkToolButton:stock`-id is
/// non-`nil`, the icon is determined by the stock item. Otherwise,
/// the button does not have a icon.
/// 
/// # CSS nodes
/// 
/// GtkToolButton has a single CSS node with name toolbutton.
public protocol ToolButtonProtocol: ToolItemProtocol, ActionableProtocol {
    /// Untyped pointer to the underlying `GtkToolButton` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkToolButton` instance.
    var tool_button_ptr: UnsafeMutablePointer<GtkToolButton> { get }
}

/// The `ToolButtonRef` type acts as a lightweight Swift reference to an underlying `GtkToolButton` instance.
/// It exposes methods that can operate on this data type through `ToolButtonProtocol` conformance.
/// Use `ToolButtonRef` only as an `unowned` reference to an existing `GtkToolButton` instance.
///
/// `GtkToolButtons` are `GtkToolItems` containing buttons.
/// 
/// Use `gtk_tool_button_new()` to create a new `GtkToolButton`.
/// 
/// The label of a `GtkToolButton` is determined by the properties
/// `GtkToolButton:label`-widget, `GtkToolButton:label`, and
/// `GtkToolButton:stock`-id. If `GtkToolButton:label`-widget is
/// non-`nil`, then that widget is used as the label. Otherwise, if
/// `GtkToolButton:label` is non-`nil`, that string is used as the label.
/// Otherwise, if `GtkToolButton:stock`-id is non-`nil`, the label is
/// determined by the stock item. Otherwise, the button does not have a label.
/// 
/// The icon of a `GtkToolButton` is determined by the properties
/// `GtkToolButton:icon`-widget and `GtkToolButton:stock`-id. If
/// `GtkToolButton:icon`-widget is non-`nil`, then
/// that widget is used as the icon. Otherwise, if `GtkToolButton:stock`-id is
/// non-`nil`, the icon is determined by the stock item. Otherwise,
/// the button does not have a icon.
/// 
/// # CSS nodes
/// 
/// GtkToolButton has a single CSS node with name toolbutton.
public struct ToolButtonRef: ToolButtonProtocol {
    /// Untyped pointer to the underlying `GtkToolButton` instance.
    /// For type-safe access, use the generated, typed pointer `tool_button_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension ToolButtonRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkToolButton>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `ToolButtonProtocol`
    init<T: ToolButtonProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolButtonProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolButtonProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolButtonProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolButtonProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolButtonProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkToolButton` using `icon_widget` as contents and `label` as
    /// label.
    init( icon_widget: WidgetProtocol, label: UnsafePointer<gchar>) {
        let rv = gtk_tool_button_new(cast(icon_widget.ptr), label)
        self.init(cast(rv))
    }

    /// Creates a new `GtkToolButton` containing the image and text from a
    /// stock item. Some stock ids have preprocessor macros like `GTK_STOCK_OK`
    /// and `GTK_STOCK_APPLY`.
    /// 
    /// It is an error if `stock_id` is not a name of a stock item.
    ///
    /// **new_from_stock is deprecated:**
    /// Use gtk_tool_button_new() together with
    /// gtk_image_new_from_icon_name() instead.
    @available(*, deprecated) init(stock stock_id: UnsafePointer<gchar>) {
        let rv = gtk_tool_button_new_from_stock(stock_id)
        self.init(cast(rv))
    }
    /// Creates a new `GtkToolButton` containing the image and text from a
    /// stock item. Some stock ids have preprocessor macros like `GTK_STOCK_OK`
    /// and `GTK_STOCK_APPLY`.
    /// 
    /// It is an error if `stock_id` is not a name of a stock item.
    ///
    /// **new_from_stock is deprecated:**
    /// Use gtk_tool_button_new() together with
    /// gtk_image_new_from_icon_name() instead.
    @available(*, deprecated) static func newFrom(stock stock_id: UnsafePointer<gchar>) -> ToolButtonRef! {
        let rv = gtk_tool_button_new_from_stock(stock_id)
        return rv.map { ToolButtonRef(cast($0)) }
    }
}

/// The `ToolButton` type acts as a reference-counted owner of an underlying `GtkToolButton` instance.
/// It provides the methods that can operate on this data type through `ToolButtonProtocol` conformance.
/// Use `ToolButton` as a strong reference or owner of a `GtkToolButton` instance.
///
/// `GtkToolButtons` are `GtkToolItems` containing buttons.
/// 
/// Use `gtk_tool_button_new()` to create a new `GtkToolButton`.
/// 
/// The label of a `GtkToolButton` is determined by the properties
/// `GtkToolButton:label`-widget, `GtkToolButton:label`, and
/// `GtkToolButton:stock`-id. If `GtkToolButton:label`-widget is
/// non-`nil`, then that widget is used as the label. Otherwise, if
/// `GtkToolButton:label` is non-`nil`, that string is used as the label.
/// Otherwise, if `GtkToolButton:stock`-id is non-`nil`, the label is
/// determined by the stock item. Otherwise, the button does not have a label.
/// 
/// The icon of a `GtkToolButton` is determined by the properties
/// `GtkToolButton:icon`-widget and `GtkToolButton:stock`-id. If
/// `GtkToolButton:icon`-widget is non-`nil`, then
/// that widget is used as the icon. Otherwise, if `GtkToolButton:stock`-id is
/// non-`nil`, the icon is determined by the stock item. Otherwise,
/// the button does not have a icon.
/// 
/// # CSS nodes
/// 
/// GtkToolButton has a single CSS node with name toolbutton.
open class ToolButton: ToolItem, ToolButtonProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `ToolButton` instance.
    public init(_ op: UnsafeMutablePointer<GtkToolButton>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `ToolButtonProtocol`
    /// Will retain `GtkToolButton`.
    public convenience init<T: ToolButtonProtocol>(_ other: T) {
        self.init(cast(other.tool_button_ptr))
        g_object_ref(cast(tool_button_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolButtonProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkToolButton.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolButtonProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkToolButton.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolButtonProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkToolButton.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolButtonProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkToolButton>(opaquePointer))
    }

    /// Creates a new `GtkToolButton` using `icon_widget` as contents and `label` as
    /// label.
    public convenience init( icon_widget: WidgetProtocol, label: UnsafePointer<gchar>) {
        let rv = gtk_tool_button_new(cast(icon_widget.ptr), label)
        self.init(cast(rv))
    }

    /// Creates a new `GtkToolButton` containing the image and text from a
    /// stock item. Some stock ids have preprocessor macros like `GTK_STOCK_OK`
    /// and `GTK_STOCK_APPLY`.
    /// 
    /// It is an error if `stock_id` is not a name of a stock item.
    ///
    /// **new_from_stock is deprecated:**
    /// Use gtk_tool_button_new() together with
    /// gtk_image_new_from_icon_name() instead.
    @available(*, deprecated) public convenience init(stock stock_id: UnsafePointer<gchar>) {
        let rv = gtk_tool_button_new_from_stock(stock_id)
        self.init(cast(rv))
    }

    /// Creates a new `GtkToolButton` containing the image and text from a
    /// stock item. Some stock ids have preprocessor macros like `GTK_STOCK_OK`
    /// and `GTK_STOCK_APPLY`.
    /// 
    /// It is an error if `stock_id` is not a name of a stock item.
    ///
    /// **new_from_stock is deprecated:**
    /// Use gtk_tool_button_new() together with
    /// gtk_image_new_from_icon_name() instead.
    @available(*, deprecated) public static func newFrom(stock stock_id: UnsafePointer<gchar>) -> ToolButton! {
        let rv = gtk_tool_button_new_from_stock(stock_id)
        return rv.map { ToolButton(cast($0)) }
    }

}

public enum ToolButtonPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case appPaintable = "app-paintable"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case compositeChild = "composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The name of the themed icon displayed on the item.
    /// This property only has an effect if not overridden by
    /// `GtkToolButton:label`-widget, `GtkToolButton:icon`-widget or
    /// `GtkToolButton:stock`-id properties.
    case iconName = "icon-name"
    case iconWidget = "icon-widget"
    case isFocus = "is-focus"
    case isImportant = "is-important"
    case label = "label"
    case labelWidget = "label-widget"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case resizeMode = "resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"

    ///
    /// **stock-id is deprecated:**
    /// Use #GtkToolButton:icon-name instead.
    case stockID = "stock-id"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    case useUnderline = "use-underline"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case visibleHorizontal = "visible-horizontal"
    case visibleVertical = "visible-vertical"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
}

public extension ToolButtonProtocol {
    /// Bind a `ToolButtonPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ToolButtonPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(tool_button_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum ToolButtonSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    case add = "add"
    /// The `button`-press-event signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button`-release-event signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child`-notify signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// This signal is emitted when the tool button is clicked with the mouse
    /// or activated with the keyboard.
    case clicked = "clicked"
    /// The `composited`-changed signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure`-event signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// This signal is emitted when the toolbar needs information from `tool_item`
    /// about whether the item should appear in the toolbar overflow menu. In
    /// response the tool item should either
    /// 
    /// - call `gtk_tool_item_set_proxy_menu_item()` with a `nil`
    ///   pointer and return `true` to indicate that the item should not appear
    ///   in the overflow menu
    /// 
    /// - call `gtk_tool_item_set_proxy_menu_item()` with a new menu
    ///   item and return `true`, or
    /// 
    /// - return `false` to indicate that the signal was not handled by the item.
    ///   This means that the item will not appear in the overflow menu unless
    ///   a later handler installs a menu item.
    /// 
    /// The toolbar may cache the result of this signal. When the tool item changes
    /// how it will respond to this signal it must call `gtk_tool_item_rebuild_menu()`
    /// to invalidate the cache and ensure that the toolbar rebuilds its overflow
    /// menu.
    case createMenuProxy = "create-menu-proxy"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete`-event signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy`-event signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag`-begin signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag`-data-delete signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag`-data-get signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag`-data-received signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag`-drop signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag`-drop signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag`-data-received handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag`-end signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag`-begin.
    case dragEnd = "drag-end"
    /// The `drag`-failed signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag`-leave signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag`-motion, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag`-leave signal is also emitted before the
    /// `drag`-drop signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag`-motion signal handler.
    case dragLeave = "drag-leave"
    /// The `drag`-motion signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag`-data-received
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag`-leave and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enter`-notify-event will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key`-press-event) and finally a generic
    /// `GtkWidget::event`-after signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event`-after will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `focus`-in-event signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus`-out-event signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab`-notify signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy`-changed signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key`-press-event signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key`-release-event signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `leave`-notify-event will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map`-event will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map`-event signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion`-notify-event signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent`-set signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The `property`-notify-event signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// The `screen`-changed signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll`-event signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `selection`-clear-event signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection`-request-event signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-changed signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style`-set signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style`-updated signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style`-updated signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    /// This signal is emitted when some property of the toolbar that the
    /// item is a child of changes. For custom subclasses of `GtkToolItem`,
    /// the default handler of this signal use the functions
    /// - `gtk_tool_shell_get_orientation()`
    /// - `gtk_tool_shell_get_style()`
    /// - `gtk_tool_shell_get_icon_size()`
    /// - `gtk_tool_shell_get_relief_style()`
    /// to find out what the toolbar should look like and change
    /// themselves accordingly.
    case toolbarReconfigured = "toolbar-reconfigured"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap`-event signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility`-notify-event will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    /// The `window`-state-event will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The name of the themed icon displayed on the item.
    /// This property only has an effect if not overridden by
    /// `GtkToolButton:label`-widget, `GtkToolButton:icon`-widget or
    /// `GtkToolButton:stock`-id properties.
    case notifyIconName = "notify::icon-name"
    case notifyIconWidget = "notify::icon-widget"
    case notifyIsFocus = "notify::is-focus"
    case notifyIsImportant = "notify::is-important"
    case notifyLabel = "notify::label"
    case notifyLabelWidget = "notify::label-widget"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizeMode = "notify::resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"

    ///
    /// **stock-id is deprecated:**
    /// Use #GtkToolButton:icon-name instead.
    case notifyStockID = "notify::stock-id"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    case notifyUseUnderline = "notify::use-underline"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyVisibleHorizontal = "notify::visible-horizontal"
    case notifyVisibleVertical = "notify::visible-vertical"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
}

public extension ToolButtonProtocol {
    /// Connect a `ToolButtonSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: ToolButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(tool_button_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension ToolButtonProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkToolButton` instance.
    var tool_button_ptr: UnsafeMutablePointer<GtkToolButton> { return ptr.assumingMemoryBound(to: GtkToolButton.self) }

    /// Returns the name of the themed icon for the tool button,
    /// see `gtk_tool_button_set_icon_name()`.
    func getIconName() -> String! {
        let rv = gtk_tool_button_get_icon_name(cast(tool_button_ptr))
        return rv.map { String(cString: UnsafePointer<CChar>($0)) }
    }

    /// Return the widget used as icon widget on `button`.
    /// See `gtk_tool_button_set_icon_widget()`.
    func getIconWidget() -> UnsafeMutablePointer<GtkWidget>! {
        let rv = gtk_tool_button_get_icon_widget(cast(tool_button_ptr))
        return cast(rv)
    }

    /// Returns the label used by the tool button, or `nil` if the tool button
    /// doesn’t have a label. or uses a the label from a stock item. The returned
    /// string is owned by GTK+, and must not be modified or freed.
    func getLabel() -> String! {
        let rv = gtk_tool_button_get_label(cast(tool_button_ptr))
        return rv.map { String(cString: UnsafePointer<CChar>($0)) }
    }

    /// Returns the widget used as label on `button`.
    /// See `gtk_tool_button_set_label_widget()`.
    func getLabelWidget() -> UnsafeMutablePointer<GtkWidget>! {
        let rv = gtk_tool_button_get_label_widget(cast(tool_button_ptr))
        return cast(rv)
    }

    /// Returns the name of the stock item. See `gtk_tool_button_set_stock_id()`.
    /// The returned string is owned by GTK+ and must not be freed or modifed.
    ///
    /// **get_stock_id is deprecated:**
    /// Use gtk_tool_button_get_icon_name() instead.
    @available(*, deprecated) func getStockID() -> String! {
        let rv = gtk_tool_button_get_stock_id(cast(tool_button_ptr))
        return rv.map { String(cString: UnsafePointer<CChar>($0)) }
    }

    /// Returns whether underscores in the label property are used as mnemonics
    /// on menu items on the overflow menu. See `gtk_tool_button_set_use_underline()`.
    func getUseUnderline() -> Bool {
        let rv = gtk_tool_button_get_use_underline(cast(tool_button_ptr))
        return Bool(rv != 0)
    }

    /// Sets the icon for the tool button from a named themed icon.
    /// See the docs for `GtkIconTheme` for more details.
    /// The `GtkToolButton:icon`-name property only has an effect if not
    /// overridden by non-`nil` `GtkToolButton:label`-widget,
    /// `GtkToolButton:icon`-widget and `GtkToolButton:stock`-id properties.
    func set(iconName icon_name: UnsafePointer<gchar>) {
        gtk_tool_button_set_icon_name(cast(tool_button_ptr), icon_name)
    
    }

    /// Sets `icon` as the widget used as icon on `button`. If `icon_widget` is
    /// `nil` the icon is determined by the `GtkToolButton:stock`-id property. If the
    /// `GtkToolButton:stock`-id property is also `nil`, `button` will not have an icon.
    func set(iconWidget icon_widget: WidgetProtocol) {
        gtk_tool_button_set_icon_widget(cast(tool_button_ptr), cast(icon_widget.ptr))
    
    }

    /// Sets `label` as the label used for the tool button. The `GtkToolButton:label`
    /// property only has an effect if not overridden by a non-`nil`
    /// `GtkToolButton:label`-widget property. If both the `GtkToolButton:label`-widget
    /// and `GtkToolButton:label` properties are `nil`, the label is determined by the
    /// `GtkToolButton:stock`-id property. If the `GtkToolButton:stock`-id property is
    /// also `nil`, `button` will not have a label.
    func set(label: UnsafePointer<gchar>) {
        gtk_tool_button_set_label(cast(tool_button_ptr), label)
    
    }

    /// Sets `label_widget` as the widget that will be used as the label
    /// for `button`. If `label_widget` is `nil` the `GtkToolButton:label` property is used
    /// as label. If `GtkToolButton:label` is also `nil`, the label in the stock item
    /// determined by the `GtkToolButton:stock`-id property is used as label. If
    /// `GtkToolButton:stock`-id is also `nil`, `button` does not have a label.
    func set(labelWidget label_widget: WidgetProtocol) {
        gtk_tool_button_set_label_widget(cast(tool_button_ptr), cast(label_widget.ptr))
    
    }

    /// Sets the name of the stock item. See `gtk_tool_button_new_from_stock()`.
    /// The stock_id property only has an effect if not overridden by non-`nil`
    /// `GtkToolButton:label`-widget and `GtkToolButton:icon`-widget properties.
    ///
    /// **set_stock_id is deprecated:**
    /// Use gtk_tool_button_set_icon_name() instead.
    @available(*, deprecated) func set(stockID stock_id: UnsafePointer<gchar>) {
        gtk_tool_button_set_stock_id(cast(tool_button_ptr), stock_id)
    
    }

    /// If set, an underline in the label property indicates that the next character
    /// should be used for the mnemonic accelerator key in the overflow menu. For
    /// example, if the label property is “_Open” and `use_underline` is `true`,
    /// the label on the tool button will be “Open” and the item on the overflow
    /// menu will have an underlined “O”.
    /// 
    /// Labels shown on tool buttons never have mnemonics on them; this property
    /// only affects the menu item on the overflow menu.
    func set(useUnderline use_underline: Bool) {
        gtk_tool_button_set_use_underline(cast(tool_button_ptr), gboolean(use_underline ? 1 : 0))
    
    }
    /// Returns the name of the themed icon for the tool button,
    /// see `gtk_tool_button_set_icon_name()`.
    var iconName: String! {
        /// Returns the name of the themed icon for the tool button,
        /// see `gtk_tool_button_set_icon_name()`.
        get {
            let rv = gtk_tool_button_get_icon_name(cast(tool_button_ptr))
            return rv.map { String(cString: UnsafePointer<CChar>($0)) }
        }
        /// Sets the icon for the tool button from a named themed icon.
        /// See the docs for `GtkIconTheme` for more details.
        /// The `GtkToolButton:icon`-name property only has an effect if not
        /// overridden by non-`nil` `GtkToolButton:label`-widget,
        /// `GtkToolButton:icon`-widget and `GtkToolButton:stock`-id properties.
        nonmutating set {
            gtk_tool_button_set_icon_name(cast(tool_button_ptr), newValue)
        }
    }

    /// Return the widget used as icon widget on `button`.
    /// See `gtk_tool_button_set_icon_widget()`.
    var iconWidget: UnsafeMutablePointer<GtkWidget>! {
        /// Return the widget used as icon widget on `button`.
        /// See `gtk_tool_button_set_icon_widget()`.
        get {
            let rv = gtk_tool_button_get_icon_widget(cast(tool_button_ptr))
            return cast(rv)
        }
        /// Sets `icon` as the widget used as icon on `button`. If `icon_widget` is
        /// `nil` the icon is determined by the `GtkToolButton:stock`-id property. If the
        /// `GtkToolButton:stock`-id property is also `nil`, `button` will not have an icon.
        nonmutating set {
            gtk_tool_button_set_icon_widget(cast(tool_button_ptr), cast(newValue))
        }
    }

    var label: String! {
        /// Returns the label used by the tool button, or `nil` if the tool button
        /// doesn’t have a label. or uses a the label from a stock item. The returned
        /// string is owned by GTK+, and must not be modified or freed.
        get {
            let rv = gtk_tool_button_get_label(cast(tool_button_ptr))
            return rv.map { String(cString: UnsafePointer<CChar>($0)) }
        }
        /// Sets `label` as the label used for the tool button. The `GtkToolButton:label`
        /// property only has an effect if not overridden by a non-`nil`
        /// `GtkToolButton:label`-widget property. If both the `GtkToolButton:label`-widget
        /// and `GtkToolButton:label` properties are `nil`, the label is determined by the
        /// `GtkToolButton:stock`-id property. If the `GtkToolButton:stock`-id property is
        /// also `nil`, `button` will not have a label.
        nonmutating set {
            gtk_tool_button_set_label(cast(tool_button_ptr), newValue)
        }
    }

    /// Returns the widget used as label on `button`.
    /// See `gtk_tool_button_set_label_widget()`.
    var labelWidget: UnsafeMutablePointer<GtkWidget>! {
        /// Returns the widget used as label on `button`.
        /// See `gtk_tool_button_set_label_widget()`.
        get {
            let rv = gtk_tool_button_get_label_widget(cast(tool_button_ptr))
            return cast(rv)
        }
        /// Sets `label_widget` as the widget that will be used as the label
        /// for `button`. If `label_widget` is `nil` the `GtkToolButton:label` property is used
        /// as label. If `GtkToolButton:label` is also `nil`, the label in the stock item
        /// determined by the `GtkToolButton:stock`-id property is used as label. If
        /// `GtkToolButton:stock`-id is also `nil`, `button` does not have a label.
        nonmutating set {
            gtk_tool_button_set_label_widget(cast(tool_button_ptr), cast(newValue))
        }
    }

    /// Returns the name of the stock item. See `gtk_tool_button_set_stock_id()`.
    /// The returned string is owned by GTK+ and must not be freed or modifed.
    ///
    /// **get_stock_id is deprecated:**
    /// Use gtk_tool_button_get_icon_name() instead.
    var stockID: String! {
        /// Returns the name of the stock item. See `gtk_tool_button_set_stock_id()`.
        /// The returned string is owned by GTK+ and must not be freed or modifed.
        ///
        /// **get_stock_id is deprecated:**
        /// Use gtk_tool_button_get_icon_name() instead.
        @available(*, deprecated) get {
            let rv = gtk_tool_button_get_stock_id(cast(tool_button_ptr))
            return rv.map { String(cString: UnsafePointer<CChar>($0)) }
        }
        /// Sets the name of the stock item. See `gtk_tool_button_new_from_stock()`.
        /// The stock_id property only has an effect if not overridden by non-`nil`
        /// `GtkToolButton:label`-widget and `GtkToolButton:icon`-widget properties.
        ///
        /// **set_stock_id is deprecated:**
        /// Use gtk_tool_button_set_icon_name() instead.
        @available(*, deprecated) nonmutating set {
            gtk_tool_button_set_stock_id(cast(tool_button_ptr), newValue)
        }
    }

    /// Returns whether underscores in the label property are used as mnemonics
    /// on menu items on the overflow menu. See `gtk_tool_button_set_use_underline()`.
    var useUnderline: Bool {
        /// Returns whether underscores in the label property are used as mnemonics
        /// on menu items on the overflow menu. See `gtk_tool_button_set_use_underline()`.
        get {
            let rv = gtk_tool_button_get_use_underline(cast(tool_button_ptr))
            return Bool(rv != 0)
        }
        /// If set, an underline in the label property indicates that the next character
        /// should be used for the mnemonic accelerator key in the overflow menu. For
        /// example, if the label property is “_Open” and `use_underline` is `true`,
        /// the label on the tool button will be “Open” and the item on the overflow
        /// menu will have an underlined “O”.
        /// 
        /// Labels shown on tool buttons never have mnemonics on them; this property
        /// only affects the menu item on the overflow menu.
        nonmutating set {
            gtk_tool_button_set_use_underline(cast(tool_button_ptr), gboolean(newValue ? 1 : 0))
        }
    }
}



// MARK: - ToolItem Class

/// The `ToolItemProtocol` protocol exposes the methods and properties of an underlying `GtkToolItem` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ToolItem`.
/// Alternatively, use `ToolItemRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkToolItems` are widgets that can appear on a toolbar. To
/// create a toolbar item that contain something else than a button, use
/// `gtk_tool_item_new()`. Use `gtk_container_add()` to add a child
/// widget to the tool item.
/// 
/// For toolbar items that contain buttons, see the `GtkToolButton`,
/// `GtkToggleToolButton` and `GtkRadioToolButton` classes.
/// 
/// See the `GtkToolbar` class for a description of the toolbar widget, and
/// `GtkToolShell` for a description of the tool shell interface.
public protocol ToolItemProtocol: BinProtocol, ActivatableProtocol {
    /// Untyped pointer to the underlying `GtkToolItem` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkToolItem` instance.
    var tool_item_ptr: UnsafeMutablePointer<GtkToolItem> { get }
}

/// The `ToolItemRef` type acts as a lightweight Swift reference to an underlying `GtkToolItem` instance.
/// It exposes methods that can operate on this data type through `ToolItemProtocol` conformance.
/// Use `ToolItemRef` only as an `unowned` reference to an existing `GtkToolItem` instance.
///
/// `GtkToolItems` are widgets that can appear on a toolbar. To
/// create a toolbar item that contain something else than a button, use
/// `gtk_tool_item_new()`. Use `gtk_container_add()` to add a child
/// widget to the tool item.
/// 
/// For toolbar items that contain buttons, see the `GtkToolButton`,
/// `GtkToggleToolButton` and `GtkRadioToolButton` classes.
/// 
/// See the `GtkToolbar` class for a description of the toolbar widget, and
/// `GtkToolShell` for a description of the tool shell interface.
public struct ToolItemRef: ToolItemProtocol {
    /// Untyped pointer to the underlying `GtkToolItem` instance.
    /// For type-safe access, use the generated, typed pointer `tool_item_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension ToolItemRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkToolItem>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `ToolItemProtocol`
    init<T: ToolItemProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkToolItem`
    init() {
        let rv = gtk_tool_item_new()
        self.init(cast(rv))
    }
}

/// The `ToolItem` type acts as a reference-counted owner of an underlying `GtkToolItem` instance.
/// It provides the methods that can operate on this data type through `ToolItemProtocol` conformance.
/// Use `ToolItem` as a strong reference or owner of a `GtkToolItem` instance.
///
/// `GtkToolItems` are widgets that can appear on a toolbar. To
/// create a toolbar item that contain something else than a button, use
/// `gtk_tool_item_new()`. Use `gtk_container_add()` to add a child
/// widget to the tool item.
/// 
/// For toolbar items that contain buttons, see the `GtkToolButton`,
/// `GtkToggleToolButton` and `GtkRadioToolButton` classes.
/// 
/// See the `GtkToolbar` class for a description of the toolbar widget, and
/// `GtkToolShell` for a description of the tool shell interface.
open class ToolItem: Bin, ToolItemProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `ToolItem` instance.
    public init(_ op: UnsafeMutablePointer<GtkToolItem>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `ToolItemProtocol`
    /// Will retain `GtkToolItem`.
    public convenience init<T: ToolItemProtocol>(_ other: T) {
        self.init(cast(other.tool_item_ptr))
        g_object_ref(cast(tool_item_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkToolItem.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkToolItem.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkToolItem.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkToolItem>(opaquePointer))
    }

    /// Creates a new `GtkToolItem`
    public convenience init() {
        let rv = gtk_tool_item_new()
        self.init(cast(rv))
    }


}

public enum ToolItemPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case appPaintable = "app-paintable"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case compositeChild = "composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    case isFocus = "is-focus"
    case isImportant = "is-important"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case resizeMode = "resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case visibleHorizontal = "visible-horizontal"
    case visibleVertical = "visible-vertical"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
}

public extension ToolItemProtocol {
    /// Bind a `ToolItemPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ToolItemPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(tool_item_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum ToolItemSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    case add = "add"
    /// The `button`-press-event signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button`-release-event signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child`-notify signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The `composited`-changed signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure`-event signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// This signal is emitted when the toolbar needs information from `tool_item`
    /// about whether the item should appear in the toolbar overflow menu. In
    /// response the tool item should either
    /// 
    /// - call `gtk_tool_item_set_proxy_menu_item()` with a `nil`
    ///   pointer and return `true` to indicate that the item should not appear
    ///   in the overflow menu
    /// 
    /// - call `gtk_tool_item_set_proxy_menu_item()` with a new menu
    ///   item and return `true`, or
    /// 
    /// - return `false` to indicate that the signal was not handled by the item.
    ///   This means that the item will not appear in the overflow menu unless
    ///   a later handler installs a menu item.
    /// 
    /// The toolbar may cache the result of this signal. When the tool item changes
    /// how it will respond to this signal it must call `gtk_tool_item_rebuild_menu()`
    /// to invalidate the cache and ensure that the toolbar rebuilds its overflow
    /// menu.
    case createMenuProxy = "create-menu-proxy"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete`-event signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy`-event signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag`-begin signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag`-data-delete signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag`-data-get signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag`-data-received signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag`-drop signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag`-drop signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag`-data-received handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag`-end signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag`-begin.
    case dragEnd = "drag-end"
    /// The `drag`-failed signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag`-leave signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag`-motion, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag`-leave signal is also emitted before the
    /// `drag`-drop signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag`-motion signal handler.
    case dragLeave = "drag-leave"
    /// The `drag`-motion signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag`-data-received
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag`-leave and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enter`-notify-event will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key`-press-event) and finally a generic
    /// `GtkWidget::event`-after signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event`-after will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `focus`-in-event signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus`-out-event signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab`-notify signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy`-changed signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key`-press-event signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key`-release-event signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `leave`-notify-event will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map`-event will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map`-event signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion`-notify-event signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent`-set signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The `property`-notify-event signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// The `screen`-changed signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll`-event signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `selection`-clear-event signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection`-request-event signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-changed signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style`-set signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style`-updated signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style`-updated signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    /// This signal is emitted when some property of the toolbar that the
    /// item is a child of changes. For custom subclasses of `GtkToolItem`,
    /// the default handler of this signal use the functions
    /// - `gtk_tool_shell_get_orientation()`
    /// - `gtk_tool_shell_get_style()`
    /// - `gtk_tool_shell_get_icon_size()`
    /// - `gtk_tool_shell_get_relief_style()`
    /// to find out what the toolbar should look like and change
    /// themselves accordingly.
    case toolbarReconfigured = "toolbar-reconfigured"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap`-event signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility`-notify-event will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    /// The `window`-state-event will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    case notifyIsFocus = "notify::is-focus"
    case notifyIsImportant = "notify::is-important"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizeMode = "notify::resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyVisibleHorizontal = "notify::visible-horizontal"
    case notifyVisibleVertical = "notify::visible-vertical"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
}

public extension ToolItemProtocol {
    /// Connect a `ToolItemSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: ToolItemSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(tool_item_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension ToolItemProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkToolItem` instance.
    var tool_item_ptr: UnsafeMutablePointer<GtkToolItem> { return ptr.assumingMemoryBound(to: GtkToolItem.self) }

    /// Returns the ellipsize mode used for `tool_item`. Custom subclasses of
    /// `GtkToolItem` should call this function to find out how text should
    /// be ellipsized.
    func getEllipsizeMode() -> PangoEllipsizeMode {
        let rv = gtk_tool_item_get_ellipsize_mode(cast(tool_item_ptr))
        return rv
    }

    /// Returns whether `tool_item` is allocated extra space.
    /// See `gtk_tool_item_set_expand()`.
    func getExpand() -> Bool {
        let rv = gtk_tool_item_get_expand(cast(tool_item_ptr))
        return Bool(rv != 0)
    }

    /// Returns whether `tool_item` is the same size as other homogeneous
    /// items. See `gtk_tool_item_set_homogeneous()`.
    func getHomogeneous() -> Bool {
        let rv = gtk_tool_item_get_homogeneous(cast(tool_item_ptr))
        return Bool(rv != 0)
    }

    /// Returns the icon size used for `tool_item`. Custom subclasses of
    /// `GtkToolItem` should call this function to find out what size icons
    /// they should use.
    func getIconSize() -> GtkIconSize {
        let rv = gtk_tool_item_get_icon_size(cast(tool_item_ptr))
        return rv
    }

    /// Returns whether `tool_item` is considered important. See
    /// `gtk_tool_item_set_is_important()`
    func getIsImportant() -> Bool {
        let rv = gtk_tool_item_get_is_important(cast(tool_item_ptr))
        return Bool(rv != 0)
    }

    /// Returns the orientation used for `tool_item`. Custom subclasses of
    /// `GtkToolItem` should call this function to find out what size icons
    /// they should use.
    func getOrientation() -> GtkOrientation {
        let rv = gtk_tool_item_get_orientation(cast(tool_item_ptr))
        return rv
    }

    /// If `menu_item_id` matches the string passed to
    /// `gtk_tool_item_set_proxy_menu_item()` return the corresponding `GtkMenuItem`.
    /// 
    /// Custom subclasses of `GtkToolItem` should use this function to
    /// update their menu item when the `GtkToolItem` changes. That the
    /// `menu_item_ids` must match ensures that a `GtkToolItem`
    /// will not inadvertently change a menu item that they did not create.
    func getProxyMenuItem(menuItemID menu_item_id: UnsafePointer<gchar>) -> UnsafeMutablePointer<GtkWidget>! {
        let rv = gtk_tool_item_get_proxy_menu_item(cast(tool_item_ptr), menu_item_id)
        return cast(rv)
    }

    /// Returns the relief style of `tool_item`. See `gtk_button_set_relief()`.
    /// Custom subclasses of `GtkToolItem` should call this function in the handler
    /// of the `GtkToolItem::toolbar_reconfigured` signal to find out the
    /// relief style of buttons.
    func getReliefStyle() -> GtkReliefStyle {
        let rv = gtk_tool_item_get_relief_style(cast(tool_item_ptr))
        return rv
    }

    /// Returns the text alignment used for `tool_item`. Custom subclasses of
    /// `GtkToolItem` should call this function to find out how text should
    /// be aligned.
    func getTextAlignment() -> gfloat {
        let rv = gtk_tool_item_get_text_alignment(cast(tool_item_ptr))
        return rv
    }

    /// Returns the text orientation used for `tool_item`. Custom subclasses of
    /// `GtkToolItem` should call this function to find out how text should
    /// be orientated.
    func getTextOrientation() -> GtkOrientation {
        let rv = gtk_tool_item_get_text_orientation(cast(tool_item_ptr))
        return rv
    }

    /// Returns the size group used for labels in `tool_item`.
    /// Custom subclasses of `GtkToolItem` should call this function
    /// and use the size group for labels.
    func getTextSizeGroup() -> UnsafeMutablePointer<GtkSizeGroup>! {
        let rv = gtk_tool_item_get_text_size_group(cast(tool_item_ptr))
        return cast(rv)
    }

    /// Returns the toolbar style used for `tool_item`. Custom subclasses of
    /// `GtkToolItem` should call this function in the handler of the
    /// GtkToolItem`toolbar_reconfigured` signal to find out in what style
    /// the toolbar is displayed and change themselves accordingly
    /// 
    /// Possibilities are:
    /// - `GTK_TOOLBAR_BOTH`, meaning the tool item should show
    ///   both an icon and a label, stacked vertically
    /// - `GTK_TOOLBAR_ICONS`, meaning the toolbar shows only icons
    /// - `GTK_TOOLBAR_TEXT`, meaning the tool item should only show text
    /// - `GTK_TOOLBAR_BOTH_HORIZ`, meaning the tool item should show
    ///   both an icon and a label, arranged horizontally
    func getToolbarStyle() -> GtkToolbarStyle {
        let rv = gtk_tool_item_get_toolbar_style(cast(tool_item_ptr))
        return rv
    }

    /// Returns whether `tool_item` has a drag window. See
    /// `gtk_tool_item_set_use_drag_window()`.
    func getUseDragWindow() -> Bool {
        let rv = gtk_tool_item_get_use_drag_window(cast(tool_item_ptr))
        return Bool(rv != 0)
    }

    /// Returns whether the `tool_item` is visible on toolbars that are
    /// docked horizontally.
    func getVisibleHorizontal() -> Bool {
        let rv = gtk_tool_item_get_visible_horizontal(cast(tool_item_ptr))
        return Bool(rv != 0)
    }

    /// Returns whether `tool_item` is visible when the toolbar is docked vertically.
    /// See `gtk_tool_item_set_visible_vertical()`.
    func getVisibleVertical() -> Bool {
        let rv = gtk_tool_item_get_visible_vertical(cast(tool_item_ptr))
        return Bool(rv != 0)
    }

    /// Calling this function signals to the toolbar that the
    /// overflow menu item for `tool_item` has changed. If the
    /// overflow menu is visible when this function it called,
    /// the menu will be rebuilt.
    /// 
    /// The function must be called when the tool item changes what it
    /// will do in response to the `GtkToolItem::create`-menu-proxy signal.
    func rebuildMenu() {
        gtk_tool_item_rebuild_menu(cast(tool_item_ptr))
    
    }

    /// Returns the `GtkMenuItem` that was last set by
    /// `gtk_tool_item_set_proxy_menu_item()`, ie. the `GtkMenuItem`
    /// that is going to appear in the overflow menu.
    func retrieveProxyMenuItem() -> UnsafeMutablePointer<GtkWidget>! {
        let rv = gtk_tool_item_retrieve_proxy_menu_item(cast(tool_item_ptr))
        return cast(rv)
    }

    /// Sets whether `tool_item` is allocated extra space when there
    /// is more room on the toolbar then needed for the items. The
    /// effect is that the item gets bigger when the toolbar gets bigger
    /// and smaller when the toolbar gets smaller.
    func set(expand: Bool) {
        gtk_tool_item_set_expand(cast(tool_item_ptr), gboolean(expand ? 1 : 0))
    
    }

    /// Sets whether `tool_item` is to be allocated the same size as other
    /// homogeneous items. The effect is that all homogeneous items will have
    /// the same width as the widest of the items.
    func set(homogeneous: Bool) {
        gtk_tool_item_set_homogeneous(cast(tool_item_ptr), gboolean(homogeneous ? 1 : 0))
    
    }

    /// Sets whether `tool_item` should be considered important. The `GtkToolButton`
    /// class uses this property to determine whether to show or hide its label
    /// when the toolbar style is `GTK_TOOLBAR_BOTH_HORIZ`. The result is that
    /// only tool buttons with the “is_important” property set have labels, an
    /// effect known as “priority text”
    func set(isImportant is_important: Bool) {
        gtk_tool_item_set_is_important(cast(tool_item_ptr), gboolean(is_important ? 1 : 0))
    
    }

    /// Sets the `GtkMenuItem` used in the toolbar overflow menu. The
    /// `menu_item_id` is used to identify the caller of this function and
    /// should also be used with `gtk_tool_item_get_proxy_menu_item()`.
    /// 
    /// See also `GtkToolItem::create`-menu-proxy.
    func setProxyMenuItem(menuItemID menu_item_id: UnsafePointer<gchar>, menuItem menu_item: WidgetProtocol) {
        gtk_tool_item_set_proxy_menu_item(cast(tool_item_ptr), menu_item_id, cast(menu_item.ptr))
    
    }

    /// Sets the markup text to be displayed as tooltip on the item.
    /// See `gtk_widget_set_tooltip_markup()`.
    func setTooltip(markup: UnsafePointer<gchar>) {
        gtk_tool_item_set_tooltip_markup(cast(tool_item_ptr), markup)
    
    }

    /// Sets the text to be displayed as tooltip on the item.
    /// See `gtk_widget_set_tooltip_text()`.
    func setTooltip(text: UnsafePointer<gchar>) {
        gtk_tool_item_set_tooltip_text(cast(tool_item_ptr), text)
    
    }

    /// Sets whether `tool_item` has a drag window. When `true` the
    /// toolitem can be used as a drag source through `gtk_drag_source_set()`.
    /// When `tool_item` has a drag window it will intercept all events,
    /// even those that would otherwise be sent to a child of `tool_item`.
    func set(useDragWindow use_drag_window: Bool) {
        gtk_tool_item_set_use_drag_window(cast(tool_item_ptr), gboolean(use_drag_window ? 1 : 0))
    
    }

    /// Sets whether `tool_item` is visible when the toolbar is docked horizontally.
    func set(visibleHorizontal visible_horizontal: Bool) {
        gtk_tool_item_set_visible_horizontal(cast(tool_item_ptr), gboolean(visible_horizontal ? 1 : 0))
    
    }

    /// Sets whether `tool_item` is visible when the toolbar is docked
    /// vertically. Some tool items, such as text entries, are too wide to be
    /// useful on a vertically docked toolbar. If `visible_vertical` is `false`
    /// `tool_item` will not appear on toolbars that are docked vertically.
    func set(visibleVertical visible_vertical: Bool) {
        gtk_tool_item_set_visible_vertical(cast(tool_item_ptr), gboolean(visible_vertical ? 1 : 0))
    
    }

    /// Emits the signal `GtkToolItem::toolbar_reconfigured` on `tool_item`.
    /// `GtkToolbar` and other `GtkToolShell` implementations use this function
    /// to notify children, when some aspect of their configuration changes.
    func toolbarReconfigured() {
        gtk_tool_item_toolbar_reconfigured(cast(tool_item_ptr))
    
    }
    /// Returns the ellipsize mode used for `tool_item`. Custom subclasses of
    /// `GtkToolItem` should call this function to find out how text should
    /// be ellipsized.
    var ellipsizeMode: PangoEllipsizeMode {
        /// Returns the ellipsize mode used for `tool_item`. Custom subclasses of
        /// `GtkToolItem` should call this function to find out how text should
        /// be ellipsized.
        get {
            let rv = gtk_tool_item_get_ellipsize_mode(cast(tool_item_ptr))
            return rv
        }
    }

    /// Returns whether `tool_item` is allocated extra space.
    /// See `gtk_tool_item_set_expand()`.
    var expand: Bool {
        /// Returns whether `tool_item` is allocated extra space.
        /// See `gtk_tool_item_set_expand()`.
        get {
            let rv = gtk_tool_item_get_expand(cast(tool_item_ptr))
            return Bool(rv != 0)
        }
        /// Sets whether `tool_item` is allocated extra space when there
        /// is more room on the toolbar then needed for the items. The
        /// effect is that the item gets bigger when the toolbar gets bigger
        /// and smaller when the toolbar gets smaller.
        nonmutating set {
            gtk_tool_item_set_expand(cast(tool_item_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Returns whether `tool_item` is the same size as other homogeneous
    /// items. See `gtk_tool_item_set_homogeneous()`.
    var homogeneous: Bool {
        /// Returns whether `tool_item` is the same size as other homogeneous
        /// items. See `gtk_tool_item_set_homogeneous()`.
        get {
            let rv = gtk_tool_item_get_homogeneous(cast(tool_item_ptr))
            return Bool(rv != 0)
        }
        /// Sets whether `tool_item` is to be allocated the same size as other
        /// homogeneous items. The effect is that all homogeneous items will have
        /// the same width as the widest of the items.
        nonmutating set {
            gtk_tool_item_set_homogeneous(cast(tool_item_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Returns the icon size used for `tool_item`. Custom subclasses of
    /// `GtkToolItem` should call this function to find out what size icons
    /// they should use.
    var iconSize: GtkIconSize {
        /// Returns the icon size used for `tool_item`. Custom subclasses of
        /// `GtkToolItem` should call this function to find out what size icons
        /// they should use.
        get {
            let rv = gtk_tool_item_get_icon_size(cast(tool_item_ptr))
            return rv
        }
    }

    /// Returns whether `tool_item` is considered important. See
    /// `gtk_tool_item_set_is_important()`
    var isImportant: Bool {
        /// Returns whether `tool_item` is considered important. See
        /// `gtk_tool_item_set_is_important()`
        get {
            let rv = gtk_tool_item_get_is_important(cast(tool_item_ptr))
            return Bool(rv != 0)
        }
        /// Sets whether `tool_item` should be considered important. The `GtkToolButton`
        /// class uses this property to determine whether to show or hide its label
        /// when the toolbar style is `GTK_TOOLBAR_BOTH_HORIZ`. The result is that
        /// only tool buttons with the “is_important” property set have labels, an
        /// effect known as “priority text”
        nonmutating set {
            gtk_tool_item_set_is_important(cast(tool_item_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Returns the orientation used for `tool_item`. Custom subclasses of
    /// `GtkToolItem` should call this function to find out what size icons
    /// they should use.
    var orientation: GtkOrientation {
        /// Returns the orientation used for `tool_item`. Custom subclasses of
        /// `GtkToolItem` should call this function to find out what size icons
        /// they should use.
        get {
            let rv = gtk_tool_item_get_orientation(cast(tool_item_ptr))
            return rv
        }
    }

    /// Returns the relief style of `tool_item`. See `gtk_button_set_relief()`.
    /// Custom subclasses of `GtkToolItem` should call this function in the handler
    /// of the `GtkToolItem::toolbar_reconfigured` signal to find out the
    /// relief style of buttons.
    var reliefStyle: GtkReliefStyle {
        /// Returns the relief style of `tool_item`. See `gtk_button_set_relief()`.
        /// Custom subclasses of `GtkToolItem` should call this function in the handler
        /// of the `GtkToolItem::toolbar_reconfigured` signal to find out the
        /// relief style of buttons.
        get {
            let rv = gtk_tool_item_get_relief_style(cast(tool_item_ptr))
            return rv
        }
    }

    /// Returns the text alignment used for `tool_item`. Custom subclasses of
    /// `GtkToolItem` should call this function to find out how text should
    /// be aligned.
    var textAlignment: gfloat {
        /// Returns the text alignment used for `tool_item`. Custom subclasses of
        /// `GtkToolItem` should call this function to find out how text should
        /// be aligned.
        get {
            let rv = gtk_tool_item_get_text_alignment(cast(tool_item_ptr))
            return rv
        }
    }

    /// Returns the text orientation used for `tool_item`. Custom subclasses of
    /// `GtkToolItem` should call this function to find out how text should
    /// be orientated.
    var textOrientation: GtkOrientation {
        /// Returns the text orientation used for `tool_item`. Custom subclasses of
        /// `GtkToolItem` should call this function to find out how text should
        /// be orientated.
        get {
            let rv = gtk_tool_item_get_text_orientation(cast(tool_item_ptr))
            return rv
        }
    }

    /// Returns the size group used for labels in `tool_item`.
    /// Custom subclasses of `GtkToolItem` should call this function
    /// and use the size group for labels.
    var textSizeGroup: UnsafeMutablePointer<GtkSizeGroup>! {
        /// Returns the size group used for labels in `tool_item`.
        /// Custom subclasses of `GtkToolItem` should call this function
        /// and use the size group for labels.
        get {
            let rv = gtk_tool_item_get_text_size_group(cast(tool_item_ptr))
            return cast(rv)
        }
    }

    /// Returns the toolbar style used for `tool_item`. Custom subclasses of
    /// `GtkToolItem` should call this function in the handler of the
    /// GtkToolItem`toolbar_reconfigured` signal to find out in what style
    /// the toolbar is displayed and change themselves accordingly
    /// 
    /// Possibilities are:
    /// - `GTK_TOOLBAR_BOTH`, meaning the tool item should show
    ///   both an icon and a label, stacked vertically
    /// - `GTK_TOOLBAR_ICONS`, meaning the toolbar shows only icons
    /// - `GTK_TOOLBAR_TEXT`, meaning the tool item should only show text
    /// - `GTK_TOOLBAR_BOTH_HORIZ`, meaning the tool item should show
    ///   both an icon and a label, arranged horizontally
    var toolbarStyle: GtkToolbarStyle {
        /// Returns the toolbar style used for `tool_item`. Custom subclasses of
        /// `GtkToolItem` should call this function in the handler of the
        /// GtkToolItem`toolbar_reconfigured` signal to find out in what style
        /// the toolbar is displayed and change themselves accordingly
        /// 
        /// Possibilities are:
        /// - `GTK_TOOLBAR_BOTH`, meaning the tool item should show
        ///   both an icon and a label, stacked vertically
        /// - `GTK_TOOLBAR_ICONS`, meaning the toolbar shows only icons
        /// - `GTK_TOOLBAR_TEXT`, meaning the tool item should only show text
        /// - `GTK_TOOLBAR_BOTH_HORIZ`, meaning the tool item should show
        ///   both an icon and a label, arranged horizontally
        get {
            let rv = gtk_tool_item_get_toolbar_style(cast(tool_item_ptr))
            return rv
        }
    }

    /// Returns whether `tool_item` has a drag window. See
    /// `gtk_tool_item_set_use_drag_window()`.
    var useDragWindow: Bool {
        /// Returns whether `tool_item` has a drag window. See
        /// `gtk_tool_item_set_use_drag_window()`.
        get {
            let rv = gtk_tool_item_get_use_drag_window(cast(tool_item_ptr))
            return Bool(rv != 0)
        }
        /// Sets whether `tool_item` has a drag window. When `true` the
        /// toolitem can be used as a drag source through `gtk_drag_source_set()`.
        /// When `tool_item` has a drag window it will intercept all events,
        /// even those that would otherwise be sent to a child of `tool_item`.
        nonmutating set {
            gtk_tool_item_set_use_drag_window(cast(tool_item_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Returns whether the `tool_item` is visible on toolbars that are
    /// docked horizontally.
    var visibleHorizontal: Bool {
        /// Returns whether the `tool_item` is visible on toolbars that are
        /// docked horizontally.
        get {
            let rv = gtk_tool_item_get_visible_horizontal(cast(tool_item_ptr))
            return Bool(rv != 0)
        }
        /// Sets whether `tool_item` is visible when the toolbar is docked horizontally.
        nonmutating set {
            gtk_tool_item_set_visible_horizontal(cast(tool_item_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Returns whether `tool_item` is visible when the toolbar is docked vertically.
    /// See `gtk_tool_item_set_visible_vertical()`.
    var visibleVertical: Bool {
        /// Returns whether `tool_item` is visible when the toolbar is docked vertically.
        /// See `gtk_tool_item_set_visible_vertical()`.
        get {
            let rv = gtk_tool_item_get_visible_vertical(cast(tool_item_ptr))
            return Bool(rv != 0)
        }
        /// Sets whether `tool_item` is visible when the toolbar is docked
        /// vertically. Some tool items, such as text entries, are too wide to be
        /// useful on a vertically docked toolbar. If `visible_vertical` is `false`
        /// `tool_item` will not appear on toolbars that are docked vertically.
        nonmutating set {
            gtk_tool_item_set_visible_vertical(cast(tool_item_ptr), gboolean(newValue ? 1 : 0))
        }
    }
}



// MARK: - ToolItemGroup Class

/// The `ToolItemGroupProtocol` protocol exposes the methods and properties of an underlying `GtkToolItemGroup` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ToolItemGroup`.
/// Alternatively, use `ToolItemGroupRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkToolItemGroup` is used together with `GtkToolPalette` to add
/// `GtkToolItems` to a palette like container with different
/// categories and drag and drop support.
/// 
/// # CSS nodes
/// 
/// GtkToolItemGroup has a single CSS node named toolitemgroup.
public protocol ToolItemGroupProtocol: ContainerProtocol, ToolShellProtocol {
    /// Untyped pointer to the underlying `GtkToolItemGroup` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkToolItemGroup` instance.
    var tool_item_group_ptr: UnsafeMutablePointer<GtkToolItemGroup> { get }
}

/// The `ToolItemGroupRef` type acts as a lightweight Swift reference to an underlying `GtkToolItemGroup` instance.
/// It exposes methods that can operate on this data type through `ToolItemGroupProtocol` conformance.
/// Use `ToolItemGroupRef` only as an `unowned` reference to an existing `GtkToolItemGroup` instance.
///
/// A `GtkToolItemGroup` is used together with `GtkToolPalette` to add
/// `GtkToolItems` to a palette like container with different
/// categories and drag and drop support.
/// 
/// # CSS nodes
/// 
/// GtkToolItemGroup has a single CSS node named toolitemgroup.
public struct ToolItemGroupRef: ToolItemGroupProtocol {
    /// Untyped pointer to the underlying `GtkToolItemGroup` instance.
    /// For type-safe access, use the generated, typed pointer `tool_item_group_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension ToolItemGroupRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkToolItemGroup>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `ToolItemGroupProtocol`
    init<T: ToolItemGroupProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemGroupProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemGroupProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemGroupProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemGroupProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemGroupProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new tool item group with label `label`.
    init( label: UnsafePointer<gchar>) {
        let rv = gtk_tool_item_group_new(label)
        self.init(cast(rv))
    }
}

/// The `ToolItemGroup` type acts as a reference-counted owner of an underlying `GtkToolItemGroup` instance.
/// It provides the methods that can operate on this data type through `ToolItemGroupProtocol` conformance.
/// Use `ToolItemGroup` as a strong reference or owner of a `GtkToolItemGroup` instance.
///
/// A `GtkToolItemGroup` is used together with `GtkToolPalette` to add
/// `GtkToolItems` to a palette like container with different
/// categories and drag and drop support.
/// 
/// # CSS nodes
/// 
/// GtkToolItemGroup has a single CSS node named toolitemgroup.
open class ToolItemGroup: Container, ToolItemGroupProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `ToolItemGroup` instance.
    public init(_ op: UnsafeMutablePointer<GtkToolItemGroup>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `ToolItemGroupProtocol`
    /// Will retain `GtkToolItemGroup`.
    public convenience init<T: ToolItemGroupProtocol>(_ other: T) {
        self.init(cast(other.tool_item_group_ptr))
        g_object_ref(cast(tool_item_group_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemGroupProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkToolItemGroup.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemGroupProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkToolItemGroup.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemGroupProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkToolItemGroup.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemGroupProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkToolItemGroup>(opaquePointer))
    }

    /// Creates a new tool item group with label `label`.
    public convenience init( label: UnsafePointer<gchar>) {
        let rv = gtk_tool_item_group_new(label)
        self.init(cast(rv))
    }


}

public enum ToolItemGroupPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case appPaintable = "app-paintable"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case collapsed = "collapsed"
    case compositeChild = "composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case ellipsize = "ellipsize"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case headerRelief = "header-relief"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    case isFocus = "is-focus"
    case label = "label"
    case labelWidget = "label-widget"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case resizeMode = "resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
}

public extension ToolItemGroupProtocol {
    /// Bind a `ToolItemGroupPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ToolItemGroupPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(tool_item_group_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum ToolItemGroupSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    case add = "add"
    /// The `button`-press-event signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button`-release-event signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child`-notify signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The `composited`-changed signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure`-event signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete`-event signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy`-event signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag`-begin signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag`-data-delete signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag`-data-get signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag`-data-received signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag`-drop signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag`-drop signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag`-data-received handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag`-end signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag`-begin.
    case dragEnd = "drag-end"
    /// The `drag`-failed signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag`-leave signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag`-motion, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag`-leave signal is also emitted before the
    /// `drag`-drop signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag`-motion signal handler.
    case dragLeave = "drag-leave"
    /// The `drag`-motion signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag`-data-received
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag`-leave and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enter`-notify-event will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key`-press-event) and finally a generic
    /// `GtkWidget::event`-after signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event`-after will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `focus`-in-event signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus`-out-event signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab`-notify signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy`-changed signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key`-press-event signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key`-release-event signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `leave`-notify-event will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map`-event will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map`-event signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion`-notify-event signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent`-set signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The `property`-notify-event signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// The `screen`-changed signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll`-event signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `selection`-clear-event signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection`-request-event signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-changed signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style`-set signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style`-updated signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style`-updated signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap`-event signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility`-notify-event will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    /// The `window`-state-event will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCollapsed = "notify::collapsed"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyEllipsize = "notify::ellipsize"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeaderRelief = "notify::header-relief"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    case notifyIsFocus = "notify::is-focus"
    case notifyLabel = "notify::label"
    case notifyLabelWidget = "notify::label-widget"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizeMode = "notify::resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
}

public extension ToolItemGroupProtocol {
    /// Connect a `ToolItemGroupSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: ToolItemGroupSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(tool_item_group_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension ToolItemGroupProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkToolItemGroup` instance.
    var tool_item_group_ptr: UnsafeMutablePointer<GtkToolItemGroup> { return ptr.assumingMemoryBound(to: GtkToolItemGroup.self) }

    /// Gets whether `group` is collapsed or expanded.
    func getCollapsed() -> Bool {
        let rv = gtk_tool_item_group_get_collapsed(cast(tool_item_group_ptr))
        return Bool(rv != 0)
    }

    /// Gets the tool item at position (x, y).
    func getDropItem(x: CInt, y: CInt) -> UnsafeMutablePointer<GtkToolItem>! {
        let rv = gtk_tool_item_group_get_drop_item(cast(tool_item_group_ptr), gint(x), gint(y))
        return cast(rv)
    }

    /// Gets the ellipsization mode of `group`.
    func getEllipsize() -> PangoEllipsizeMode {
        let rv = gtk_tool_item_group_get_ellipsize(cast(tool_item_group_ptr))
        return rv
    }

    /// Gets the relief mode of the header button of `group`.
    func getHeaderRelief() -> GtkReliefStyle {
        let rv = gtk_tool_item_group_get_header_relief(cast(tool_item_group_ptr))
        return rv
    }

    /// Gets the position of `item` in `group` as index.
    func getItemPosition(item: ToolItemProtocol) -> CInt {
        let rv = gtk_tool_item_group_get_item_position(cast(tool_item_group_ptr), cast(item.ptr))
        return CInt(rv)
    }

    /// Gets the label of `group`.
    func getLabel() -> String! {
        let rv = gtk_tool_item_group_get_label(cast(tool_item_group_ptr))
        return rv.map { String(cString: UnsafePointer<CChar>($0)) }
    }

    /// Gets the label widget of `group`.
    /// See `gtk_tool_item_group_set_label_widget()`.
    func getLabelWidget() -> UnsafeMutablePointer<GtkWidget>! {
        let rv = gtk_tool_item_group_get_label_widget(cast(tool_item_group_ptr))
        return cast(rv)
    }

    /// Gets the number of tool items in `group`.
    func getNItems() -> CUnsignedInt {
        let rv = gtk_tool_item_group_get_n_items(cast(tool_item_group_ptr))
        return CUnsignedInt(rv)
    }

    /// Gets the tool item at `index` in group.
    func getNthItem(index: CUnsignedInt) -> UnsafeMutablePointer<GtkToolItem>! {
        let rv = gtk_tool_item_group_get_nth_item(cast(tool_item_group_ptr), guint(index))
        return cast(rv)
    }

    /// Inserts `item` at `position` in the list of children of `group`.
    func insert(item: ToolItemProtocol, position: CInt) {
        gtk_tool_item_group_insert(cast(tool_item_group_ptr), cast(item.ptr), gint(position))
    
    }

    /// Sets whether the `group` should be collapsed or expanded.
    func set(collapsed: Bool) {
        gtk_tool_item_group_set_collapsed(cast(tool_item_group_ptr), gboolean(collapsed ? 1 : 0))
    
    }

    /// Sets the ellipsization mode which should be used by labels in `group`.
    func set(ellipsize: Pango.EllipsizeMode) {
        gtk_tool_item_group_set_ellipsize(cast(tool_item_group_ptr), ellipsize)
    
    }

    /// Set the button relief of the group header.
    /// See `gtk_button_set_relief()` for details.
    func setHeaderRelief(style: ReliefStyle) {
        gtk_tool_item_group_set_header_relief(cast(tool_item_group_ptr), style)
    
    }

    /// Sets the position of `item` in the list of children of `group`.
    func setItemPosition(item: ToolItemProtocol, position: CInt) {
        gtk_tool_item_group_set_item_position(cast(tool_item_group_ptr), cast(item.ptr), gint(position))
    
    }

    /// Sets the label of the tool item group. The label is displayed in the header
    /// of the group.
    func set(label: UnsafePointer<gchar>) {
        gtk_tool_item_group_set_label(cast(tool_item_group_ptr), label)
    
    }

    /// Sets the label of the tool item group.
    /// The label widget is displayed in the header of the group, in place
    /// of the usual label.
    func set(labelWidget label_widget: WidgetProtocol) {
        gtk_tool_item_group_set_label_widget(cast(tool_item_group_ptr), cast(label_widget.ptr))
    
    }
    var collapsed: Bool {
        /// Gets whether `group` is collapsed or expanded.
        get {
            let rv = gtk_tool_item_group_get_collapsed(cast(tool_item_group_ptr))
            return Bool(rv != 0)
        }
        /// Sets whether the `group` should be collapsed or expanded.
        nonmutating set {
            gtk_tool_item_group_set_collapsed(cast(tool_item_group_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    var ellipsize: PangoEllipsizeMode {
        /// Gets the ellipsization mode of `group`.
        get {
            let rv = gtk_tool_item_group_get_ellipsize(cast(tool_item_group_ptr))
            return rv
        }
        /// Sets the ellipsization mode which should be used by labels in `group`.
        nonmutating set {
            gtk_tool_item_group_set_ellipsize(cast(tool_item_group_ptr), newValue)
        }
    }

    /// Gets the relief mode of the header button of `group`.
    var headerRelief: GtkReliefStyle {
        /// Gets the relief mode of the header button of `group`.
        get {
            let rv = gtk_tool_item_group_get_header_relief(cast(tool_item_group_ptr))
            return rv
        }
        /// Set the button relief of the group header.
        /// See `gtk_button_set_relief()` for details.
        nonmutating set {
            gtk_tool_item_group_set_header_relief(cast(tool_item_group_ptr), newValue)
        }
    }

    var label: String! {
        /// Gets the label of `group`.
        get {
            let rv = gtk_tool_item_group_get_label(cast(tool_item_group_ptr))
            return rv.map { String(cString: UnsafePointer<CChar>($0)) }
        }
        /// Sets the label of the tool item group. The label is displayed in the header
        /// of the group.
        nonmutating set {
            gtk_tool_item_group_set_label(cast(tool_item_group_ptr), newValue)
        }
    }

    /// Gets the label widget of `group`.
    /// See `gtk_tool_item_group_set_label_widget()`.
    var labelWidget: UnsafeMutablePointer<GtkWidget>! {
        /// Gets the label widget of `group`.
        /// See `gtk_tool_item_group_set_label_widget()`.
        get {
            let rv = gtk_tool_item_group_get_label_widget(cast(tool_item_group_ptr))
            return cast(rv)
        }
        /// Sets the label of the tool item group.
        /// The label widget is displayed in the header of the group, in place
        /// of the usual label.
        nonmutating set {
            gtk_tool_item_group_set_label_widget(cast(tool_item_group_ptr), cast(newValue))
        }
    }

    /// Gets the number of tool items in `group`.
    var nItems: CUnsignedInt {
        /// Gets the number of tool items in `group`.
        get {
            let rv = gtk_tool_item_group_get_n_items(cast(tool_item_group_ptr))
            return CUnsignedInt(rv)
        }
    }
}



// MARK: - ToolPalette Class

/// The `ToolPaletteProtocol` protocol exposes the methods and properties of an underlying `GtkToolPalette` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ToolPalette`.
/// Alternatively, use `ToolPaletteRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkToolPalette` allows you to add `GtkToolItems` to a palette-like
/// container with different categories and drag and drop support.
/// 
/// A `GtkToolPalette` is created with a call to `gtk_tool_palette_new()`.
/// 
/// `GtkToolItems` cannot be added directly to a `GtkToolPalette` -
/// instead they are added to a `GtkToolItemGroup` which can than be added
/// to a `GtkToolPalette`. To add a `GtkToolItemGroup` to a `GtkToolPalette`,
/// use `gtk_container_add()`.
/// 
/// (C Language Example):
/// ```C
/// GtkWidget *palette, *group;
/// GtkToolItem *item;
/// 
/// palette = gtk_tool_palette_new ();
/// group = gtk_tool_item_group_new (_("Test Category"));
/// gtk_container_add (GTK_CONTAINER (palette), group);
/// 
/// item = gtk_tool_button_new (NULL, _("_Open"));
/// gtk_tool_button_set_icon_name (GTK_TOOL_BUTTON (item), "document-open");
/// gtk_tool_item_group_insert (GTK_TOOL_ITEM_GROUP (group), item, -1);
/// ```
/// 
/// The easiest way to use drag and drop with `GtkToolPalette` is to call
/// `gtk_tool_palette_add_drag_dest()` with the desired drag source `palette`
/// and the desired drag target `widget`. Then `gtk_tool_palette_get_drag_item()`
/// can be used to get the dragged item in the `GtkWidget::drag`-data-received
/// signal handler of the drag target.
/// 
/// (C Language Example):
/// ```C
/// static void
/// passive_canvas_drag_data_received (GtkWidget        *widget,
///                                    GdkDragContext   *context,
///                                    gint              x,
///                                    gint              y,
///                                    GtkSelectionData *selection,
///                                    guint             info,
///                                    guint             time,
///                                    gpointer          data)
/// {
///   GtkWidget *palette;
///   GtkWidget *item;
/// 
///   // Get the dragged item
///   palette = gtk_widget_get_ancestor (gtk_drag_get_source_widget (context),
///                                      GTK_TYPE_TOOL_PALETTE);
///   if (palette != NULL)
///     item = gtk_tool_palette_get_drag_item (GTK_TOOL_PALETTE (palette),
///                                            selection);
/// 
///   // Do something with item
/// }
/// 
/// GtkWidget *target, palette;
/// 
/// palette = gtk_tool_palette_new ();
/// target = gtk_drawing_area_new ();
/// 
/// g_signal_connect (G_OBJECT (target), "drag-data-received",
///                   G_CALLBACK (passive_canvas_drag_data_received), NULL);
/// gtk_tool_palette_add_drag_dest (GTK_TOOL_PALETTE (palette), target,
///                                 GTK_DEST_DEFAULT_ALL,
///                                 GTK_TOOL_PALETTE_DRAG_ITEMS,
///                                 GDK_ACTION_COPY);
/// ```
/// 
/// # CSS nodes
/// 
/// GtkToolPalette has a single CSS node named toolpalette.
public protocol ToolPaletteProtocol: ContainerProtocol, OrientableProtocol, ScrollableProtocol {
    /// Untyped pointer to the underlying `GtkToolPalette` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkToolPalette` instance.
    var tool_palette_ptr: UnsafeMutablePointer<GtkToolPalette> { get }
}

/// The `ToolPaletteRef` type acts as a lightweight Swift reference to an underlying `GtkToolPalette` instance.
/// It exposes methods that can operate on this data type through `ToolPaletteProtocol` conformance.
/// Use `ToolPaletteRef` only as an `unowned` reference to an existing `GtkToolPalette` instance.
///
/// A `GtkToolPalette` allows you to add `GtkToolItems` to a palette-like
/// container with different categories and drag and drop support.
/// 
/// A `GtkToolPalette` is created with a call to `gtk_tool_palette_new()`.
/// 
/// `GtkToolItems` cannot be added directly to a `GtkToolPalette` -
/// instead they are added to a `GtkToolItemGroup` which can than be added
/// to a `GtkToolPalette`. To add a `GtkToolItemGroup` to a `GtkToolPalette`,
/// use `gtk_container_add()`.
/// 
/// (C Language Example):
/// ```C
/// GtkWidget *palette, *group;
/// GtkToolItem *item;
/// 
/// palette = gtk_tool_palette_new ();
/// group = gtk_tool_item_group_new (_("Test Category"));
/// gtk_container_add (GTK_CONTAINER (palette), group);
/// 
/// item = gtk_tool_button_new (NULL, _("_Open"));
/// gtk_tool_button_set_icon_name (GTK_TOOL_BUTTON (item), "document-open");
/// gtk_tool_item_group_insert (GTK_TOOL_ITEM_GROUP (group), item, -1);
/// ```
/// 
/// The easiest way to use drag and drop with `GtkToolPalette` is to call
/// `gtk_tool_palette_add_drag_dest()` with the desired drag source `palette`
/// and the desired drag target `widget`. Then `gtk_tool_palette_get_drag_item()`
/// can be used to get the dragged item in the `GtkWidget::drag`-data-received
/// signal handler of the drag target.
/// 
/// (C Language Example):
/// ```C
/// static void
/// passive_canvas_drag_data_received (GtkWidget        *widget,
///                                    GdkDragContext   *context,
///                                    gint              x,
///                                    gint              y,
///                                    GtkSelectionData *selection,
///                                    guint             info,
///                                    guint             time,
///                                    gpointer          data)
/// {
///   GtkWidget *palette;
///   GtkWidget *item;
/// 
///   // Get the dragged item
///   palette = gtk_widget_get_ancestor (gtk_drag_get_source_widget (context),
///                                      GTK_TYPE_TOOL_PALETTE);
///   if (palette != NULL)
///     item = gtk_tool_palette_get_drag_item (GTK_TOOL_PALETTE (palette),
///                                            selection);
/// 
///   // Do something with item
/// }
/// 
/// GtkWidget *target, palette;
/// 
/// palette = gtk_tool_palette_new ();
/// target = gtk_drawing_area_new ();
/// 
/// g_signal_connect (G_OBJECT (target), "drag-data-received",
///                   G_CALLBACK (passive_canvas_drag_data_received), NULL);
/// gtk_tool_palette_add_drag_dest (GTK_TOOL_PALETTE (palette), target,
///                                 GTK_DEST_DEFAULT_ALL,
///                                 GTK_TOOL_PALETTE_DRAG_ITEMS,
///                                 GDK_ACTION_COPY);
/// ```
/// 
/// # CSS nodes
/// 
/// GtkToolPalette has a single CSS node named toolpalette.
public struct ToolPaletteRef: ToolPaletteProtocol {
    /// Untyped pointer to the underlying `GtkToolPalette` instance.
    /// For type-safe access, use the generated, typed pointer `tool_palette_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension ToolPaletteRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkToolPalette>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `ToolPaletteProtocol`
    init<T: ToolPaletteProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolPaletteProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolPaletteProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolPaletteProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolPaletteProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolPaletteProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new tool palette.
    init() {
        let rv = gtk_tool_palette_new()
        self.init(cast(rv))
    }
}

/// The `ToolPalette` type acts as a reference-counted owner of an underlying `GtkToolPalette` instance.
/// It provides the methods that can operate on this data type through `ToolPaletteProtocol` conformance.
/// Use `ToolPalette` as a strong reference or owner of a `GtkToolPalette` instance.
///
/// A `GtkToolPalette` allows you to add `GtkToolItems` to a palette-like
/// container with different categories and drag and drop support.
/// 
/// A `GtkToolPalette` is created with a call to `gtk_tool_palette_new()`.
/// 
/// `GtkToolItems` cannot be added directly to a `GtkToolPalette` -
/// instead they are added to a `GtkToolItemGroup` which can than be added
/// to a `GtkToolPalette`. To add a `GtkToolItemGroup` to a `GtkToolPalette`,
/// use `gtk_container_add()`.
/// 
/// (C Language Example):
/// ```C
/// GtkWidget *palette, *group;
/// GtkToolItem *item;
/// 
/// palette = gtk_tool_palette_new ();
/// group = gtk_tool_item_group_new (_("Test Category"));
/// gtk_container_add (GTK_CONTAINER (palette), group);
/// 
/// item = gtk_tool_button_new (NULL, _("_Open"));
/// gtk_tool_button_set_icon_name (GTK_TOOL_BUTTON (item), "document-open");
/// gtk_tool_item_group_insert (GTK_TOOL_ITEM_GROUP (group), item, -1);
/// ```
/// 
/// The easiest way to use drag and drop with `GtkToolPalette` is to call
/// `gtk_tool_palette_add_drag_dest()` with the desired drag source `palette`
/// and the desired drag target `widget`. Then `gtk_tool_palette_get_drag_item()`
/// can be used to get the dragged item in the `GtkWidget::drag`-data-received
/// signal handler of the drag target.
/// 
/// (C Language Example):
/// ```C
/// static void
/// passive_canvas_drag_data_received (GtkWidget        *widget,
///                                    GdkDragContext   *context,
///                                    gint              x,
///                                    gint              y,
///                                    GtkSelectionData *selection,
///                                    guint             info,
///                                    guint             time,
///                                    gpointer          data)
/// {
///   GtkWidget *palette;
///   GtkWidget *item;
/// 
///   // Get the dragged item
///   palette = gtk_widget_get_ancestor (gtk_drag_get_source_widget (context),
///                                      GTK_TYPE_TOOL_PALETTE);
///   if (palette != NULL)
///     item = gtk_tool_palette_get_drag_item (GTK_TOOL_PALETTE (palette),
///                                            selection);
/// 
///   // Do something with item
/// }
/// 
/// GtkWidget *target, palette;
/// 
/// palette = gtk_tool_palette_new ();
/// target = gtk_drawing_area_new ();
/// 
/// g_signal_connect (G_OBJECT (target), "drag-data-received",
///                   G_CALLBACK (passive_canvas_drag_data_received), NULL);
/// gtk_tool_palette_add_drag_dest (GTK_TOOL_PALETTE (palette), target,
///                                 GTK_DEST_DEFAULT_ALL,
///                                 GTK_TOOL_PALETTE_DRAG_ITEMS,
///                                 GDK_ACTION_COPY);
/// ```
/// 
/// # CSS nodes
/// 
/// GtkToolPalette has a single CSS node named toolpalette.
open class ToolPalette: Container, ToolPaletteProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `ToolPalette` instance.
    public init(_ op: UnsafeMutablePointer<GtkToolPalette>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `ToolPaletteProtocol`
    /// Will retain `GtkToolPalette`.
    public convenience init<T: ToolPaletteProtocol>(_ other: T) {
        self.init(cast(other.tool_palette_ptr))
        g_object_ref(cast(tool_palette_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolPaletteProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkToolPalette.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolPaletteProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkToolPalette.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolPaletteProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkToolPalette.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolPaletteProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkToolPalette>(opaquePointer))
    }

    /// Creates a new tool palette.
    public convenience init() {
        let rv = gtk_tool_palette_new()
        self.init(cast(rv))
    }


}

public enum ToolPalettePropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case appPaintable = "app-paintable"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case compositeChild = "composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The size of the icons in a tool palette. When this property is set,
    /// it overrides the default setting.
    /// 
    /// This should only be used for special-purpose tool palettes, normal
    /// application tool palettes should respect the user preferences for the
    /// size of icons.
    case iconSize = "icon-size"
    /// Is `true` if the `GtkToolPalette:icon`-size property has been set.
    case iconSizeSet = "icon-size-set"
    case isFocus = "is-focus"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case resizeMode = "resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    /// The style of items in the tool palette.
    case toolbarStyle = "toolbar-style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
}

public extension ToolPaletteProtocol {
    /// Bind a `ToolPalettePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ToolPalettePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(tool_palette_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum ToolPaletteSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    case add = "add"
    /// The `button`-press-event signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button`-release-event signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child`-notify signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The `composited`-changed signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure`-event signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete`-event signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy`-event signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag`-begin signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag`-data-delete signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag`-data-get signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag`-data-received signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag`-drop signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag`-drop signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag`-data-received handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag`-end signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag`-begin.
    case dragEnd = "drag-end"
    /// The `drag`-failed signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag`-leave signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag`-motion, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag`-leave signal is also emitted before the
    /// `drag`-drop signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag`-motion signal handler.
    case dragLeave = "drag-leave"
    /// The `drag`-motion signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag`-data-received
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag`-leave and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enter`-notify-event will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key`-press-event) and finally a generic
    /// `GtkWidget::event`-after signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event`-after will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `focus`-in-event signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus`-out-event signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab`-notify signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy`-changed signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key`-press-event signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key`-release-event signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `leave`-notify-event will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map`-event will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map`-event signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion`-notify-event signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent`-set signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The `property`-notify-event signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// The `screen`-changed signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll`-event signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `selection`-clear-event signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection`-request-event signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-changed signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style`-set signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style`-updated signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style`-updated signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap`-event signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility`-notify-event will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    /// The `window`-state-event will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The size of the icons in a tool palette. When this property is set,
    /// it overrides the default setting.
    /// 
    /// This should only be used for special-purpose tool palettes, normal
    /// application tool palettes should respect the user preferences for the
    /// size of icons.
    case notifyIconSize = "notify::icon-size"
    /// Is `true` if the `GtkToolPalette:icon`-size property has been set.
    case notifyIconSizeSet = "notify::icon-size-set"
    case notifyIsFocus = "notify::is-focus"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizeMode = "notify::resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    /// The style of items in the tool palette.
    case notifyToolbarStyle = "notify::toolbar-style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
}

public extension ToolPaletteProtocol {
    /// Connect a `ToolPaletteSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: ToolPaletteSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(tool_palette_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension ToolPaletteProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkToolPalette` instance.
    var tool_palette_ptr: UnsafeMutablePointer<GtkToolPalette> { return ptr.assumingMemoryBound(to: GtkToolPalette.self) }

    /// Sets `palette` as drag source (see `gtk_tool_palette_set_drag_source()`)
    /// and sets `widget` as a drag destination for drags from `palette`.
    /// See `gtk_drag_dest_set()`.
    func addDragDest(widget: WidgetProtocol, flags: DestDefaults, targets: ToolPaletteDragTargets, actions: Gdk.DragAction) {
        gtk_tool_palette_add_drag_dest(cast(tool_palette_ptr), cast(widget.ptr), flags, targets, actions)
    
    }

    /// Get the dragged item from the selection.
    /// This could be a `GtkToolItem` or a `GtkToolItemGroup`.
    func getDragItem(selection: SelectionDataProtocol) -> UnsafeMutablePointer<GtkWidget>! {
        let rv = gtk_tool_palette_get_drag_item(cast(tool_palette_ptr), cast(selection.ptr))
        return cast(rv)
    }

    /// Gets the group at position (x, y).
    func getDropGroup(x: CInt, y: CInt) -> UnsafeMutablePointer<GtkToolItemGroup>! {
        let rv = gtk_tool_palette_get_drop_group(cast(tool_palette_ptr), gint(x), gint(y))
        return cast(rv)
    }

    /// Gets the item at position (x, y).
    /// See `gtk_tool_palette_get_drop_group()`.
    func getDropItem(x: CInt, y: CInt) -> UnsafeMutablePointer<GtkToolItem>! {
        let rv = gtk_tool_palette_get_drop_item(cast(tool_palette_ptr), gint(x), gint(y))
        return cast(rv)
    }

    /// Gets whether `group` is exclusive or not.
    /// See `gtk_tool_palette_set_exclusive()`.
    func getExclusive(group: ToolItemGroupProtocol) -> Bool {
        let rv = gtk_tool_palette_get_exclusive(cast(tool_palette_ptr), cast(group.ptr))
        return Bool(rv != 0)
    }

    /// Gets whether group should be given extra space.
    /// See `gtk_tool_palette_set_expand()`.
    func getExpand(group: ToolItemGroupProtocol) -> Bool {
        let rv = gtk_tool_palette_get_expand(cast(tool_palette_ptr), cast(group.ptr))
        return Bool(rv != 0)
    }

    /// Gets the position of `group` in `palette` as index.
    /// See `gtk_tool_palette_set_group_position()`.
    func getGroupPosition(group: ToolItemGroupProtocol) -> CInt {
        let rv = gtk_tool_palette_get_group_position(cast(tool_palette_ptr), cast(group.ptr))
        return CInt(rv)
    }

    /// Gets the horizontal adjustment of the tool palette.
    ///
    /// **get_hadjustment is deprecated:**
    /// Use gtk_scrollable_get_hadjustment()
    @available(*, deprecated) func getHadjustment() -> UnsafeMutablePointer<GtkAdjustment>! {
        let rv = gtk_tool_palette_get_hadjustment(cast(tool_palette_ptr))
        return cast(rv)
    }

    /// Gets the size of icons in the tool palette.
    /// See `gtk_tool_palette_set_icon_size()`.
    func getIconSize() -> GtkIconSize {
        let rv = gtk_tool_palette_get_icon_size(cast(tool_palette_ptr))
        return rv
    }

    /// Gets the style (icons, text or both) of items in the tool palette.
    func getStyle() -> GtkToolbarStyle {
        let rv = gtk_tool_palette_get_style(cast(tool_palette_ptr))
        return rv
    }

    /// Gets the vertical adjustment of the tool palette.
    ///
    /// **get_vadjustment is deprecated:**
    /// Use gtk_scrollable_get_vadjustment()
    @available(*, deprecated) func getVadjustment() -> UnsafeMutablePointer<GtkAdjustment>! {
        let rv = gtk_tool_palette_get_vadjustment(cast(tool_palette_ptr))
        return cast(rv)
    }

    /// Sets the tool palette as a drag source.
    /// Enables all groups and items in the tool palette as drag sources
    /// on button 1 and button 3 press with copy and move actions.
    /// See `gtk_drag_source_set()`.
    func setDragSource(targets: ToolPaletteDragTargets) {
        gtk_tool_palette_set_drag_source(cast(tool_palette_ptr), targets)
    
    }

    /// Sets whether the group should be exclusive or not.
    /// If an exclusive group is expanded all other groups are collapsed.
    func setExclusive(group: ToolItemGroupProtocol, exclusive: Bool) {
        gtk_tool_palette_set_exclusive(cast(tool_palette_ptr), cast(group.ptr), gboolean(exclusive ? 1 : 0))
    
    }

    /// Sets whether the group should be given extra space.
    func setExpand(group: ToolItemGroupProtocol, expand: Bool) {
        gtk_tool_palette_set_expand(cast(tool_palette_ptr), cast(group.ptr), gboolean(expand ? 1 : 0))
    
    }

    /// Sets the position of the group as an index of the tool palette.
    /// If position is 0 the group will become the first child, if position is
    /// -1 it will become the last child.
    func setGroupPosition(group: ToolItemGroupProtocol, position: CInt) {
        gtk_tool_palette_set_group_position(cast(tool_palette_ptr), cast(group.ptr), gint(position))
    
    }

    /// Sets the size of icons in the tool palette.
    func set(iconSize icon_size: GtkIconSize) {
        gtk_tool_palette_set_icon_size(cast(tool_palette_ptr), icon_size)
    
    }

    /// Sets the style (text, icons or both) of items in the tool palette.
    func set(style: ToolbarStyle) {
        gtk_tool_palette_set_style(cast(tool_palette_ptr), style)
    
    }

    /// Unsets the tool palette icon size set with `gtk_tool_palette_set_icon_size()`,
    /// so that user preferences will be used to determine the icon size.
    func unsetIconSize() {
        gtk_tool_palette_unset_icon_size(cast(tool_palette_ptr))
    
    }

    /// Unsets a toolbar style set with `gtk_tool_palette_set_style()`,
    /// so that user preferences will be used to determine the toolbar style.
    func unsetStyle() {
        gtk_tool_palette_unset_style(cast(tool_palette_ptr))
    
    }
    /// Gets the horizontal adjustment of the tool palette.
    ///
    /// **get_hadjustment is deprecated:**
    /// Use gtk_scrollable_get_hadjustment()
    var hadjustment: UnsafeMutablePointer<GtkAdjustment>! {
        /// Gets the horizontal adjustment of the tool palette.
        ///
        /// **get_hadjustment is deprecated:**
        /// Use gtk_scrollable_get_hadjustment()
        @available(*, deprecated) get {
            let rv = gtk_tool_palette_get_hadjustment(cast(tool_palette_ptr))
            return cast(rv)
        }
    }

    /// Gets the size of icons in the tool palette.
    /// See `gtk_tool_palette_set_icon_size()`.
    var iconSize: GtkIconSize {
        /// Gets the size of icons in the tool palette.
        /// See `gtk_tool_palette_set_icon_size()`.
        get {
            let rv = gtk_tool_palette_get_icon_size(cast(tool_palette_ptr))
            return rv
        }
        /// Sets the size of icons in the tool palette.
        nonmutating set {
            gtk_tool_palette_set_icon_size(cast(tool_palette_ptr), newValue)
        }
    }

    /// Gets the style (icons, text or both) of items in the tool palette.
    var style: GtkToolbarStyle {
        /// Gets the style (icons, text or both) of items in the tool palette.
        get {
            let rv = gtk_tool_palette_get_style(cast(tool_palette_ptr))
            return rv
        }
        /// Sets the style (text, icons or both) of items in the tool palette.
        nonmutating set {
            gtk_tool_palette_set_style(cast(tool_palette_ptr), newValue)
        }
    }

    /// Gets the vertical adjustment of the tool palette.
    ///
    /// **get_vadjustment is deprecated:**
    /// Use gtk_scrollable_get_vadjustment()
    var vadjustment: UnsafeMutablePointer<GtkAdjustment>! {
        /// Gets the vertical adjustment of the tool palette.
        ///
        /// **get_vadjustment is deprecated:**
        /// Use gtk_scrollable_get_vadjustment()
        @available(*, deprecated) get {
            let rv = gtk_tool_palette_get_vadjustment(cast(tool_palette_ptr))
            return cast(rv)
        }
    }
}



// MARK: - Toolbar Class

/// The `ToolbarProtocol` protocol exposes the methods and properties of an underlying `GtkToolbar` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Toolbar`.
/// Alternatively, use `ToolbarRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A toolbar is created with a call to `gtk_toolbar_new()`.
/// 
/// A toolbar can contain instances of a subclass of `GtkToolItem`. To add
/// a `GtkToolItem` to the a toolbar, use `gtk_toolbar_insert()`. To remove
/// an item from the toolbar use `gtk_container_remove()`. To add a button
/// to the toolbar, add an instance of `GtkToolButton`.
/// 
/// Toolbar items can be visually grouped by adding instances of
/// `GtkSeparatorToolItem` to the toolbar. If the GtkToolbar child property
/// “expand” is `TRUE` and the property `GtkSeparatorToolItem:draw` is set to
/// `FALSE`, the effect is to force all following items to the end of the toolbar.
/// 
/// By default, a toolbar can be shrunk, upon which it will add an arrow button
/// to show an overflow menu offering access to any `GtkToolItem` child that has
/// a proxy menu item. To disable this and request enough size for all children,
/// call `gtk_toolbar_set_show_arrow()` to set `GtkToolbar:show`-arrow to `false`.
/// 
/// Creating a context menu for the toolbar can be done by connecting to
/// the `GtkToolbar::popup`-context-menu signal.
/// 
/// # CSS nodes
/// 
/// GtkToolbar has a single CSS node with name toolbar.
public protocol ToolbarProtocol: ContainerProtocol, OrientableProtocol, ToolShellProtocol {
    /// Untyped pointer to the underlying `GtkToolbar` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkToolbar` instance.
    var toolbar_ptr: UnsafeMutablePointer<GtkToolbar> { get }
}

/// The `ToolbarRef` type acts as a lightweight Swift reference to an underlying `GtkToolbar` instance.
/// It exposes methods that can operate on this data type through `ToolbarProtocol` conformance.
/// Use `ToolbarRef` only as an `unowned` reference to an existing `GtkToolbar` instance.
///
/// A toolbar is created with a call to `gtk_toolbar_new()`.
/// 
/// A toolbar can contain instances of a subclass of `GtkToolItem`. To add
/// a `GtkToolItem` to the a toolbar, use `gtk_toolbar_insert()`. To remove
/// an item from the toolbar use `gtk_container_remove()`. To add a button
/// to the toolbar, add an instance of `GtkToolButton`.
/// 
/// Toolbar items can be visually grouped by adding instances of
/// `GtkSeparatorToolItem` to the toolbar. If the GtkToolbar child property
/// “expand” is `TRUE` and the property `GtkSeparatorToolItem:draw` is set to
/// `FALSE`, the effect is to force all following items to the end of the toolbar.
/// 
/// By default, a toolbar can be shrunk, upon which it will add an arrow button
/// to show an overflow menu offering access to any `GtkToolItem` child that has
/// a proxy menu item. To disable this and request enough size for all children,
/// call `gtk_toolbar_set_show_arrow()` to set `GtkToolbar:show`-arrow to `false`.
/// 
/// Creating a context menu for the toolbar can be done by connecting to
/// the `GtkToolbar::popup`-context-menu signal.
/// 
/// # CSS nodes
/// 
/// GtkToolbar has a single CSS node with name toolbar.
public struct ToolbarRef: ToolbarProtocol {
    /// Untyped pointer to the underlying `GtkToolbar` instance.
    /// For type-safe access, use the generated, typed pointer `toolbar_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension ToolbarRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkToolbar>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `ToolbarProtocol`
    init<T: ToolbarProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolbarProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolbarProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolbarProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolbarProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolbarProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new toolbar.
    init() {
        let rv = gtk_toolbar_new()
        self.init(cast(rv))
    }
}

/// The `Toolbar` type acts as a reference-counted owner of an underlying `GtkToolbar` instance.
/// It provides the methods that can operate on this data type through `ToolbarProtocol` conformance.
/// Use `Toolbar` as a strong reference or owner of a `GtkToolbar` instance.
///
/// A toolbar is created with a call to `gtk_toolbar_new()`.
/// 
/// A toolbar can contain instances of a subclass of `GtkToolItem`. To add
/// a `GtkToolItem` to the a toolbar, use `gtk_toolbar_insert()`. To remove
/// an item from the toolbar use `gtk_container_remove()`. To add a button
/// to the toolbar, add an instance of `GtkToolButton`.
/// 
/// Toolbar items can be visually grouped by adding instances of
/// `GtkSeparatorToolItem` to the toolbar. If the GtkToolbar child property
/// “expand” is `TRUE` and the property `GtkSeparatorToolItem:draw` is set to
/// `FALSE`, the effect is to force all following items to the end of the toolbar.
/// 
/// By default, a toolbar can be shrunk, upon which it will add an arrow button
/// to show an overflow menu offering access to any `GtkToolItem` child that has
/// a proxy menu item. To disable this and request enough size for all children,
/// call `gtk_toolbar_set_show_arrow()` to set `GtkToolbar:show`-arrow to `false`.
/// 
/// Creating a context menu for the toolbar can be done by connecting to
/// the `GtkToolbar::popup`-context-menu signal.
/// 
/// # CSS nodes
/// 
/// GtkToolbar has a single CSS node with name toolbar.
open class Toolbar: Container, ToolbarProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `Toolbar` instance.
    public init(_ op: UnsafeMutablePointer<GtkToolbar>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `ToolbarProtocol`
    /// Will retain `GtkToolbar`.
    public convenience init<T: ToolbarProtocol>(_ other: T) {
        self.init(cast(other.toolbar_ptr))
        g_object_ref(cast(toolbar_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolbarProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkToolbar.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolbarProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkToolbar.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolbarProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkToolbar.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolbarProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkToolbar>(opaquePointer))
    }

    /// Creates a new toolbar.
    public convenience init() {
        let rv = gtk_toolbar_new()
        self.init(cast(rv))
    }


}

public enum ToolbarPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case appPaintable = "app-paintable"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case compositeChild = "composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The size of the icons in a toolbar is normally determined by
    /// the toolbar-icon-size setting. When this property is set, it
    /// overrides the setting.
    /// 
    /// This should only be used for special-purpose toolbars, normal
    /// application toolbars should respect the user preferences for the
    /// size of icons.
    case iconSize = "icon-size"
    /// Is `true` if the icon-size property has been set.
    case iconSizeSet = "icon-size-set"
    case isFocus = "is-focus"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case resizeMode = "resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    case showArrow = "show-arrow"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    case toolbarStyle = "toolbar-style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
}

public extension ToolbarProtocol {
    /// Bind a `ToolbarPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ToolbarPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(toolbar_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum ToolbarSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    case add = "add"
    /// The `button`-press-event signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button`-release-event signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child`-notify signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The `composited`-changed signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure`-event signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete`-event signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy`-event signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag`-begin signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag`-data-delete signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag`-data-get signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag`-data-received signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag`-drop signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag`-drop signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag`-data-received handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag`-end signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag`-begin.
    case dragEnd = "drag-end"
    /// The `drag`-failed signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag`-leave signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag`-motion, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag`-leave signal is also emitted before the
    /// `drag`-drop signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag`-motion signal handler.
    case dragLeave = "drag-leave"
    /// The `drag`-motion signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag`-data-received
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag`-leave and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enter`-notify-event will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key`-press-event) and finally a generic
    /// `GtkWidget::event`-after signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event`-after will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// A keybinding signal used internally by GTK+. This signal can't
    /// be used in application code
    case focusHomeOrEnd = "focus-home-or-end"
    /// The `focus`-in-event signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus`-out-event signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab`-notify signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy`-changed signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key`-press-event signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key`-release-event signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `leave`-notify-event will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map`-event will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map`-event signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion`-notify-event signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the orientation of the toolbar changes.
    case orientationChanged = "orientation-changed"
    /// The `parent`-set signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// Emitted when the user right-clicks the toolbar or uses the
    /// keybinding to display a popup menu.
    /// 
    /// Application developers should handle this signal if they want
    /// to display a context menu on the toolbar. The context-menu should
    /// appear at the coordinates given by `x` and `y`. The mouse button
    /// number is given by the `button` parameter. If the menu was popped
    /// up using the keybaord, `button` is -1.
    case popupContextMenu = "popup-context-menu"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The `property`-notify-event signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// The `screen`-changed signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll`-event signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `selection`-clear-event signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection`-request-event signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-changed signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when the style of the toolbar changes.
    case styleChanged = "style-changed"
    /// The `style`-set signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style`-updated signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style`-updated signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap`-event signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility`-notify-event will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    /// The `window`-state-event will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The size of the icons in a toolbar is normally determined by
    /// the toolbar-icon-size setting. When this property is set, it
    /// overrides the setting.
    /// 
    /// This should only be used for special-purpose toolbars, normal
    /// application toolbars should respect the user preferences for the
    /// size of icons.
    case notifyIconSize = "notify::icon-size"
    /// Is `true` if the icon-size property has been set.
    case notifyIconSizeSet = "notify::icon-size-set"
    case notifyIsFocus = "notify::is-focus"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizeMode = "notify::resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    case notifyShowArrow = "notify::show-arrow"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    case notifyToolbarStyle = "notify::toolbar-style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
}

public extension ToolbarProtocol {
    /// Connect a `ToolbarSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: ToolbarSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(toolbar_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension ToolbarProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkToolbar` instance.
    var toolbar_ptr: UnsafeMutablePointer<GtkToolbar> { return ptr.assumingMemoryBound(to: GtkToolbar.self) }

    /// Returns the position corresponding to the indicated point on
    /// `toolbar`. This is useful when dragging items to the toolbar:
    /// this function returns the position a new item should be
    /// inserted.
    /// 
    /// `x` and `y` are in `toolbar` coordinates.
    func getDropIndex(x: CInt, y: CInt) -> CInt {
        let rv = gtk_toolbar_get_drop_index(cast(toolbar_ptr), gint(x), gint(y))
        return CInt(rv)
    }

    /// Retrieves the icon size for the toolbar. See `gtk_toolbar_set_icon_size()`.
    func getIconSize() -> GtkIconSize {
        let rv = gtk_toolbar_get_icon_size(cast(toolbar_ptr))
        return rv
    }

    /// Returns the position of `item` on the toolbar, starting from 0.
    /// It is an error if `item` is not a child of the toolbar.
    func getItemIndex(item: ToolItemProtocol) -> CInt {
        let rv = gtk_toolbar_get_item_index(cast(toolbar_ptr), cast(item.ptr))
        return CInt(rv)
    }

    /// Returns the number of items on the toolbar.
    func getNItems() -> CInt {
        let rv = gtk_toolbar_get_n_items(cast(toolbar_ptr))
        return CInt(rv)
    }

    /// Returns the `n`'th item on `toolbar`, or `nil` if the
    /// toolbar does not contain an `n`'th item.
    func getNthItem(n: CInt) -> UnsafeMutablePointer<GtkToolItem>! {
        let rv = gtk_toolbar_get_nth_item(cast(toolbar_ptr), gint(n))
        return cast(rv)
    }

    /// Returns the relief style of buttons on `toolbar`. See
    /// `gtk_button_set_relief()`.
    func getReliefStyle() -> GtkReliefStyle {
        let rv = gtk_toolbar_get_relief_style(cast(toolbar_ptr))
        return rv
    }

    /// Returns whether the toolbar has an overflow menu.
    /// See `gtk_toolbar_set_show_arrow()`.
    func getShowArrow() -> Bool {
        let rv = gtk_toolbar_get_show_arrow(cast(toolbar_ptr))
        return Bool(rv != 0)
    }

    /// Retrieves whether the toolbar has text, icons, or both . See
    /// `gtk_toolbar_set_style()`.
    func getStyle() -> GtkToolbarStyle {
        let rv = gtk_toolbar_get_style(cast(toolbar_ptr))
        return rv
    }

    /// Insert a `GtkToolItem` into the toolbar at position `pos`. If `pos` is
    /// 0 the item is prepended to the start of the toolbar. If `pos` is
    /// negative, the item is appended to the end of the toolbar.
    func insert(item: ToolItemProtocol, pos: CInt) {
        gtk_toolbar_insert(cast(toolbar_ptr), cast(item.ptr), gint(pos))
    
    }

    /// Highlights `toolbar` to give an idea of what it would look like
    /// if `item` was added to `toolbar` at the position indicated by `index_`.
    /// If `item` is `nil`, highlighting is turned off. In that case `index_`
    /// is ignored.
    /// 
    /// The `tool_item` passed to this function must not be part of any widget
    /// hierarchy. When an item is set as drop highlight item it can not
    /// added to any widget hierarchy or used as highlight item for another
    /// toolbar.
    func setDropHighlightItem(toolItem tool_item: ToolItemProtocol, index_: CInt) {
        gtk_toolbar_set_drop_highlight_item(cast(toolbar_ptr), cast(tool_item.ptr), gint(index_))
    
    }

    /// This function sets the size of stock icons in the toolbar. You
    /// can call it both before you add the icons and after they’ve been
    /// added. The size you set will override user preferences for the default
    /// icon size.
    /// 
    /// This should only be used for special-purpose toolbars, normal
    /// application toolbars should respect the user preferences for the
    /// size of icons.
    func set(iconSize icon_size: IconSize) {
        gtk_toolbar_set_icon_size(cast(toolbar_ptr), icon_size)
    
    }

    /// Sets whether to show an overflow menu when `toolbar` isn’t allocated enough
    /// size to show all of its items. If `true`, items which can’t fit in `toolbar`,
    /// and which have a proxy menu item set by `gtk_tool_item_set_proxy_menu_item()`
    /// or `GtkToolItem::create`-menu-proxy, will be available in an overflow menu,
    /// which can be opened by an added arrow button. If `false`, `toolbar` will
    /// request enough size to fit all of its child items without any overflow.
    func set(showArrow show_arrow: Bool) {
        gtk_toolbar_set_show_arrow(cast(toolbar_ptr), gboolean(show_arrow ? 1 : 0))
    
    }

    /// Alters the view of `toolbar` to display either icons only, text only, or both.
    func set(style: ToolbarStyle) {
        gtk_toolbar_set_style(cast(toolbar_ptr), style)
    
    }

    /// Unsets toolbar icon size set with `gtk_toolbar_set_icon_size()`, so that
    /// user preferences will be used to determine the icon size.
    func unsetIconSize() {
        gtk_toolbar_unset_icon_size(cast(toolbar_ptr))
    
    }

    /// Unsets a toolbar style set with `gtk_toolbar_set_style()`, so that
    /// user preferences will be used to determine the toolbar style.
    func unsetStyle() {
        gtk_toolbar_unset_style(cast(toolbar_ptr))
    
    }
    /// Retrieves the icon size for the toolbar. See `gtk_toolbar_set_icon_size()`.
    var iconSize: GtkIconSize {
        /// Retrieves the icon size for the toolbar. See `gtk_toolbar_set_icon_size()`.
        get {
            let rv = gtk_toolbar_get_icon_size(cast(toolbar_ptr))
            return rv
        }
        /// This function sets the size of stock icons in the toolbar. You
        /// can call it both before you add the icons and after they’ve been
        /// added. The size you set will override user preferences for the default
        /// icon size.
        /// 
        /// This should only be used for special-purpose toolbars, normal
        /// application toolbars should respect the user preferences for the
        /// size of icons.
        nonmutating set {
            gtk_toolbar_set_icon_size(cast(toolbar_ptr), newValue)
        }
    }

    /// Returns the number of items on the toolbar.
    var nItems: CInt {
        /// Returns the number of items on the toolbar.
        get {
            let rv = gtk_toolbar_get_n_items(cast(toolbar_ptr))
            return CInt(rv)
        }
    }

    /// Returns the relief style of buttons on `toolbar`. See
    /// `gtk_button_set_relief()`.
    var reliefStyle: GtkReliefStyle {
        /// Returns the relief style of buttons on `toolbar`. See
        /// `gtk_button_set_relief()`.
        get {
            let rv = gtk_toolbar_get_relief_style(cast(toolbar_ptr))
            return rv
        }
    }

    /// Returns whether the toolbar has an overflow menu.
    /// See `gtk_toolbar_set_show_arrow()`.
    var showArrow: Bool {
        /// Returns whether the toolbar has an overflow menu.
        /// See `gtk_toolbar_set_show_arrow()`.
        get {
            let rv = gtk_toolbar_get_show_arrow(cast(toolbar_ptr))
            return Bool(rv != 0)
        }
        /// Sets whether to show an overflow menu when `toolbar` isn’t allocated enough
        /// size to show all of its items. If `true`, items which can’t fit in `toolbar`,
        /// and which have a proxy menu item set by `gtk_tool_item_set_proxy_menu_item()`
        /// or `GtkToolItem::create`-menu-proxy, will be available in an overflow menu,
        /// which can be opened by an added arrow button. If `false`, `toolbar` will
        /// request enough size to fit all of its child items without any overflow.
        nonmutating set {
            gtk_toolbar_set_show_arrow(cast(toolbar_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Retrieves whether the toolbar has text, icons, or both . See
    /// `gtk_toolbar_set_style()`.
    var style: GtkToolbarStyle {
        /// Retrieves whether the toolbar has text, icons, or both . See
        /// `gtk_toolbar_set_style()`.
        get {
            let rv = gtk_toolbar_get_style(cast(toolbar_ptr))
            return rv
        }
        /// Alters the view of `toolbar` to display either icons only, text only, or both.
        nonmutating set {
            gtk_toolbar_set_style(cast(toolbar_ptr), newValue)
        }
    }
}



// MARK: - Tooltip Class

/// The `TooltipProtocol` protocol exposes the methods and properties of an underlying `GtkTooltip` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Tooltip`.
/// Alternatively, use `TooltipRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// Basic tooltips can be realized simply by using `gtk_widget_set_tooltip_text()`
/// or `gtk_widget_set_tooltip_markup()` without any explicit tooltip object.
/// 
/// When you need a tooltip with a little more fancy contents, like adding an
/// image, or you want the tooltip to have different contents per `GtkTreeView`
/// row or cell, you will have to do a little more work:
/// 
/// - Set the `GtkWidget:has`-tooltip property to `true`, this will make GTK+
///   monitor the widget for motion and related events which are needed to
///   determine when and where to show a tooltip.
/// 
/// - Connect to the `GtkWidget::query`-tooltip signal.  This signal will be
///   emitted when a tooltip is supposed to be shown. One of the arguments passed
///   to the signal handler is a GtkTooltip object. This is the object that we
///   are about to display as a tooltip, and can be manipulated in your callback
///   using functions like `gtk_tooltip_set_icon()`. There are functions for setting
///   the tooltip’s markup, setting an image from a named icon, or even putting in
///   a custom widget.
/// 
///   Return `true` from your query-tooltip handler. This causes the tooltip to be
///   show. If you return `false`, it will not be shown.
/// 
/// In the probably rare case where you want to have even more control over the
/// tooltip that is about to be shown, you can set your own `GtkWindow` which
/// will be used as tooltip window.  This works as follows:
/// 
/// - Set `GtkWidget:has`-tooltip and connect to `GtkWidget::query`-tooltip as before.
///   Use `gtk_widget_set_tooltip_window()` to set a `GtkWindow` created by you as
///   tooltip window.
/// 
/// - In the `GtkWidget::query`-tooltip callback you can access your window using
///   `gtk_widget_get_tooltip_window()` and manipulate as you wish. The semantics of
///   the return value are exactly as before, return `true` to show the window,
///   `false` to not show it.
public protocol TooltipProtocol: GLibObject.ObjectProtocol {
    /// Untyped pointer to the underlying `GtkTooltip` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkTooltip` instance.
    var tooltip_ptr: UnsafeMutablePointer<GtkTooltip> { get }
}

/// The `TooltipRef` type acts as a lightweight Swift reference to an underlying `GtkTooltip` instance.
/// It exposes methods that can operate on this data type through `TooltipProtocol` conformance.
/// Use `TooltipRef` only as an `unowned` reference to an existing `GtkTooltip` instance.
///
/// Basic tooltips can be realized simply by using `gtk_widget_set_tooltip_text()`
/// or `gtk_widget_set_tooltip_markup()` without any explicit tooltip object.
/// 
/// When you need a tooltip with a little more fancy contents, like adding an
/// image, or you want the tooltip to have different contents per `GtkTreeView`
/// row or cell, you will have to do a little more work:
/// 
/// - Set the `GtkWidget:has`-tooltip property to `true`, this will make GTK+
///   monitor the widget for motion and related events which are needed to
///   determine when and where to show a tooltip.
/// 
/// - Connect to the `GtkWidget::query`-tooltip signal.  This signal will be
///   emitted when a tooltip is supposed to be shown. One of the arguments passed
///   to the signal handler is a GtkTooltip object. This is the object that we
///   are about to display as a tooltip, and can be manipulated in your callback
///   using functions like `gtk_tooltip_set_icon()`. There are functions for setting
///   the tooltip’s markup, setting an image from a named icon, or even putting in
///   a custom widget.
/// 
///   Return `true` from your query-tooltip handler. This causes the tooltip to be
///   show. If you return `false`, it will not be shown.
/// 
/// In the probably rare case where you want to have even more control over the
/// tooltip that is about to be shown, you can set your own `GtkWindow` which
/// will be used as tooltip window.  This works as follows:
/// 
/// - Set `GtkWidget:has`-tooltip and connect to `GtkWidget::query`-tooltip as before.
///   Use `gtk_widget_set_tooltip_window()` to set a `GtkWindow` created by you as
///   tooltip window.
/// 
/// - In the `GtkWidget::query`-tooltip callback you can access your window using
///   `gtk_widget_get_tooltip_window()` and manipulate as you wish. The semantics of
///   the return value are exactly as before, return `true` to show the window,
///   `false` to not show it.
public struct TooltipRef: TooltipProtocol {
    /// Untyped pointer to the underlying `GtkTooltip` instance.
    /// For type-safe access, use the generated, typed pointer `tooltip_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension TooltipRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkTooltip>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `TooltipProtocol`
    init<T: TooltipProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `Tooltip` type acts as a reference-counted owner of an underlying `GtkTooltip` instance.
/// It provides the methods that can operate on this data type through `TooltipProtocol` conformance.
/// Use `Tooltip` as a strong reference or owner of a `GtkTooltip` instance.
///
/// Basic tooltips can be realized simply by using `gtk_widget_set_tooltip_text()`
/// or `gtk_widget_set_tooltip_markup()` without any explicit tooltip object.
/// 
/// When you need a tooltip with a little more fancy contents, like adding an
/// image, or you want the tooltip to have different contents per `GtkTreeView`
/// row or cell, you will have to do a little more work:
/// 
/// - Set the `GtkWidget:has`-tooltip property to `true`, this will make GTK+
///   monitor the widget for motion and related events which are needed to
///   determine when and where to show a tooltip.
/// 
/// - Connect to the `GtkWidget::query`-tooltip signal.  This signal will be
///   emitted when a tooltip is supposed to be shown. One of the arguments passed
///   to the signal handler is a GtkTooltip object. This is the object that we
///   are about to display as a tooltip, and can be manipulated in your callback
///   using functions like `gtk_tooltip_set_icon()`. There are functions for setting
///   the tooltip’s markup, setting an image from a named icon, or even putting in
///   a custom widget.
/// 
///   Return `true` from your query-tooltip handler. This causes the tooltip to be
///   show. If you return `false`, it will not be shown.
/// 
/// In the probably rare case where you want to have even more control over the
/// tooltip that is about to be shown, you can set your own `GtkWindow` which
/// will be used as tooltip window.  This works as follows:
/// 
/// - Set `GtkWidget:has`-tooltip and connect to `GtkWidget::query`-tooltip as before.
///   Use `gtk_widget_set_tooltip_window()` to set a `GtkWindow` created by you as
///   tooltip window.
/// 
/// - In the `GtkWidget::query`-tooltip callback you can access your window using
///   `gtk_widget_get_tooltip_window()` and manipulate as you wish. The semantics of
///   the return value are exactly as before, return `true` to show the window,
///   `false` to not show it.
open class Tooltip: GLibObject.Object, TooltipProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `Tooltip` instance.
    public init(_ op: UnsafeMutablePointer<GtkTooltip>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `TooltipProtocol`
    /// Will retain `GtkTooltip`.
    public convenience init<T: TooltipProtocol>(_ other: T) {
        self.init(cast(other.tooltip_ptr))
        g_object_ref(cast(tooltip_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkTooltip.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkTooltip.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkTooltip.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkTooltip>(opaquePointer))
    }



}

// MARK: - no Tooltip properties

public enum TooltipSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

public extension TooltipProtocol {
    /// Connect a `TooltipSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: TooltipSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(tooltip_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension TooltipProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTooltip` instance.
    var tooltip_ptr: UnsafeMutablePointer<GtkTooltip> { return ptr.assumingMemoryBound(to: GtkTooltip.self) }

    /// Replaces the widget packed into the tooltip with
    /// `custom_widget`. `custom_widget` does not get destroyed when the tooltip goes
    /// away.
    /// By default a box with a `GtkImage` and `GtkLabel` is embedded in
    /// the tooltip, which can be configured using `gtk_tooltip_set_markup()`
    /// and `gtk_tooltip_set_icon()`.
    func setCustom(customWidget custom_widget: WidgetProtocol) {
        gtk_tooltip_set_custom(cast(tooltip_ptr), cast(custom_widget.ptr))
    
    }

    /// Sets the icon of the tooltip (which is in front of the text) to be
    /// `pixbuf`.  If `pixbuf` is `nil`, the image will be hidden.
    func setIcon(pixbuf: PixbufProtocol) {
        gtk_tooltip_set_icon(cast(tooltip_ptr), cast(pixbuf.ptr))
    
    }

    /// Sets the icon of the tooltip (which is in front of the text)
    /// to be the icon indicated by `gicon` with the size indicated
    /// by `size`. If `gicon` is `nil`, the image will be hidden.
    func setIconFrom(gicon: IconProtocol, size: GtkIconSize) {
        gtk_tooltip_set_icon_from_gicon(cast(tooltip_ptr), cast(gicon.ptr), size)
    
    }

    /// Sets the icon of the tooltip (which is in front of the text) to be
    /// the icon indicated by `icon_name` with the size indicated
    /// by `size`.  If `icon_name` is `nil`, the image will be hidden.
    func setIconFrom(iconName icon_name: UnsafePointer<gchar>, size: GtkIconSize) {
        gtk_tooltip_set_icon_from_icon_name(cast(tooltip_ptr), icon_name, size)
    
    }

    /// Sets the icon of the tooltip (which is in front of the text) to be
    /// the stock item indicated by `stock_id` with the size indicated
    /// by `size`.  If `stock_id` is `nil`, the image will be hidden.
    ///
    /// **set_icon_from_stock is deprecated:**
    /// Use gtk_tooltip_set_icon_from_icon_name() instead.
    @available(*, deprecated) func setFrom(stock stock_id: UnsafePointer<gchar>, size: GtkIconSize) {
        gtk_tooltip_set_icon_from_stock(cast(tooltip_ptr), stock_id, size)
    
    }

    /// Sets the text of the tooltip to be `markup`, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// If `markup` is `nil`, the label will be hidden.
    func set(markup: UnsafePointer<gchar>) {
        gtk_tooltip_set_markup(cast(tooltip_ptr), markup)
    
    }

    /// Sets the text of the tooltip to be `text`. If `text` is `nil`, the label
    /// will be hidden. See also `gtk_tooltip_set_markup()`.
    func set(text: UnsafePointer<gchar>) {
        gtk_tooltip_set_text(cast(tooltip_ptr), text)
    
    }

    /// Sets the area of the widget, where the contents of this tooltip apply,
    /// to be `rect` (in widget coordinates).  This is especially useful for
    /// properly setting tooltips on `GtkTreeView` rows and cells, `GtkIconViews`,
    /// etc.
    /// 
    /// For setting tooltips on `GtkTreeView`, please refer to the convenience
    /// functions for this: `gtk_tree_view_set_tooltip_row()` and
    /// `gtk_tree_view_set_tooltip_cell()`.
    func setTipArea(rect: Gdk.RectangleProtocol) {
        gtk_tooltip_set_tip_area(cast(tooltip_ptr), cast(rect.ptr))
    
    }
}



// MARK: - ToplevelAccessible Class

/// The `ToplevelAccessibleProtocol` protocol exposes the methods and properties of an underlying `GtkToplevelAccessible` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ToplevelAccessible`.
/// Alternatively, use `ToplevelAccessibleRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///

public protocol ToplevelAccessibleProtocol: Atk.ObjectProtocol {
    /// Untyped pointer to the underlying `GtkToplevelAccessible` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkToplevelAccessible` instance.
    var toplevel_accessible_ptr: UnsafeMutablePointer<GtkToplevelAccessible> { get }
}

/// The `ToplevelAccessibleRef` type acts as a lightweight Swift reference to an underlying `GtkToplevelAccessible` instance.
/// It exposes methods that can operate on this data type through `ToplevelAccessibleProtocol` conformance.
/// Use `ToplevelAccessibleRef` only as an `unowned` reference to an existing `GtkToplevelAccessible` instance.
///

public struct ToplevelAccessibleRef: ToplevelAccessibleProtocol {
    /// Untyped pointer to the underlying `GtkToplevelAccessible` instance.
    /// For type-safe access, use the generated, typed pointer `toplevel_accessible_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension ToplevelAccessibleRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkToplevelAccessible>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `ToplevelAccessibleProtocol`
    init<T: ToplevelAccessibleProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToplevelAccessibleProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToplevelAccessibleProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToplevelAccessibleProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToplevelAccessibleProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToplevelAccessibleProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `ToplevelAccessible` type acts as a reference-counted owner of an underlying `GtkToplevelAccessible` instance.
/// It provides the methods that can operate on this data type through `ToplevelAccessibleProtocol` conformance.
/// Use `ToplevelAccessible` as a strong reference or owner of a `GtkToplevelAccessible` instance.
///

open class ToplevelAccessible: Atk.Object, ToplevelAccessibleProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `ToplevelAccessible` instance.
    public init(_ op: UnsafeMutablePointer<GtkToplevelAccessible>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `ToplevelAccessibleProtocol`
    /// Will retain `GtkToplevelAccessible`.
    public convenience init<T: ToplevelAccessibleProtocol>(_ other: T) {
        self.init(cast(other.toplevel_accessible_ptr))
        g_object_ref(cast(toplevel_accessible_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToplevelAccessibleProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkToplevelAccessible.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToplevelAccessibleProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkToplevelAccessible.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToplevelAccessibleProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkToplevelAccessible.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToplevelAccessibleProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkToplevelAccessible>(opaquePointer))
    }



}

public enum ToplevelAccessiblePropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
}

public extension ToplevelAccessibleProtocol {
    /// Bind a `ToplevelAccessiblePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ToplevelAccessiblePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(toplevel_accessible_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum ToplevelAccessibleSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
}

public extension ToplevelAccessibleProtocol {
    /// Connect a `ToplevelAccessibleSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: ToplevelAccessibleSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(toplevel_accessible_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension ToplevelAccessibleProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkToplevelAccessible` instance.
    var toplevel_accessible_ptr: UnsafeMutablePointer<GtkToplevelAccessible> { return ptr.assumingMemoryBound(to: GtkToplevelAccessible.self) }

    func getChildren() -> UnsafeMutablePointer<GList>! {
        let rv = gtk_toplevel_accessible_get_children(cast(toplevel_accessible_ptr))
        return cast(rv)
    }
    var children: UnsafeMutablePointer<GList>! {
        get {
            let rv = gtk_toplevel_accessible_get_children(cast(toplevel_accessible_ptr))
            return cast(rv)
        }
    }
}



// MARK: - TreeModelFilter Class

/// The `TreeModelFilterProtocol` protocol exposes the methods and properties of an underlying `GtkTreeModelFilter` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeModelFilter`.
/// Alternatively, use `TreeModelFilterRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkTreeModelFilter` is a tree model which wraps another tree model,
/// and can do the following things:
/// 
/// - Filter specific rows, based on data from a “visible column”, a column
///   storing booleans indicating whether the row should be filtered or not,
///   or based on the return value of a “visible function”, which gets a
///   model, iter and user_data and returns a boolean indicating whether the
///   row should be filtered or not.
/// 
/// - Modify the “appearance” of the model, using a modify function.
///   This is extremely powerful and allows for just changing some
///   values and also for creating a completely different model based
///   on the given child model.
/// 
/// - Set a different root node, also known as a “virtual root”. You can pass
///   in a `GtkTreePath` indicating the root node for the filter at construction
///   time.
/// 
/// The basic API is similar to `GtkTreeModelSort`. For an example on its usage,
/// see the section on `GtkTreeModelSort`.
/// 
/// When using `GtkTreeModelFilter`, it is important to realize that
/// `GtkTreeModelFilter` maintains an internal cache of all nodes which are
/// visible in its clients. The cache is likely to be a subtree of the tree
/// exposed by the child model. `GtkTreeModelFilter` will not cache the entire
/// child model when unnecessary to not compromise the caching mechanism
/// that is exposed by the reference counting scheme. If the child model
/// implements reference counting, unnecessary signals may not be emitted
/// because of reference counting rule 3, see the `GtkTreeModel`
/// documentation. (Note that e.g. `GtkTreeStore` does not implement
/// reference counting and will always emit all signals, even when
/// the receiving node is not visible).
/// 
/// Because of this, limitations for possible visible functions do apply.
/// In general, visible functions should only use data or properties from
/// the node for which the visibility state must be determined, its siblings
/// or its parents. Usually, having a dependency on the state of any child
/// node is not possible, unless references are taken on these explicitly.
/// When no such reference exists, no signals may be received for these child
/// nodes (see reference couting rule number 3 in the `GtkTreeModel` section).
/// 
/// Determining the visibility state of a given node based on the state
/// of its child nodes is a frequently occurring use case. Therefore,
/// `GtkTreeModelFilter` explicitly supports this. For example, when a node
/// does not have any children, you might not want the node to be visible.
/// As soon as the first row is added to the node’s child level (or the
/// last row removed), the node’s visibility should be updated.
/// 
/// This introduces a dependency from the node on its child nodes. In order
/// to accommodate this, `GtkTreeModelFilter` must make sure the necessary
/// signals are received from the child model. This is achieved by building,
/// for all nodes which are exposed as visible nodes to `GtkTreeModelFilter`'s
/// clients, the child level (if any) and take a reference on the first node
/// in this level. Furthermore, for every row-inserted, row-changed or
/// row-deleted signal (also these which were not handled because the node
/// was not cached), `GtkTreeModelFilter` will check if the visibility state
/// of any parent node has changed.
/// 
/// Beware, however, that this explicit support is limited to these two
/// cases. For example, if you want a node to be visible only if two nodes
/// in a child’s child level (2 levels deeper) are visible, you are on your
/// own. In this case, either rely on `GtkTreeStore` to emit all signals
/// because it does not implement reference counting, or for models that
/// do implement reference counting, obtain references on these child levels
/// yourself.
public protocol TreeModelFilterProtocol: GLibObject.ObjectProtocol, TreeDragSourceProtocol, TreeModelProtocol {
    /// Untyped pointer to the underlying `GtkTreeModelFilter` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkTreeModelFilter` instance.
    var tree_model_filter_ptr: UnsafeMutablePointer<GtkTreeModelFilter> { get }
}

/// The `TreeModelFilterRef` type acts as a lightweight Swift reference to an underlying `GtkTreeModelFilter` instance.
/// It exposes methods that can operate on this data type through `TreeModelFilterProtocol` conformance.
/// Use `TreeModelFilterRef` only as an `unowned` reference to an existing `GtkTreeModelFilter` instance.
///
/// A `GtkTreeModelFilter` is a tree model which wraps another tree model,
/// and can do the following things:
/// 
/// - Filter specific rows, based on data from a “visible column”, a column
///   storing booleans indicating whether the row should be filtered or not,
///   or based on the return value of a “visible function”, which gets a
///   model, iter and user_data and returns a boolean indicating whether the
///   row should be filtered or not.
/// 
/// - Modify the “appearance” of the model, using a modify function.
///   This is extremely powerful and allows for just changing some
///   values and also for creating a completely different model based
///   on the given child model.
/// 
/// - Set a different root node, also known as a “virtual root”. You can pass
///   in a `GtkTreePath` indicating the root node for the filter at construction
///   time.
/// 
/// The basic API is similar to `GtkTreeModelSort`. For an example on its usage,
/// see the section on `GtkTreeModelSort`.
/// 
/// When using `GtkTreeModelFilter`, it is important to realize that
/// `GtkTreeModelFilter` maintains an internal cache of all nodes which are
/// visible in its clients. The cache is likely to be a subtree of the tree
/// exposed by the child model. `GtkTreeModelFilter` will not cache the entire
/// child model when unnecessary to not compromise the caching mechanism
/// that is exposed by the reference counting scheme. If the child model
/// implements reference counting, unnecessary signals may not be emitted
/// because of reference counting rule 3, see the `GtkTreeModel`
/// documentation. (Note that e.g. `GtkTreeStore` does not implement
/// reference counting and will always emit all signals, even when
/// the receiving node is not visible).
/// 
/// Because of this, limitations for possible visible functions do apply.
/// In general, visible functions should only use data or properties from
/// the node for which the visibility state must be determined, its siblings
/// or its parents. Usually, having a dependency on the state of any child
/// node is not possible, unless references are taken on these explicitly.
/// When no such reference exists, no signals may be received for these child
/// nodes (see reference couting rule number 3 in the `GtkTreeModel` section).
/// 
/// Determining the visibility state of a given node based on the state
/// of its child nodes is a frequently occurring use case. Therefore,
/// `GtkTreeModelFilter` explicitly supports this. For example, when a node
/// does not have any children, you might not want the node to be visible.
/// As soon as the first row is added to the node’s child level (or the
/// last row removed), the node’s visibility should be updated.
/// 
/// This introduces a dependency from the node on its child nodes. In order
/// to accommodate this, `GtkTreeModelFilter` must make sure the necessary
/// signals are received from the child model. This is achieved by building,
/// for all nodes which are exposed as visible nodes to `GtkTreeModelFilter`'s
/// clients, the child level (if any) and take a reference on the first node
/// in this level. Furthermore, for every row-inserted, row-changed or
/// row-deleted signal (also these which were not handled because the node
/// was not cached), `GtkTreeModelFilter` will check if the visibility state
/// of any parent node has changed.
/// 
/// Beware, however, that this explicit support is limited to these two
/// cases. For example, if you want a node to be visible only if two nodes
/// in a child’s child level (2 levels deeper) are visible, you are on your
/// own. In this case, either rely on `GtkTreeStore` to emit all signals
/// because it does not implement reference counting, or for models that
/// do implement reference counting, obtain references on these child levels
/// yourself.
public struct TreeModelFilterRef: TreeModelFilterProtocol {
    /// Untyped pointer to the underlying `GtkTreeModelFilter` instance.
    /// For type-safe access, use the generated, typed pointer `tree_model_filter_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension TreeModelFilterRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkTreeModelFilter>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `TreeModelFilterProtocol`
    init<T: TreeModelFilterProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `TreeModelFilter` type acts as a reference-counted owner of an underlying `GtkTreeModelFilter` instance.
/// It provides the methods that can operate on this data type through `TreeModelFilterProtocol` conformance.
/// Use `TreeModelFilter` as a strong reference or owner of a `GtkTreeModelFilter` instance.
///
/// A `GtkTreeModelFilter` is a tree model which wraps another tree model,
/// and can do the following things:
/// 
/// - Filter specific rows, based on data from a “visible column”, a column
///   storing booleans indicating whether the row should be filtered or not,
///   or based on the return value of a “visible function”, which gets a
///   model, iter and user_data and returns a boolean indicating whether the
///   row should be filtered or not.
/// 
/// - Modify the “appearance” of the model, using a modify function.
///   This is extremely powerful and allows for just changing some
///   values and also for creating a completely different model based
///   on the given child model.
/// 
/// - Set a different root node, also known as a “virtual root”. You can pass
///   in a `GtkTreePath` indicating the root node for the filter at construction
///   time.
/// 
/// The basic API is similar to `GtkTreeModelSort`. For an example on its usage,
/// see the section on `GtkTreeModelSort`.
/// 
/// When using `GtkTreeModelFilter`, it is important to realize that
/// `GtkTreeModelFilter` maintains an internal cache of all nodes which are
/// visible in its clients. The cache is likely to be a subtree of the tree
/// exposed by the child model. `GtkTreeModelFilter` will not cache the entire
/// child model when unnecessary to not compromise the caching mechanism
/// that is exposed by the reference counting scheme. If the child model
/// implements reference counting, unnecessary signals may not be emitted
/// because of reference counting rule 3, see the `GtkTreeModel`
/// documentation. (Note that e.g. `GtkTreeStore` does not implement
/// reference counting and will always emit all signals, even when
/// the receiving node is not visible).
/// 
/// Because of this, limitations for possible visible functions do apply.
/// In general, visible functions should only use data or properties from
/// the node for which the visibility state must be determined, its siblings
/// or its parents. Usually, having a dependency on the state of any child
/// node is not possible, unless references are taken on these explicitly.
/// When no such reference exists, no signals may be received for these child
/// nodes (see reference couting rule number 3 in the `GtkTreeModel` section).
/// 
/// Determining the visibility state of a given node based on the state
/// of its child nodes is a frequently occurring use case. Therefore,
/// `GtkTreeModelFilter` explicitly supports this. For example, when a node
/// does not have any children, you might not want the node to be visible.
/// As soon as the first row is added to the node’s child level (or the
/// last row removed), the node’s visibility should be updated.
/// 
/// This introduces a dependency from the node on its child nodes. In order
/// to accommodate this, `GtkTreeModelFilter` must make sure the necessary
/// signals are received from the child model. This is achieved by building,
/// for all nodes which are exposed as visible nodes to `GtkTreeModelFilter`'s
/// clients, the child level (if any) and take a reference on the first node
/// in this level. Furthermore, for every row-inserted, row-changed or
/// row-deleted signal (also these which were not handled because the node
/// was not cached), `GtkTreeModelFilter` will check if the visibility state
/// of any parent node has changed.
/// 
/// Beware, however, that this explicit support is limited to these two
/// cases. For example, if you want a node to be visible only if two nodes
/// in a child’s child level (2 levels deeper) are visible, you are on your
/// own. In this case, either rely on `GtkTreeStore` to emit all signals
/// because it does not implement reference counting, or for models that
/// do implement reference counting, obtain references on these child levels
/// yourself.
open class TreeModelFilter: GLibObject.Object, TreeModelFilterProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `TreeModelFilter` instance.
    public init(_ op: UnsafeMutablePointer<GtkTreeModelFilter>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `TreeModelFilterProtocol`
    /// Will retain `GtkTreeModelFilter`.
    public convenience init<T: TreeModelFilterProtocol>(_ other: T) {
        self.init(cast(other.tree_model_filter_ptr))
        g_object_ref(cast(tree_model_filter_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkTreeModelFilter.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkTreeModelFilter.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkTreeModelFilter.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkTreeModelFilter>(opaquePointer))
    }



}

public enum TreeModelFilterPropertyName: String, PropertyNameProtocol {
    case childModel = "child-model"
    case virtualRoot = "virtual-root"
}

public extension TreeModelFilterProtocol {
    /// Bind a `TreeModelFilterPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TreeModelFilterPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(tree_model_filter_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum TreeModelFilterSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case notifyChildModel = "notify::child-model"
    case notifyVirtualRoot = "notify::virtual-root"
}

public extension TreeModelFilterProtocol {
    /// Connect a `TreeModelFilterSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: TreeModelFilterSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(tree_model_filter_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension TreeModelFilterProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeModelFilter` instance.
    var tree_model_filter_ptr: UnsafeMutablePointer<GtkTreeModelFilter> { return ptr.assumingMemoryBound(to: GtkTreeModelFilter.self) }

    /// This function should almost never be called. It clears the `filter`
    /// of any cached iterators that haven’t been reffed with
    /// `gtk_tree_model_ref_node()`. This might be useful if the child model
    /// being filtered is static (and doesn’t change often) and there has been
    /// a lot of unreffed access to nodes. As a side effect of this function,
    /// all unreffed iters will be invalid.
    func clearCache() {
        gtk_tree_model_filter_clear_cache(cast(tree_model_filter_ptr))
    
    }

    /// Sets `filter_iter` to point to the row in `filter` that corresponds to the
    /// row pointed at by `child_iter`.  If `filter_iter` was not set, `false` is
    /// returned.
    func convertChildIterToIter(filterIter filter_iter: TreeIterProtocol, childIter child_iter: TreeIterProtocol) -> Bool {
        let rv = gtk_tree_model_filter_convert_child_iter_to_iter(cast(tree_model_filter_ptr), cast(filter_iter.ptr), cast(child_iter.ptr))
        return Bool(rv != 0)
    }

    /// Converts `child_path` to a path relative to `filter`. That is, `child_path`
    /// points to a path in the child model. The rerturned path will point to the
    /// same row in the filtered model. If `child_path` isn’t a valid path on the
    /// child model or points to a row which is not visible in `filter`, then `nil`
    /// is returned.
    func convertChildPathToPath(childPath child_path: TreePathProtocol) -> UnsafeMutablePointer<GtkTreePath>! {
        let rv = gtk_tree_model_filter_convert_child_path_to_path(cast(tree_model_filter_ptr), cast(child_path.ptr))
        return cast(rv)
    }

    /// Sets `child_iter` to point to the row pointed to by `filter_iter`.
    func convertIterTo(childIter child_iter: TreeIterProtocol, filterIter filter_iter: TreeIterProtocol) {
        gtk_tree_model_filter_convert_iter_to_child_iter(cast(tree_model_filter_ptr), cast(child_iter.ptr), cast(filter_iter.ptr))
    
    }

    /// Converts `filter_path` to a path on the child model of `filter`. That is,
    /// `filter_path` points to a location in `filter`. The returned path will
    /// point to the same location in the model not being filtered. If `filter_path`
    /// does not point to a location in the child model, `nil` is returned.
    func convertPathToChildPath(filterPath filter_path: TreePathProtocol) -> UnsafeMutablePointer<GtkTreePath>! {
        let rv = gtk_tree_model_filter_convert_path_to_child_path(cast(tree_model_filter_ptr), cast(filter_path.ptr))
        return cast(rv)
    }

    /// Returns a pointer to the child model of `filter`.
    func getModel() -> UnsafeMutablePointer<GtkTreeModel>! {
        let rv = gtk_tree_model_filter_get_model(cast(tree_model_filter_ptr))
        return cast(rv)
    }

    /// Emits `row_changed` for each row in the child model, which causes
    /// the filter to re-evaluate whether a row is visible or not.
    func refilter() {
        gtk_tree_model_filter_refilter(cast(tree_model_filter_ptr))
    
    }

    /// With the `n_columns` and `types` parameters, you give an array of column
    /// types for this model (which will be exposed to the parent model/view).
    /// The `func`, `data` and `destroy` parameters are for specifying the modify
    /// function. The modify function will get called for each
    /// data access, the goal of the modify function is to return the data which
    /// should be displayed at the location specified using the parameters of the
    /// modify function.
    /// 
    /// Note that `gtk_tree_model_filter_set_modify_func()`
    /// can only be called once for a given filter model.
    func setModifyFunc(nColumns n_columns: CInt, types: UnsafeMutablePointer<GType>, func_: @escaping TreeModelFilterModifyFunc, data: UnsafeMutableRawPointer, destroy: @escaping GLib.DestroyNotify) {
        gtk_tree_model_filter_set_modify_func(cast(tree_model_filter_ptr), gint(n_columns), cast(types), func_, cast(data), destroy)
    
    }

    /// Sets `column` of the child_model to be the column where `filter` should
    /// look for visibility information. `columns` should be a column of type
    /// `G_TYPE_BOOLEAN`, where `true` means that a row is visible, and `false`
    /// if not.
    /// 
    /// Note that `gtk_tree_model_filter_set_visible_func()` or
    /// `gtk_tree_model_filter_set_visible_column()` can only be called
    /// once for a given filter model.
    func setVisible(column: CInt) {
        gtk_tree_model_filter_set_visible_column(cast(tree_model_filter_ptr), gint(column))
    
    }

    /// Sets the visible function used when filtering the `filter` to be `func`.
    /// The function should return `true` if the given row should be visible and
    /// `false` otherwise.
    /// 
    /// If the condition calculated by the function changes over time (e.g.
    /// because it depends on some global parameters), you must call
    /// `gtk_tree_model_filter_refilter()` to keep the visibility information
    /// of the model up-to-date.
    /// 
    /// Note that `func` is called whenever a row is inserted, when it may still
    /// be empty. The visible function should therefore take special care of empty
    /// rows, like in the example below.
    /// 
    /// (C Language Example):
    /// ```C
    /// static gboolean
    /// visible_func (GtkTreeModel *model,
    ///               GtkTreeIter  *iter,
    ///               gpointer      data)
    /// {
    ///   // Visible if row is non-empty and first column is “HI”
    ///   gchar *str;
    ///   gboolean visible = FALSE;
    /// 
    ///   gtk_tree_model_get (model, iter, 0, &str, -1);
    ///   if (str && strcmp (str, "HI") == 0)
    ///     visible = TRUE;
    ///   g_free (str);
    /// 
    ///   return visible;
    /// }
    /// ```
    /// 
    /// Note that `gtk_tree_model_filter_set_visible_func()` or
    /// `gtk_tree_model_filter_set_visible_column()` can only be called
    /// once for a given filter model.
    func setVisibleFunc(_ func_: @escaping TreeModelFilterVisibleFunc, data: UnsafeMutableRawPointer, destroy: @escaping GLib.DestroyNotify) {
        gtk_tree_model_filter_set_visible_func(cast(tree_model_filter_ptr), func_, cast(data), destroy)
    
    }
    /// Returns a pointer to the child model of `filter`.
    var model: UnsafeMutablePointer<GtkTreeModel>! {
        /// Returns a pointer to the child model of `filter`.
        get {
            let rv = gtk_tree_model_filter_get_model(cast(tree_model_filter_ptr))
            return cast(rv)
        }
    }
}



// MARK: - TreeModelSort Class

/// The `TreeModelSortProtocol` protocol exposes the methods and properties of an underlying `GtkTreeModelSort` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeModelSort`.
/// Alternatively, use `TreeModelSortRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// The `GtkTreeModelSort` is a model which implements the `GtkTreeSortable`
/// interface.  It does not hold any data itself, but rather is created with
/// a child model and proxies its data.  It has identical column types to
/// this child model, and the changes in the child are propagated.  The
/// primary purpose of this model is to provide a way to sort a different
/// model without modifying it. Note that the sort function used by
/// `GtkTreeModelSort` is not guaranteed to be stable.
/// 
/// The use of this is best demonstrated through an example.  In the
/// following sample code we create two `GtkTreeView` widgets each with a
/// view of the same data.  As the model is wrapped here by a
/// `GtkTreeModelSort`, the two `GtkTreeViews` can each sort their
/// view of the data without affecting the other.  By contrast, if we
/// simply put the same model in each widget, then sorting the first would
/// sort the second.
/// 
/// ## Using a `GtkTreeModelSort`
/// 
/// (C Language Example):
/// ```C
/// {
///   GtkTreeView *tree_view1;
///   GtkTreeView *tree_view2;
///   GtkTreeModel *sort_model1;
///   GtkTreeModel *sort_model2;
///   GtkTreeModel *child_model;
/// 
///   // get the child model
///   child_model = get_my_model ();
/// 
///   // Create the first tree
///   sort_model1 = gtk_tree_model_sort_new_with_model (child_model);
///   tree_view1 = gtk_tree_view_new_with_model (sort_model1);
/// 
///   // Create the second tree
///   sort_model2 = gtk_tree_model_sort_new_with_model (child_model);
///   tree_view2 = gtk_tree_view_new_with_model (sort_model2);
/// 
///   // Now we can sort the two models independently
///   gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model1),
///                                         COLUMN_1, GTK_SORT_ASCENDING);
///   gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model2),
///                                         COLUMN_1, GTK_SORT_DESCENDING);
/// }
/// ```
/// 
/// To demonstrate how to access the underlying child model from the sort
/// model, the next example will be a callback for the `GtkTreeSelection`
/// `GtkTreeSelection::changed` signal.  In this callback, we get a string
/// from COLUMN_1 of the model.  We then modify the string, find the same
/// selected row on the child model, and change the row there.
/// 
/// ## Accessing the child model of in a selection changed callback
/// 
/// (C Language Example):
/// ```C
/// void
/// selection_changed (GtkTreeSelection *selection, gpointer data)
/// {
///   GtkTreeModel *sort_model = NULL;
///   GtkTreeModel *child_model;
///   GtkTreeIter sort_iter;
///   GtkTreeIter child_iter;
///   char *some_data = NULL;
///   char *modified_data;
/// 
///   // Get the current selected row and the model.
///   if (! gtk_tree_selection_get_selected (selection,
///                                          &sort_model,
///                                          &sort_iter))
///     return;
/// 
///   // Look up the current value on the selected row and get
///   // a new value to change it to.
///   gtk_tree_model_get (GTK_TREE_MODEL (sort_model), &sort_iter,
///                       COLUMN_1, &some_data,
///                       -1);
/// 
///   modified_data = change_the_data (some_data);
///   g_free (some_data);
/// 
///   // Get an iterator on the child model, instead of the sort model.
///   gtk_tree_model_sort_convert_iter_to_child_iter (GTK_TREE_MODEL_SORT (sort_model),
///                                                   &child_iter,
///                                                   &sort_iter);
/// 
///   // Get the child model and change the value of the row. In this
///   // example, the child model is a GtkListStore. It could be any other
///   // type of model, though.
///   child_model = gtk_tree_model_sort_get_model (GTK_TREE_MODEL_SORT (sort_model));
///   gtk_list_store_set (GTK_LIST_STORE (child_model), &child_iter,
///                       COLUMN_1, &modified_data,
///                       -1);
///   g_free (modified_data);
/// }
/// ```
/// 
public protocol TreeModelSortProtocol: GLibObject.ObjectProtocol, TreeDragSourceProtocol, TreeModelProtocol, TreeSortableProtocol {
    /// Untyped pointer to the underlying `GtkTreeModelSort` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkTreeModelSort` instance.
    var tree_model_sort_ptr: UnsafeMutablePointer<GtkTreeModelSort> { get }
}

/// The `TreeModelSortRef` type acts as a lightweight Swift reference to an underlying `GtkTreeModelSort` instance.
/// It exposes methods that can operate on this data type through `TreeModelSortProtocol` conformance.
/// Use `TreeModelSortRef` only as an `unowned` reference to an existing `GtkTreeModelSort` instance.
///
/// The `GtkTreeModelSort` is a model which implements the `GtkTreeSortable`
/// interface.  It does not hold any data itself, but rather is created with
/// a child model and proxies its data.  It has identical column types to
/// this child model, and the changes in the child are propagated.  The
/// primary purpose of this model is to provide a way to sort a different
/// model without modifying it. Note that the sort function used by
/// `GtkTreeModelSort` is not guaranteed to be stable.
/// 
/// The use of this is best demonstrated through an example.  In the
/// following sample code we create two `GtkTreeView` widgets each with a
/// view of the same data.  As the model is wrapped here by a
/// `GtkTreeModelSort`, the two `GtkTreeViews` can each sort their
/// view of the data without affecting the other.  By contrast, if we
/// simply put the same model in each widget, then sorting the first would
/// sort the second.
/// 
/// ## Using a `GtkTreeModelSort`
/// 
/// (C Language Example):
/// ```C
/// {
///   GtkTreeView *tree_view1;
///   GtkTreeView *tree_view2;
///   GtkTreeModel *sort_model1;
///   GtkTreeModel *sort_model2;
///   GtkTreeModel *child_model;
/// 
///   // get the child model
///   child_model = get_my_model ();
/// 
///   // Create the first tree
///   sort_model1 = gtk_tree_model_sort_new_with_model (child_model);
///   tree_view1 = gtk_tree_view_new_with_model (sort_model1);
/// 
///   // Create the second tree
///   sort_model2 = gtk_tree_model_sort_new_with_model (child_model);
///   tree_view2 = gtk_tree_view_new_with_model (sort_model2);
/// 
///   // Now we can sort the two models independently
///   gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model1),
///                                         COLUMN_1, GTK_SORT_ASCENDING);
///   gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model2),
///                                         COLUMN_1, GTK_SORT_DESCENDING);
/// }
/// ```
/// 
/// To demonstrate how to access the underlying child model from the sort
/// model, the next example will be a callback for the `GtkTreeSelection`
/// `GtkTreeSelection::changed` signal.  In this callback, we get a string
/// from COLUMN_1 of the model.  We then modify the string, find the same
/// selected row on the child model, and change the row there.
/// 
/// ## Accessing the child model of in a selection changed callback
/// 
/// (C Language Example):
/// ```C
/// void
/// selection_changed (GtkTreeSelection *selection, gpointer data)
/// {
///   GtkTreeModel *sort_model = NULL;
///   GtkTreeModel *child_model;
///   GtkTreeIter sort_iter;
///   GtkTreeIter child_iter;
///   char *some_data = NULL;
///   char *modified_data;
/// 
///   // Get the current selected row and the model.
///   if (! gtk_tree_selection_get_selected (selection,
///                                          &sort_model,
///                                          &sort_iter))
///     return;
/// 
///   // Look up the current value on the selected row and get
///   // a new value to change it to.
///   gtk_tree_model_get (GTK_TREE_MODEL (sort_model), &sort_iter,
///                       COLUMN_1, &some_data,
///                       -1);
/// 
///   modified_data = change_the_data (some_data);
///   g_free (some_data);
/// 
///   // Get an iterator on the child model, instead of the sort model.
///   gtk_tree_model_sort_convert_iter_to_child_iter (GTK_TREE_MODEL_SORT (sort_model),
///                                                   &child_iter,
///                                                   &sort_iter);
/// 
///   // Get the child model and change the value of the row. In this
///   // example, the child model is a GtkListStore. It could be any other
///   // type of model, though.
///   child_model = gtk_tree_model_sort_get_model (GTK_TREE_MODEL_SORT (sort_model));
///   gtk_list_store_set (GTK_LIST_STORE (child_model), &child_iter,
///                       COLUMN_1, &modified_data,
///                       -1);
///   g_free (modified_data);
/// }
/// ```
/// 
public struct TreeModelSortRef: TreeModelSortProtocol {
    /// Untyped pointer to the underlying `GtkTreeModelSort` instance.
    /// For type-safe access, use the generated, typed pointer `tree_model_sort_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension TreeModelSortRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkTreeModelSort>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `TreeModelSortProtocol`
    init<T: TreeModelSortProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `TreeModelSort` type acts as a reference-counted owner of an underlying `GtkTreeModelSort` instance.
/// It provides the methods that can operate on this data type through `TreeModelSortProtocol` conformance.
/// Use `TreeModelSort` as a strong reference or owner of a `GtkTreeModelSort` instance.
///
/// The `GtkTreeModelSort` is a model which implements the `GtkTreeSortable`
/// interface.  It does not hold any data itself, but rather is created with
/// a child model and proxies its data.  It has identical column types to
/// this child model, and the changes in the child are propagated.  The
/// primary purpose of this model is to provide a way to sort a different
/// model without modifying it. Note that the sort function used by
/// `GtkTreeModelSort` is not guaranteed to be stable.
/// 
/// The use of this is best demonstrated through an example.  In the
/// following sample code we create two `GtkTreeView` widgets each with a
/// view of the same data.  As the model is wrapped here by a
/// `GtkTreeModelSort`, the two `GtkTreeViews` can each sort their
/// view of the data without affecting the other.  By contrast, if we
/// simply put the same model in each widget, then sorting the first would
/// sort the second.
/// 
/// ## Using a `GtkTreeModelSort`
/// 
/// (C Language Example):
/// ```C
/// {
///   GtkTreeView *tree_view1;
///   GtkTreeView *tree_view2;
///   GtkTreeModel *sort_model1;
///   GtkTreeModel *sort_model2;
///   GtkTreeModel *child_model;
/// 
///   // get the child model
///   child_model = get_my_model ();
/// 
///   // Create the first tree
///   sort_model1 = gtk_tree_model_sort_new_with_model (child_model);
///   tree_view1 = gtk_tree_view_new_with_model (sort_model1);
/// 
///   // Create the second tree
///   sort_model2 = gtk_tree_model_sort_new_with_model (child_model);
///   tree_view2 = gtk_tree_view_new_with_model (sort_model2);
/// 
///   // Now we can sort the two models independently
///   gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model1),
///                                         COLUMN_1, GTK_SORT_ASCENDING);
///   gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model2),
///                                         COLUMN_1, GTK_SORT_DESCENDING);
/// }
/// ```
/// 
/// To demonstrate how to access the underlying child model from the sort
/// model, the next example will be a callback for the `GtkTreeSelection`
/// `GtkTreeSelection::changed` signal.  In this callback, we get a string
/// from COLUMN_1 of the model.  We then modify the string, find the same
/// selected row on the child model, and change the row there.
/// 
/// ## Accessing the child model of in a selection changed callback
/// 
/// (C Language Example):
/// ```C
/// void
/// selection_changed (GtkTreeSelection *selection, gpointer data)
/// {
///   GtkTreeModel *sort_model = NULL;
///   GtkTreeModel *child_model;
///   GtkTreeIter sort_iter;
///   GtkTreeIter child_iter;
///   char *some_data = NULL;
///   char *modified_data;
/// 
///   // Get the current selected row and the model.
///   if (! gtk_tree_selection_get_selected (selection,
///                                          &sort_model,
///                                          &sort_iter))
///     return;
/// 
///   // Look up the current value on the selected row and get
///   // a new value to change it to.
///   gtk_tree_model_get (GTK_TREE_MODEL (sort_model), &sort_iter,
///                       COLUMN_1, &some_data,
///                       -1);
/// 
///   modified_data = change_the_data (some_data);
///   g_free (some_data);
/// 
///   // Get an iterator on the child model, instead of the sort model.
///   gtk_tree_model_sort_convert_iter_to_child_iter (GTK_TREE_MODEL_SORT (sort_model),
///                                                   &child_iter,
///                                                   &sort_iter);
/// 
///   // Get the child model and change the value of the row. In this
///   // example, the child model is a GtkListStore. It could be any other
///   // type of model, though.
///   child_model = gtk_tree_model_sort_get_model (GTK_TREE_MODEL_SORT (sort_model));
///   gtk_list_store_set (GTK_LIST_STORE (child_model), &child_iter,
///                       COLUMN_1, &modified_data,
///                       -1);
///   g_free (modified_data);
/// }
/// ```
/// 
open class TreeModelSort: GLibObject.Object, TreeModelSortProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `TreeModelSort` instance.
    public init(_ op: UnsafeMutablePointer<GtkTreeModelSort>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `TreeModelSortProtocol`
    /// Will retain `GtkTreeModelSort`.
    public convenience init<T: TreeModelSortProtocol>(_ other: T) {
        self.init(cast(other.tree_model_sort_ptr))
        g_object_ref(cast(tree_model_sort_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkTreeModelSort.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkTreeModelSort.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkTreeModelSort.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkTreeModelSort>(opaquePointer))
    }



}

public enum TreeModelSortPropertyName: String, PropertyNameProtocol {
    case model = "model"
}

public extension TreeModelSortProtocol {
    /// Bind a `TreeModelSortPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TreeModelSortPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(tree_model_sort_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum TreeModelSortSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case notifyModel = "notify::model"
}

public extension TreeModelSortProtocol {
    /// Connect a `TreeModelSortSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: TreeModelSortSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(tree_model_sort_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension TreeModelSortProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeModelSort` instance.
    var tree_model_sort_ptr: UnsafeMutablePointer<GtkTreeModelSort> { return ptr.assumingMemoryBound(to: GtkTreeModelSort.self) }

    /// This function should almost never be called.  It clears the `tree_model_sort`
    /// of any cached iterators that haven’t been reffed with
    /// `gtk_tree_model_ref_node()`.  This might be useful if the child model being
    /// sorted is static (and doesn’t change often) and there has been a lot of
    /// unreffed access to nodes.  As a side effect of this function, all unreffed
    /// iters will be invalid.
    func clearCache() {
        gtk_tree_model_sort_clear_cache(cast(tree_model_sort_ptr))
    
    }

    /// Sets `sort_iter` to point to the row in `tree_model_sort` that corresponds to
    /// the row pointed at by `child_iter`.  If `sort_iter` was not set, `false`
    /// is returned.  Note: a boolean is only returned since 2.14.
    func convertChildIterToIter(sortIter sort_iter: TreeIterProtocol, childIter child_iter: TreeIterProtocol) -> Bool {
        let rv = gtk_tree_model_sort_convert_child_iter_to_iter(cast(tree_model_sort_ptr), cast(sort_iter.ptr), cast(child_iter.ptr))
        return Bool(rv != 0)
    }

    /// Converts `child_path` to a path relative to `tree_model_sort`.  That is,
    /// `child_path` points to a path in the child model.  The returned path will
    /// point to the same row in the sorted model.  If `child_path` isn’t a valid
    /// path on the child model, then `nil` is returned.
    func convertChildPathToPath(childPath child_path: TreePathProtocol) -> UnsafeMutablePointer<GtkTreePath>! {
        let rv = gtk_tree_model_sort_convert_child_path_to_path(cast(tree_model_sort_ptr), cast(child_path.ptr))
        return cast(rv)
    }

    /// Sets `child_iter` to point to the row pointed to by `sorted_iter`.
    func convertIterTo(childIter child_iter: TreeIterProtocol, sortedIter sorted_iter: TreeIterProtocol) {
        gtk_tree_model_sort_convert_iter_to_child_iter(cast(tree_model_sort_ptr), cast(child_iter.ptr), cast(sorted_iter.ptr))
    
    }

    /// Converts `sorted_path` to a path on the child model of `tree_model_sort`.
    /// That is, `sorted_path` points to a location in `tree_model_sort`.  The
    /// returned path will point to the same location in the model not being
    /// sorted.  If `sorted_path` does not point to a location in the child model,
    /// `nil` is returned.
    func convertPathToChildPath(sortedPath sorted_path: TreePathProtocol) -> UnsafeMutablePointer<GtkTreePath>! {
        let rv = gtk_tree_model_sort_convert_path_to_child_path(cast(tree_model_sort_ptr), cast(sorted_path.ptr))
        return cast(rv)
    }

    /// Returns the model the `GtkTreeModelSort` is sorting.
    func getModel() -> UnsafeMutablePointer<GtkTreeModel>! {
        let rv = gtk_tree_model_sort_get_model(cast(tree_model_sort_ptr))
        return cast(rv)
    }

    /// > This function is slow. Only use it for debugging and/or testing
    /// > purposes.
    /// 
    /// Checks if the given iter is a valid iter for this `GtkTreeModelSort`.
    func iterIsValid(iter: TreeIterProtocol) -> Bool {
        let rv = gtk_tree_model_sort_iter_is_valid(cast(tree_model_sort_ptr), cast(iter.ptr))
        return Bool(rv != 0)
    }

    /// This resets the default sort function to be in the “unsorted” state.  That
    /// is, it is in the same order as the child model. It will re-sort the model
    /// to be in the same order as the child model only if the `GtkTreeModelSort`
    /// is in “unsorted” state.
    func resetDefaultSortFunc() {
        gtk_tree_model_sort_reset_default_sort_func(cast(tree_model_sort_ptr))
    
    }
    var model: UnsafeMutablePointer<GtkTreeModel>! {
        /// Returns the model the `GtkTreeModelSort` is sorting.
        get {
            let rv = gtk_tree_model_sort_get_model(cast(tree_model_sort_ptr))
            return cast(rv)
        }
    }
}



// MARK: - TreeSelection Class

/// The `TreeSelectionProtocol` protocol exposes the methods and properties of an underlying `GtkTreeSelection` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeSelection`.
/// Alternatively, use `TreeSelectionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// The `GtkTreeSelection` object is a helper object to manage the selection
/// for a `GtkTreeView` widget.  The `GtkTreeSelection` object is
/// automatically created when a new `GtkTreeView` widget is created, and
/// cannot exist independently of this widget.  The primary reason the
/// `GtkTreeSelection` objects exists is for cleanliness of code and API.
/// That is, there is no conceptual reason all these functions could not be
/// methods on the `GtkTreeView` widget instead of a separate function.
/// 
/// The `GtkTreeSelection` object is gotten from a `GtkTreeView` by calling
/// `gtk_tree_view_get_selection()`.  It can be manipulated to check the
/// selection status of the tree, as well as select and deselect individual
/// rows.  Selection is done completely view side.  As a result, multiple
/// views of the same model can have completely different selections.
/// Additionally, you cannot change the selection of a row on the model that
/// is not currently displayed by the view without expanding its parents
/// first.
/// 
/// One of the important things to remember when monitoring the selection of
/// a view is that the `GtkTreeSelection::changed` signal is mostly a hint.
/// That is, it may only emit one signal when a range of rows is selected.
/// Additionally, it may on occasion emit a `GtkTreeSelection::changed` signal
/// when nothing has happened (mostly as a result of programmers calling
/// select_row on an already selected row).
public protocol TreeSelectionProtocol: GLibObject.ObjectProtocol {
    /// Untyped pointer to the underlying `GtkTreeSelection` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkTreeSelection` instance.
    var tree_selection_ptr: UnsafeMutablePointer<GtkTreeSelection> { get }
}

/// The `TreeSelectionRef` type acts as a lightweight Swift reference to an underlying `GtkTreeSelection` instance.
/// It exposes methods that can operate on this data type through `TreeSelectionProtocol` conformance.
/// Use `TreeSelectionRef` only as an `unowned` reference to an existing `GtkTreeSelection` instance.
///
/// The `GtkTreeSelection` object is a helper object to manage the selection
/// for a `GtkTreeView` widget.  The `GtkTreeSelection` object is
/// automatically created when a new `GtkTreeView` widget is created, and
/// cannot exist independently of this widget.  The primary reason the
/// `GtkTreeSelection` objects exists is for cleanliness of code and API.
/// That is, there is no conceptual reason all these functions could not be
/// methods on the `GtkTreeView` widget instead of a separate function.
/// 
/// The `GtkTreeSelection` object is gotten from a `GtkTreeView` by calling
/// `gtk_tree_view_get_selection()`.  It can be manipulated to check the
/// selection status of the tree, as well as select and deselect individual
/// rows.  Selection is done completely view side.  As a result, multiple
/// views of the same model can have completely different selections.
/// Additionally, you cannot change the selection of a row on the model that
/// is not currently displayed by the view without expanding its parents
/// first.
/// 
/// One of the important things to remember when monitoring the selection of
/// a view is that the `GtkTreeSelection::changed` signal is mostly a hint.
/// That is, it may only emit one signal when a range of rows is selected.
/// Additionally, it may on occasion emit a `GtkTreeSelection::changed` signal
/// when nothing has happened (mostly as a result of programmers calling
/// select_row on an already selected row).
public struct TreeSelectionRef: TreeSelectionProtocol {
    /// Untyped pointer to the underlying `GtkTreeSelection` instance.
    /// For type-safe access, use the generated, typed pointer `tree_selection_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension TreeSelectionRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkTreeSelection>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `TreeSelectionProtocol`
    init<T: TreeSelectionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `TreeSelection` type acts as a reference-counted owner of an underlying `GtkTreeSelection` instance.
/// It provides the methods that can operate on this data type through `TreeSelectionProtocol` conformance.
/// Use `TreeSelection` as a strong reference or owner of a `GtkTreeSelection` instance.
///
/// The `GtkTreeSelection` object is a helper object to manage the selection
/// for a `GtkTreeView` widget.  The `GtkTreeSelection` object is
/// automatically created when a new `GtkTreeView` widget is created, and
/// cannot exist independently of this widget.  The primary reason the
/// `GtkTreeSelection` objects exists is for cleanliness of code and API.
/// That is, there is no conceptual reason all these functions could not be
/// methods on the `GtkTreeView` widget instead of a separate function.
/// 
/// The `GtkTreeSelection` object is gotten from a `GtkTreeView` by calling
/// `gtk_tree_view_get_selection()`.  It can be manipulated to check the
/// selection status of the tree, as well as select and deselect individual
/// rows.  Selection is done completely view side.  As a result, multiple
/// views of the same model can have completely different selections.
/// Additionally, you cannot change the selection of a row on the model that
/// is not currently displayed by the view without expanding its parents
/// first.
/// 
/// One of the important things to remember when monitoring the selection of
/// a view is that the `GtkTreeSelection::changed` signal is mostly a hint.
/// That is, it may only emit one signal when a range of rows is selected.
/// Additionally, it may on occasion emit a `GtkTreeSelection::changed` signal
/// when nothing has happened (mostly as a result of programmers calling
/// select_row on an already selected row).
open class TreeSelection: GLibObject.Object, TreeSelectionProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `TreeSelection` instance.
    public init(_ op: UnsafeMutablePointer<GtkTreeSelection>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `TreeSelectionProtocol`
    /// Will retain `GtkTreeSelection`.
    public convenience init<T: TreeSelectionProtocol>(_ other: T) {
        self.init(cast(other.tree_selection_ptr))
        g_object_ref(cast(tree_selection_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkTreeSelection.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkTreeSelection.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkTreeSelection.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkTreeSelection>(opaquePointer))
    }



}

public enum TreeSelectionPropertyName: String, PropertyNameProtocol {
    /// Selection mode.
    /// See `gtk_tree_selection_set_mode()` for more information on this property.
    case mode = "mode"
}

public extension TreeSelectionProtocol {
    /// Bind a `TreeSelectionPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TreeSelectionPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(tree_selection_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum TreeSelectionSignalName: String, SignalNameProtocol {
    /// Emitted whenever the selection has (possibly) changed. Please note that
    /// this signal is mostly a hint.  It may only be emitted once when a range
    /// of rows are selected, and it may occasionally be emitted when nothing
    /// has happened.
    case changed = "changed"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Selection mode.
    /// See `gtk_tree_selection_set_mode()` for more information on this property.
    case notifyMode = "notify::mode"
}

public extension TreeSelectionProtocol {
    /// Connect a `TreeSelectionSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: TreeSelectionSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(tree_selection_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension TreeSelectionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeSelection` instance.
    var tree_selection_ptr: UnsafeMutablePointer<GtkTreeSelection> { return ptr.assumingMemoryBound(to: GtkTreeSelection.self) }

    /// Returns the number of rows that have been selected in `tree`.
    func countSelectedRows() -> CInt {
        let rv = gtk_tree_selection_count_selected_rows(cast(tree_selection_ptr))
        return CInt(rv)
    }

    /// Gets the selection mode for `selection`. See
    /// `gtk_tree_selection_set_mode()`.
    func getMode() -> GtkSelectionMode {
        let rv = gtk_tree_selection_get_mode(cast(tree_selection_ptr))
        return rv
    }

    /// Returns the current selection function.
    func getSelectFunction() -> GtkTreeSelectionFunc! {
        let rv = gtk_tree_selection_get_select_function(cast(tree_selection_ptr))
        return rv
    }

    /// Sets `iter` to the currently selected node if `selection` is set to
    /// `GTK_SELECTION_SINGLE` or `GTK_SELECTION_BROWSE`.  `iter` may be NULL if you
    /// just want to test if `selection` has any selected nodes.  `model` is filled
    /// with the current model as a convenience.  This function will not work if you
    /// use `selection` is `GTK_SELECTION_MULTIPLE`.
    func getSelected(model: TreeModelProtocol, iter: TreeIterProtocol) -> Bool {
        let rv = gtk_tree_selection_get_selected(cast(tree_selection_ptr), cast(model.ptr), cast(iter.ptr))
        return Bool(rv != 0)
    }

    /// Creates a list of path of all selected rows. Additionally, if you are
    /// planning on modifying the model after calling this function, you may
    /// want to convert the returned list into a list of `GtkTreeRowReferences`.
    /// To do this, you can use `gtk_tree_row_reference_new()`.
    /// 
    /// To free the return value, use:
    /// (C Language Example):
    /// ```C
    /// g_list_free_full (list, (GDestroyNotify) gtk_tree_path_free);
    /// ```
    /// 
    func getSelectedRows(model: TreeModelProtocol) -> UnsafeMutablePointer<GList>! {
        let rv = gtk_tree_selection_get_selected_rows(cast(tree_selection_ptr), cast(model.ptr))
        return cast(rv)
    }

    /// Returns the tree view associated with `selection`.
    func getTreeView() -> UnsafeMutablePointer<GtkTreeView>! {
        let rv = gtk_tree_selection_get_tree_view(cast(tree_selection_ptr))
        return cast(rv)
    }

    /// Returns the user data for the selection function.
    func getUserData() -> UnsafeMutableRawPointer! {
        let rv = gtk_tree_selection_get_user_data(cast(tree_selection_ptr))
        return cast(rv)
    }

    /// Returns `true` if the row at `iter` is currently selected.
    func iterIsSelected(iter: TreeIterProtocol) -> Bool {
        let rv = gtk_tree_selection_iter_is_selected(cast(tree_selection_ptr), cast(iter.ptr))
        return Bool(rv != 0)
    }

    /// Returns `true` if the row pointed to by `path` is currently selected.  If `path`
    /// does not point to a valid location, `false` is returned
    func pathIsSelected(path: TreePathProtocol) -> Bool {
        let rv = gtk_tree_selection_path_is_selected(cast(tree_selection_ptr), cast(path.ptr))
        return Bool(rv != 0)
    }

    /// Selects all the nodes. `selection` must be set to `GTK_SELECTION_MULTIPLE`
    /// mode.
    func selectAll() {
        gtk_tree_selection_select_all(cast(tree_selection_ptr))
    
    }

    /// Selects the specified iterator.
    func select(iter: TreeIterProtocol) {
        gtk_tree_selection_select_iter(cast(tree_selection_ptr), cast(iter.ptr))
    
    }

    /// Select the row at `path`.
    func select(path: TreePathProtocol) {
        gtk_tree_selection_select_path(cast(tree_selection_ptr), cast(path.ptr))
    
    }

    /// Selects a range of nodes, determined by `start_path` and `end_path` inclusive.
    /// `selection` must be set to `GTK_SELECTION_MULTIPLE` mode.
    func selectRange(startPath start_path: TreePathProtocol, endPath end_path: TreePathProtocol) {
        gtk_tree_selection_select_range(cast(tree_selection_ptr), cast(start_path.ptr), cast(end_path.ptr))
    
    }

    /// Calls a function for each selected node. Note that you cannot modify
    /// the tree or selection from within this function. As a result,
    /// `gtk_tree_selection_get_selected_rows()` might be more useful.
    func selectedForeach(_ func_: @escaping TreeSelectionForeachFunc, data: UnsafeMutableRawPointer) {
        gtk_tree_selection_selected_foreach(cast(tree_selection_ptr), func_, cast(data))
    
    }

    /// Sets the selection mode of the `selection`.  If the previous type was
    /// `GTK_SELECTION_MULTIPLE`, then the anchor is kept selected, if it was
    /// previously selected.
    func setMode(type: SelectionMode) {
        gtk_tree_selection_set_mode(cast(tree_selection_ptr), type)
    
    }

    /// Sets the selection function.
    /// 
    /// If set, this function is called before any node is selected or unselected,
    /// giving some control over which nodes are selected. The select function
    /// should return `true` if the state of the node may be toggled, and `false`
    /// if the state of the node should be left unchanged.
    func setSelectFunction(_ func_: @escaping TreeSelectionFunc, data: UnsafeMutableRawPointer, destroy: @escaping GLib.DestroyNotify) {
        gtk_tree_selection_set_select_function(cast(tree_selection_ptr), func_, cast(data), destroy)
    
    }

    /// Unselects all the nodes.
    func unselectAll() {
        gtk_tree_selection_unselect_all(cast(tree_selection_ptr))
    
    }

    /// Unselects the specified iterator.
    func unselect(iter: TreeIterProtocol) {
        gtk_tree_selection_unselect_iter(cast(tree_selection_ptr), cast(iter.ptr))
    
    }

    /// Unselects the row at `path`.
    func unselect(path: TreePathProtocol) {
        gtk_tree_selection_unselect_path(cast(tree_selection_ptr), cast(path.ptr))
    
    }

    /// Unselects a range of nodes, determined by `start_path` and `end_path`
    /// inclusive.
    func unselectRange(startPath start_path: TreePathProtocol, endPath end_path: TreePathProtocol) {
        gtk_tree_selection_unselect_range(cast(tree_selection_ptr), cast(start_path.ptr), cast(end_path.ptr))
    
    }
    /// Selection mode.
    /// See `gtk_tree_selection_set_mode()` for more information on this property.
    var mode: GtkSelectionMode {
        /// Gets the selection mode for `selection`. See
        /// `gtk_tree_selection_set_mode()`.
        get {
            let rv = gtk_tree_selection_get_mode(cast(tree_selection_ptr))
            return rv
        }
        /// Sets the selection mode of the `selection`.  If the previous type was
        /// `GTK_SELECTION_MULTIPLE`, then the anchor is kept selected, if it was
        /// previously selected.
        nonmutating set {
            gtk_tree_selection_set_mode(cast(tree_selection_ptr), newValue)
        }
    }

    /// Returns the current selection function.
    var selectFunction: GtkTreeSelectionFunc! {
        /// Returns the current selection function.
        get {
            let rv = gtk_tree_selection_get_select_function(cast(tree_selection_ptr))
            return rv
        }
    }

    /// Returns the tree view associated with `selection`.
    var treeView: UnsafeMutablePointer<GtkTreeView>! {
        /// Returns the tree view associated with `selection`.
        get {
            let rv = gtk_tree_selection_get_tree_view(cast(tree_selection_ptr))
            return cast(rv)
        }
    }

    /// Returns the user data for the selection function.
    var userData: UnsafeMutableRawPointer! {
        /// Returns the user data for the selection function.
        get {
            let rv = gtk_tree_selection_get_user_data(cast(tree_selection_ptr))
            return cast(rv)
        }
    }
}



// MARK: - TreeStore Class

/// The `TreeStoreProtocol` protocol exposes the methods and properties of an underlying `GtkTreeStore` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeStore`.
/// Alternatively, use `TreeStoreRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// The `GtkTreeStore` object is a list model for use with a `GtkTreeView`
/// widget.  It implements the `GtkTreeModel` interface, and consequentially,
/// can use all of the methods available there.  It also implements the
/// `GtkTreeSortable` interface so it can be sorted by the view.  Finally,
/// it also implements the tree
/// [drag and drop](#gtk3-GtkTreeView-drag-and-drop)
/// interfaces.
/// 
/// # GtkTreeStore as GtkBuildable
/// 
/// The GtkTreeStore implementation of the `GtkBuildable` interface allows
/// to specify the model columns with a <columns> element that may contain
/// multiple <column> elements, each specifying one model column. The “type”
/// attribute specifies the data type for the column.
/// 
/// An example of a UI Definition fragment for a tree store:
/// ```
/// <object class="GtkTreeStore">
///   <columns>
///     <column type="gchararray"/>
///     <column type="gchararray"/>
///     <column type="gint"/>
///   </columns>
/// </object>
/// ```
/// 
public protocol TreeStoreProtocol: GLibObject.ObjectProtocol, BuildableProtocol, TreeDragDestProtocol, TreeDragSourceProtocol, TreeModelProtocol, TreeSortableProtocol {
    /// Untyped pointer to the underlying `GtkTreeStore` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkTreeStore` instance.
    var tree_store_ptr: UnsafeMutablePointer<GtkTreeStore> { get }
}

/// The `TreeStoreRef` type acts as a lightweight Swift reference to an underlying `GtkTreeStore` instance.
/// It exposes methods that can operate on this data type through `TreeStoreProtocol` conformance.
/// Use `TreeStoreRef` only as an `unowned` reference to an existing `GtkTreeStore` instance.
///
/// The `GtkTreeStore` object is a list model for use with a `GtkTreeView`
/// widget.  It implements the `GtkTreeModel` interface, and consequentially,
/// can use all of the methods available there.  It also implements the
/// `GtkTreeSortable` interface so it can be sorted by the view.  Finally,
/// it also implements the tree
/// [drag and drop](#gtk3-GtkTreeView-drag-and-drop)
/// interfaces.
/// 
/// # GtkTreeStore as GtkBuildable
/// 
/// The GtkTreeStore implementation of the `GtkBuildable` interface allows
/// to specify the model columns with a <columns> element that may contain
/// multiple <column> elements, each specifying one model column. The “type”
/// attribute specifies the data type for the column.
/// 
/// An example of a UI Definition fragment for a tree store:
/// ```
/// <object class="GtkTreeStore">
///   <columns>
///     <column type="gchararray"/>
///     <column type="gchararray"/>
///     <column type="gint"/>
///   </columns>
/// </object>
/// ```
/// 
public struct TreeStoreRef: TreeStoreProtocol {
    /// Untyped pointer to the underlying `GtkTreeStore` instance.
    /// For type-safe access, use the generated, typed pointer `tree_store_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension TreeStoreRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkTreeStore>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `TreeStoreProtocol`
    init<T: TreeStoreProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    
    // *** new() is not available because it has a varargs (...) parameter!


    /// Non vararg creation function.  Used primarily by language bindings.
    init(nColumns n_columns: CInt, types: UnsafeMutablePointer<GType>) {
        let rv = gtk_tree_store_newv(gint(n_columns), cast(types))
        self.init(cast(rv))
    }
    /// Non vararg creation function.  Used primarily by language bindings.
    static func treeStoreNewv(nColumns n_columns: CInt, types: UnsafeMutablePointer<GType>) -> TreeStoreRef! {
        let rv = gtk_tree_store_newv(gint(n_columns), cast(types))
        return rv.map { TreeStoreRef(cast($0)) }
    }
}

/// The `TreeStore` type acts as a reference-counted owner of an underlying `GtkTreeStore` instance.
/// It provides the methods that can operate on this data type through `TreeStoreProtocol` conformance.
/// Use `TreeStore` as a strong reference or owner of a `GtkTreeStore` instance.
///
/// The `GtkTreeStore` object is a list model for use with a `GtkTreeView`
/// widget.  It implements the `GtkTreeModel` interface, and consequentially,
/// can use all of the methods available there.  It also implements the
/// `GtkTreeSortable` interface so it can be sorted by the view.  Finally,
/// it also implements the tree
/// [drag and drop](#gtk3-GtkTreeView-drag-and-drop)
/// interfaces.
/// 
/// # GtkTreeStore as GtkBuildable
/// 
/// The GtkTreeStore implementation of the `GtkBuildable` interface allows
/// to specify the model columns with a <columns> element that may contain
/// multiple <column> elements, each specifying one model column. The “type”
/// attribute specifies the data type for the column.
/// 
/// An example of a UI Definition fragment for a tree store:
/// ```
/// <object class="GtkTreeStore">
///   <columns>
///     <column type="gchararray"/>
///     <column type="gchararray"/>
///     <column type="gint"/>
///   </columns>
/// </object>
/// ```
/// 
open class TreeStore: GLibObject.Object, TreeStoreProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `TreeStore` instance.
    public init(_ op: UnsafeMutablePointer<GtkTreeStore>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `TreeStoreProtocol`
    /// Will retain `GtkTreeStore`.
    public convenience init<T: TreeStoreProtocol>(_ other: T) {
        self.init(cast(other.tree_store_ptr))
        g_object_ref(cast(tree_store_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkTreeStore.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkTreeStore.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkTreeStore.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkTreeStore>(opaquePointer))
    }


    // *** new() is not available because it has a varargs (...) parameter!


    /// Non vararg creation function.  Used primarily by language bindings.
    public convenience init(nColumns n_columns: CInt, types: UnsafeMutablePointer<GType>) {
        let rv = gtk_tree_store_newv(gint(n_columns), cast(types))
        self.init(cast(rv))
    }

    /// Non vararg creation function.  Used primarily by language bindings.
    public static func treeStoreNewv(nColumns n_columns: CInt, types: UnsafeMutablePointer<GType>) -> TreeStore! {
        let rv = gtk_tree_store_newv(gint(n_columns), cast(types))
        return rv.map { TreeStore(cast($0)) }
    }

}

// MARK: - no TreeStore properties

public enum TreeStoreSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

public extension TreeStoreProtocol {
    /// Connect a `TreeStoreSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: TreeStoreSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(tree_store_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension TreeStoreProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeStore` instance.
    var tree_store_ptr: UnsafeMutablePointer<GtkTreeStore> { return ptr.assumingMemoryBound(to: GtkTreeStore.self) }

    /// Appends a new row to `tree_store`.  If `parent` is non-`nil`, then it will append the
    /// new row after the last child of `parent`, otherwise it will append a row to
    /// the top level.  `iter` will be changed to point to this new row.  The row will
    /// be empty after this function is called.  To fill in values, you need to call
    /// `gtk_tree_store_set()` or `gtk_tree_store_set_value()`.
    func append(iter: TreeIterProtocol, parent: TreeIterProtocol) {
        gtk_tree_store_append(cast(tree_store_ptr), cast(iter.ptr), cast(parent.ptr))
    
    }

    /// Removes all rows from `tree_store`
    func clear() {
        gtk_tree_store_clear(cast(tree_store_ptr))
    
    }

    /// Creates a new row at `position`.  If parent is non-`nil`, then the row will be
    /// made a child of `parent`.  Otherwise, the row will be created at the toplevel.
    /// If `position` is -1 or is larger than the number of rows at that level, then
    /// the new row will be inserted to the end of the list.  `iter` will be changed
    /// to point to this new row.  The row will be empty after this function is
    /// called.  To fill in values, you need to call `gtk_tree_store_set()` or
    /// `gtk_tree_store_set_value()`.
    func insert(iter: TreeIterProtocol, parent: TreeIterProtocol, position: CInt) {
        gtk_tree_store_insert(cast(tree_store_ptr), cast(iter.ptr), cast(parent.ptr), gint(position))
    
    }

    /// Inserts a new row after `sibling`.  If `sibling` is `nil`, then the row will be
    /// prepended to `parent` ’s children.  If `parent` and `sibling` are `nil`, then
    /// the row will be prepended to the toplevel.  If both `sibling` and `parent` are
    /// set, then `parent` must be the parent of `sibling`.  When `sibling` is set,
    /// `parent` is optional.
    /// 
    /// `iter` will be changed to point to this new row.  The row will be empty after
    /// this function is called.  To fill in values, you need to call
    /// `gtk_tree_store_set()` or `gtk_tree_store_set_value()`.
    func insertAfter(iter: TreeIterProtocol, parent: TreeIterProtocol, sibling: TreeIterProtocol) {
        gtk_tree_store_insert_after(cast(tree_store_ptr), cast(iter.ptr), cast(parent.ptr), cast(sibling.ptr))
    
    }

    /// Inserts a new row before `sibling`.  If `sibling` is `nil`, then the row will
    /// be appended to `parent` ’s children.  If `parent` and `sibling` are `nil`, then
    /// the row will be appended to the toplevel.  If both `sibling` and `parent` are
    /// set, then `parent` must be the parent of `sibling`.  When `sibling` is set,
    /// `parent` is optional.
    /// 
    /// `iter` will be changed to point to this new row.  The row will be empty after
    /// this function is called.  To fill in values, you need to call
    /// `gtk_tree_store_set()` or `gtk_tree_store_set_value()`.
    func insertBefore(iter: TreeIterProtocol, parent: TreeIterProtocol, sibling: TreeIterProtocol) {
        gtk_tree_store_insert_before(cast(tree_store_ptr), cast(iter.ptr), cast(parent.ptr), cast(sibling.ptr))
    
    }


    // *** insertWithValues() is not available because it has a varargs (...) parameter!


    /// A variant of `gtk_tree_store_insert_with_values()` which takes
    /// the columns and values as two arrays, instead of varargs.  This
    /// function is mainly intended for language bindings.
    func insertWithValuesv(iter: TreeIterProtocol, parent: TreeIterProtocol, position: CInt, columns: UnsafeMutablePointer<CInt>, values: UnsafeMutablePointer<GValue>, nValues n_values: CInt) {
        gtk_tree_store_insert_with_valuesv(cast(tree_store_ptr), cast(iter.ptr), cast(parent.ptr), gint(position), cast(columns), cast(values), gint(n_values))
    
    }

    /// Returns `true` if `iter` is an ancestor of `descendant`.  That is, `iter` is the
    /// parent (or grandparent or great-grandparent) of `descendant`.
    func isAncestor(iter: TreeIterProtocol, descendant: TreeIterProtocol) -> Bool {
        let rv = gtk_tree_store_is_ancestor(cast(tree_store_ptr), cast(iter.ptr), cast(descendant.ptr))
        return Bool(rv != 0)
    }

    /// Returns the depth of `iter`.  This will be 0 for anything on the root level, 1
    /// for anything down a level, etc.
    func iterDepth(iter: TreeIterProtocol) -> CInt {
        let rv = gtk_tree_store_iter_depth(cast(tree_store_ptr), cast(iter.ptr))
        return CInt(rv)
    }

    /// WARNING: This function is slow. Only use it for debugging and/or testing
    /// purposes.
    /// 
    /// Checks if the given iter is a valid iter for this `GtkTreeStore`.
    func iterIsValid(iter: TreeIterProtocol) -> Bool {
        let rv = gtk_tree_store_iter_is_valid(cast(tree_store_ptr), cast(iter.ptr))
        return Bool(rv != 0)
    }

    /// Moves `iter` in `tree_store` to the position after `position`. `iter` and
    /// `position` should be in the same level. Note that this function only
    /// works with unsorted stores. If `position` is `nil`, `iter` will be moved
    /// to the start of the level.
    func moveAfter(iter: TreeIterProtocol, position: TreeIterProtocol) {
        gtk_tree_store_move_after(cast(tree_store_ptr), cast(iter.ptr), cast(position.ptr))
    
    }

    /// Moves `iter` in `tree_store` to the position before `position`. `iter` and
    /// `position` should be in the same level. Note that this function only
    /// works with unsorted stores. If `position` is `nil`, `iter` will be
    /// moved to the end of the level.
    func moveBefore(iter: TreeIterProtocol, position: TreeIterProtocol) {
        gtk_tree_store_move_before(cast(tree_store_ptr), cast(iter.ptr), cast(position.ptr))
    
    }

    /// Prepends a new row to `tree_store`.  If `parent` is non-`nil`, then it will prepend
    /// the new row before the first child of `parent`, otherwise it will prepend a row
    /// to the top level.  `iter` will be changed to point to this new row.  The row
    /// will be empty after this function is called.  To fill in values, you need to
    /// call `gtk_tree_store_set()` or `gtk_tree_store_set_value()`.
    func prepend(iter: TreeIterProtocol, parent: TreeIterProtocol) {
        gtk_tree_store_prepend(cast(tree_store_ptr), cast(iter.ptr), cast(parent.ptr))
    
    }

    /// Removes `iter` from `tree_store`.  After being removed, `iter` is set to the
    /// next valid row at that level, or invalidated if it previously pointed to the
    /// last one.
    func remove(iter: TreeIterProtocol) -> Bool {
        let rv = gtk_tree_store_remove(cast(tree_store_ptr), cast(iter.ptr))
        return Bool(rv != 0)
    }

    /// Reorders the children of `parent` in `tree_store` to follow the order
    /// indicated by `new_order`. Note that this function only works with
    /// unsorted stores.
    func reorder(parent: TreeIterProtocol, newOrder new_order: UnsafeMutablePointer<CInt>) {
        gtk_tree_store_reorder(cast(tree_store_ptr), cast(parent.ptr), cast(new_order))
    
    }


    // *** set() is not available because it has a varargs (...) parameter!


    /// This function is meant primarily for `GObjects` that inherit from
    /// `GtkTreeStore`, and should only be used when constructing a new
    /// `GtkTreeStore`.  It will not function after a row has been added,
    /// or a method on the `GtkTreeModel` interface is called.
    func setColumnTypes(nColumns n_columns: CInt, types: UnsafeMutablePointer<GType>) {
        gtk_tree_store_set_column_types(cast(tree_store_ptr), gint(n_columns), cast(types))
    
    }

    /// See `gtk_tree_store_set()`; this version takes a va_list for
    /// use by language bindings.
    func setValist(iter: TreeIterProtocol, varArgs var_args: CVaListPointer) {
        gtk_tree_store_set_valist(cast(tree_store_ptr), cast(iter.ptr), var_args)
    
    }

    /// Sets the data in the cell specified by `iter` and `column`.
    /// The type of `value` must be convertible to the type of the
    /// column.
    func setValue(iter: TreeIterProtocol, column: CInt, value: GLibObject.ValueProtocol) {
        gtk_tree_store_set_value(cast(tree_store_ptr), cast(iter.ptr), gint(column), cast(value.ptr))
    
    }

    /// A variant of `gtk_tree_store_set_valist()` which takes
    /// the columns and values as two arrays, instead of varargs.  This
    /// function is mainly intended for language bindings or in case
    /// the number of columns to change is not known until run-time.
    func setValuesv(iter: TreeIterProtocol, columns: UnsafeMutablePointer<CInt>, values: UnsafeMutablePointer<GValue>, nValues n_values: CInt) {
        gtk_tree_store_set_valuesv(cast(tree_store_ptr), cast(iter.ptr), cast(columns), cast(values), gint(n_values))
    
    }

    /// Swaps `a` and `b` in the same level of `tree_store`. Note that this function
    /// only works with unsorted stores.
    func swap(a: TreeIterProtocol, b: TreeIterProtocol) {
        gtk_tree_store_swap(cast(tree_store_ptr), cast(a.ptr), cast(b.ptr))
    
    }
}



// MARK: - TreeView Class

/// The `TreeViewProtocol` protocol exposes the methods and properties of an underlying `GtkTreeView` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeView`.
/// Alternatively, use `TreeViewRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// Widget that displays any object that implements the `GtkTreeModel` interface.
/// 
/// Please refer to the
/// [tree widget conceptual overview](#TreeWidget)
/// for an overview of all the objects and data types related
/// to the tree widget and how they work together.
/// 
/// Several different coordinate systems are exposed in the GtkTreeView API.
/// These are:
/// 
/// ![](tree-view-coordinates.png)
/// 
/// Coordinate systems in GtkTreeView API:
/// 
/// - Widget coordinates: Coordinates relative to the widget (usually `widget->window`).
/// 
/// - Bin window coordinates: Coordinates relative to the window that GtkTreeView renders to.
/// 
/// - Tree coordinates: Coordinates relative to the entire scrollable area of GtkTreeView. These
///   coordinates start at (0, 0) for row 0 of the tree.
/// 
/// Several functions are available for converting between the different
/// coordinate systems.  The most common translations are between widget and bin
/// window coordinates and between bin window and tree coordinates. For the
/// former you can use `gtk_tree_view_convert_widget_to_bin_window_coords()`
/// (and vice versa), for the latter `gtk_tree_view_convert_bin_window_to_tree_coords()`
/// (and vice versa).
/// 
/// # GtkTreeView as GtkBuildable
/// 
/// The GtkTreeView implementation of the GtkBuildable interface accepts
/// `GtkTreeViewColumn` objects as <child> elements and exposes the internal
/// `GtkTreeSelection` in UI definitions.
/// 
/// An example of a UI definition fragment with GtkTreeView:
/// ```
/// <object class="GtkTreeView" id="treeview">
///   <property name="model">liststore1</property>
///   <child>
///     <object class="GtkTreeViewColumn" id="test-column">
///       <property name="title">Test</property>
///       <child>
///         <object class="GtkCellRendererText" id="test-renderer"/>
///         <attributes>
///           <attribute name="text">1</attribute>
///         </attributes>
///       </child>
///     </object>
///   </child>
///   <child internal-child="selection">
///     <object class="GtkTreeSelection" id="selection">
///       <signal name="changed" handler="on_treeview_selection_changed"/>
///     </object>
///   </child>
/// </object>
/// ```
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// treeview.view
/// ├── header
/// │   ├── <column header>
/// ┊   ┊
/// │   ╰── <column header>
/// │
/// ╰── [rubberband]
/// ```
/// 
/// GtkTreeView has a main CSS node with name treeview and style class .view.
/// It has a subnode with name header, which is the parent for all the column
/// header widgets' CSS nodes.
/// For rubberband selection, a subnode with name rubberband is used.
public protocol TreeViewProtocol: ContainerProtocol, ScrollableProtocol {
    /// Untyped pointer to the underlying `GtkTreeView` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkTreeView` instance.
    var tree_view_ptr: UnsafeMutablePointer<GtkTreeView> { get }
}

/// The `TreeViewRef` type acts as a lightweight Swift reference to an underlying `GtkTreeView` instance.
/// It exposes methods that can operate on this data type through `TreeViewProtocol` conformance.
/// Use `TreeViewRef` only as an `unowned` reference to an existing `GtkTreeView` instance.
///
/// Widget that displays any object that implements the `GtkTreeModel` interface.
/// 
/// Please refer to the
/// [tree widget conceptual overview](#TreeWidget)
/// for an overview of all the objects and data types related
/// to the tree widget and how they work together.
/// 
/// Several different coordinate systems are exposed in the GtkTreeView API.
/// These are:
/// 
/// ![](tree-view-coordinates.png)
/// 
/// Coordinate systems in GtkTreeView API:
/// 
/// - Widget coordinates: Coordinates relative to the widget (usually `widget->window`).
/// 
/// - Bin window coordinates: Coordinates relative to the window that GtkTreeView renders to.
/// 
/// - Tree coordinates: Coordinates relative to the entire scrollable area of GtkTreeView. These
///   coordinates start at (0, 0) for row 0 of the tree.
/// 
/// Several functions are available for converting between the different
/// coordinate systems.  The most common translations are between widget and bin
/// window coordinates and between bin window and tree coordinates. For the
/// former you can use `gtk_tree_view_convert_widget_to_bin_window_coords()`
/// (and vice versa), for the latter `gtk_tree_view_convert_bin_window_to_tree_coords()`
/// (and vice versa).
/// 
/// # GtkTreeView as GtkBuildable
/// 
/// The GtkTreeView implementation of the GtkBuildable interface accepts
/// `GtkTreeViewColumn` objects as <child> elements and exposes the internal
/// `GtkTreeSelection` in UI definitions.
/// 
/// An example of a UI definition fragment with GtkTreeView:
/// ```
/// <object class="GtkTreeView" id="treeview">
///   <property name="model">liststore1</property>
///   <child>
///     <object class="GtkTreeViewColumn" id="test-column">
///       <property name="title">Test</property>
///       <child>
///         <object class="GtkCellRendererText" id="test-renderer"/>
///         <attributes>
///           <attribute name="text">1</attribute>
///         </attributes>
///       </child>
///     </object>
///   </child>
///   <child internal-child="selection">
///     <object class="GtkTreeSelection" id="selection">
///       <signal name="changed" handler="on_treeview_selection_changed"/>
///     </object>
///   </child>
/// </object>
/// ```
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// treeview.view
/// ├── header
/// │   ├── <column header>
/// ┊   ┊
/// │   ╰── <column header>
/// │
/// ╰── [rubberband]
/// ```
/// 
/// GtkTreeView has a main CSS node with name treeview and style class .view.
/// It has a subnode with name header, which is the parent for all the column
/// header widgets' CSS nodes.
/// For rubberband selection, a subnode with name rubberband is used.
public struct TreeViewRef: TreeViewProtocol {
    /// Untyped pointer to the underlying `GtkTreeView` instance.
    /// For type-safe access, use the generated, typed pointer `tree_view_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension TreeViewRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkTreeView>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `TreeViewProtocol`
    init<T: TreeViewProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkTreeView` widget.
    init() {
        let rv = gtk_tree_view_new()
        self.init(cast(rv))
    }

    /// Creates a new `GtkTreeView` widget with the model initialized to `model`.
    init(model: TreeModelProtocol) {
        let rv = gtk_tree_view_new_with_model(cast(model.ptr))
        self.init(cast(rv))
    }
    /// Creates a new `GtkTreeView` widget with the model initialized to `model`.
    static func newWith(model: TreeModelProtocol) -> TreeViewRef! {
        let rv = gtk_tree_view_new_with_model(cast(model.ptr))
        return rv.map { TreeViewRef(cast($0)) }
    }
}

/// The `TreeView` type acts as a reference-counted owner of an underlying `GtkTreeView` instance.
/// It provides the methods that can operate on this data type through `TreeViewProtocol` conformance.
/// Use `TreeView` as a strong reference or owner of a `GtkTreeView` instance.
///
/// Widget that displays any object that implements the `GtkTreeModel` interface.
/// 
/// Please refer to the
/// [tree widget conceptual overview](#TreeWidget)
/// for an overview of all the objects and data types related
/// to the tree widget and how they work together.
/// 
/// Several different coordinate systems are exposed in the GtkTreeView API.
/// These are:
/// 
/// ![](tree-view-coordinates.png)
/// 
/// Coordinate systems in GtkTreeView API:
/// 
/// - Widget coordinates: Coordinates relative to the widget (usually `widget->window`).
/// 
/// - Bin window coordinates: Coordinates relative to the window that GtkTreeView renders to.
/// 
/// - Tree coordinates: Coordinates relative to the entire scrollable area of GtkTreeView. These
///   coordinates start at (0, 0) for row 0 of the tree.
/// 
/// Several functions are available for converting between the different
/// coordinate systems.  The most common translations are between widget and bin
/// window coordinates and between bin window and tree coordinates. For the
/// former you can use `gtk_tree_view_convert_widget_to_bin_window_coords()`
/// (and vice versa), for the latter `gtk_tree_view_convert_bin_window_to_tree_coords()`
/// (and vice versa).
/// 
/// # GtkTreeView as GtkBuildable
/// 
/// The GtkTreeView implementation of the GtkBuildable interface accepts
/// `GtkTreeViewColumn` objects as <child> elements and exposes the internal
/// `GtkTreeSelection` in UI definitions.
/// 
/// An example of a UI definition fragment with GtkTreeView:
/// ```
/// <object class="GtkTreeView" id="treeview">
///   <property name="model">liststore1</property>
///   <child>
///     <object class="GtkTreeViewColumn" id="test-column">
///       <property name="title">Test</property>
///       <child>
///         <object class="GtkCellRendererText" id="test-renderer"/>
///         <attributes>
///           <attribute name="text">1</attribute>
///         </attributes>
///       </child>
///     </object>
///   </child>
///   <child internal-child="selection">
///     <object class="GtkTreeSelection" id="selection">
///       <signal name="changed" handler="on_treeview_selection_changed"/>
///     </object>
///   </child>
/// </object>
/// ```
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// treeview.view
/// ├── header
/// │   ├── <column header>
/// ┊   ┊
/// │   ╰── <column header>
/// │
/// ╰── [rubberband]
/// ```
/// 
/// GtkTreeView has a main CSS node with name treeview and style class .view.
/// It has a subnode with name header, which is the parent for all the column
/// header widgets' CSS nodes.
/// For rubberband selection, a subnode with name rubberband is used.
open class TreeView: Container, TreeViewProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `TreeView` instance.
    public init(_ op: UnsafeMutablePointer<GtkTreeView>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `TreeViewProtocol`
    /// Will retain `GtkTreeView`.
    public convenience init<T: TreeViewProtocol>(_ other: T) {
        self.init(cast(other.tree_view_ptr))
        g_object_ref(cast(tree_view_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkTreeView.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkTreeView.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkTreeView.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkTreeView>(opaquePointer))
    }

    /// Creates a new `GtkTreeView` widget.
    public convenience init() {
        let rv = gtk_tree_view_new()
        self.init(cast(rv))
    }

    /// Creates a new `GtkTreeView` widget with the model initialized to `model`.
    public convenience init(model: TreeModelProtocol) {
        let rv = gtk_tree_view_new_with_model(cast(model.ptr))
        self.init(cast(rv))
    }

    /// Creates a new `GtkTreeView` widget with the model initialized to `model`.
    public static func newWith(model: TreeModelProtocol) -> TreeView! {
        let rv = gtk_tree_view_new_with_model(cast(model.ptr))
        return rv.map { TreeView(cast($0)) }
    }

}

public enum TreeViewPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    /// The activate-on-single-click property specifies whether the "row-activated" signal
    /// will be emitted after a single click.
    case activateOnSingleClick = "activate-on-single-click"
    case appPaintable = "app-paintable"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case compositeChild = "composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case enableGridLines = "enable-grid-lines"
    case enableSearch = "enable-search"
    case enableTreeLines = "enable-tree-lines"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    case expanderColumn = "expander-column"
    /// Setting the `fixed`-height-mode property to `true` speeds up
    /// `GtkTreeView` by assuming that all rows have the same height.
    /// Only enable this option if all rows are the same height.
    /// Please see `gtk_tree_view_set_fixed_height_mode()` for more
    /// information on this option.
    case fixedHeightMode = "fixed-height-mode"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case headersClickable = "headers-clickable"
    case headersVisible = "headers-visible"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// Enables or disables the hover expansion mode of `tree_view`.
    /// Hover expansion makes rows expand or collapse if the pointer moves
    /// over them.
    /// 
    /// This mode is primarily intended for treeviews in popups, e.g.
    /// in `GtkComboBox` or `GtkEntryCompletion`.
    case hoverExpand = "hover-expand"
    /// Enables or disables the hover selection mode of `tree_view`.
    /// Hover selection makes the selected row follow the pointer.
    /// Currently, this works only for the selection modes
    /// `GTK_SELECTION_SINGLE` and `GTK_SELECTION_BROWSE`.
    /// 
    /// This mode is primarily intended for treeviews in popups, e.g.
    /// in `GtkComboBox` or `GtkEntryCompletion`.
    case hoverSelection = "hover-selection"
    case isFocus = "is-focus"
    /// Extra indentation for each level.
    case levelIndentation = "level-indentation"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case model = "model"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case reorderable = "reorderable"
    case resizeMode = "resize-mode"
    case rubberBanding = "rubber-banding"
    /// Sets a hint to the theme to draw rows in alternating colors.
    ///
    /// **rules-hint is deprecated:**
    /// The theme is responsible for drawing rows
    ///   using zebra striping
    case rulesHint = "rules-hint"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case searchColumn = "search-column"
    case sensitive = "sensitive"
    /// `true` if the view has expanders.
    case showExpanders = "show-expanders"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    case tooltipColumn = "tooltip-column"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
}

public extension TreeViewProtocol {
    /// Bind a `TreeViewPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TreeViewPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(tree_view_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum TreeViewSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    case add = "add"
    /// The `button`-press-event signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button`-release-event signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child`-notify signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The number of columns of the treeview has changed.
    case columnsChanged = "columns-changed"
    /// The `composited`-changed signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure`-event signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// The position of the cursor (focused cell) has changed.
    case cursorChanged = "cursor-changed"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete`-event signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy`-event signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction`-changed signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag`-begin signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag`-data-delete signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag`-data-get signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag`-data-received signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag`-drop signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag`-drop signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag`-data-received handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag`-end signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag`-begin.
    case dragEnd = "drag-end"
    /// The `drag`-failed signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag`-leave signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag`-motion, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag`-leave signal is also emitted before the
    /// `drag`-drop signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag`-motion signal handler.
    case dragLeave = "drag-leave"
    /// The `drag`-motion signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag`-data-received
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag`-leave and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enter`-notify-event will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key`-press-event) and finally a generic
    /// `GtkWidget::event`-after signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event`-after will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case expandCollapseCursorRow = "expand-collapse-cursor-row"
    case focus = "focus"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The `focus`-in-event signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus`-out-event signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab`-notify signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy`-changed signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key`-press-event signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key`-release-event signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `leave`-notify-event will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map`-event will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map`-event signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion`-notify-event signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    /// The `GtkTreeView::move`-cursor signal is a [keybinding
    /// signal](#GtkBindingSignal) which gets emitted when the user
    /// presses one of the cursor keys.
    /// 
    /// Applications should not connect to it, but may emit it with
    /// `g_signal_emit_by_name()` if they need to control the cursor
    /// programmatically. In contrast to `gtk_tree_view_set_cursor()` and
    /// `gtk_tree_view_set_cursor_on_cell()` when moving horizontally
    /// `GtkTreeView::move`-cursor does not reset the current selection.
    case moveCursor = "move-cursor"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent`-set signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The `property`-notify-event signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has`-tooltip is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// The "row-activated" signal is emitted when the method
    /// `gtk_tree_view_row_activated()` is called, when the user double
    /// clicks a treeview row with the "activate-on-single-click"
    /// property set to `false`, or when the user single clicks a row when
    /// the "activate-on-single-click" property set to `true`. It is also
    /// emitted when a non-editable row is selected and one of the keys:
    /// Space, Shift+Space, Return or Enter is pressed.
    /// 
    /// For selection handling refer to the
    /// [tree widget conceptual overview](#TreeWidget)
    /// as well as `GtkTreeSelection`.
    case rowActivated = "row-activated"
    /// The given row has been collapsed (child nodes are hidden).
    case rowCollapsed = "row-collapsed"
    /// The given row has been expanded (child nodes are shown).
    case rowExpanded = "row-expanded"
    /// The `screen`-changed signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll`-event signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    case selectAll = "select-all"
    case selectCursorParent = "select-cursor-parent"
    case selectCursorRow = "select-cursor-row"
    /// The `selection`-clear-event signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection`-request-event signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    case startInteractiveSearch = "start-interactive-search"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The `state`-changed signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state`-flags-changed signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style`-set signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style`-updated signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style`-updated signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    /// The given row is about to be collapsed (hide its children nodes). Use this
    /// signal if you need to control the collapsibility of individual rows.
    case testCollapseRow = "test-collapse-row"
    /// The given row is about to be expanded (show its children nodes). Use this
    /// signal if you need to control the expandability of individual rows.
    case testExpandRow = "test-expand-row"
    case toggleCursorRow = "toggle-cursor-row"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap`-event signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    case unselectAll = "unselect-all"
    /// The `visibility`-notify-event will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    /// The `window`-state-event will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    /// The activate-on-single-click property specifies whether the "row-activated" signal
    /// will be emitted after a single click.
    case notifyActivateOnSingleClick = "notify::activate-on-single-click"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyEnableGridLines = "notify::enable-grid-lines"
    case notifyEnableSearch = "notify::enable-search"
    case notifyEnableTreeLines = "notify::enable-tree-lines"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    case notifyExpanderColumn = "notify::expander-column"
    /// Setting the `fixed`-height-mode property to `true` speeds up
    /// `GtkTreeView` by assuming that all rows have the same height.
    /// Only enable this option if all rows are the same height.
    /// Please see `gtk_tree_view_set_fixed_height_mode()` for more
    /// information on this option.
    case notifyFixedHeightMode = "notify::fixed-height-mode"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query`-tooltip on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query`-tooltip to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeadersClickable = "notify::headers-clickable"
    case notifyHeadersVisible = "notify::headers-visible"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// Enables or disables the hover expansion mode of `tree_view`.
    /// Hover expansion makes rows expand or collapse if the pointer moves
    /// over them.
    /// 
    /// This mode is primarily intended for treeviews in popups, e.g.
    /// in `GtkComboBox` or `GtkEntryCompletion`.
    case notifyHoverExpand = "notify::hover-expand"
    /// Enables or disables the hover selection mode of `tree_view`.
    /// Hover selection makes the selected row follow the pointer.
    /// Currently, this works only for the selection modes
    /// `GTK_SELECTION_SINGLE` and `GTK_SELECTION_BROWSE`.
    /// 
    /// This mode is primarily intended for treeviews in popups, e.g.
    /// in `GtkComboBox` or `GtkEntryCompletion`.
    case notifyHoverSelection = "notify::hover-selection"
    case notifyIsFocus = "notify::is-focus"
    /// Extra indentation for each level.
    case notifyLevelIndentation = "notify::level-indentation"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyModel = "notify::model"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyReorderable = "notify::reorderable"
    case notifyResizeMode = "notify::resize-mode"
    case notifyRubberBanding = "notify::rubber-banding"
    /// Sets a hint to the theme to draw rows in alternating colors.
    ///
    /// **rules-hint is deprecated:**
    /// The theme is responsible for drawing rows
    ///   using zebra striping
    case notifyRulesHint = "notify::rules-hint"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySearchColumn = "notify::search-column"
    case notifySensitive = "notify::sensitive"
    /// `true` if the view has expanders.
    case notifyShowExpanders = "notify::show-expanders"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    case notifyTooltipColumn = "notify::tooltip-column"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has`-tooltip
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query`-tooltip in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip`-text and `GtkWidget:tooltip`-markup
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
}

public extension TreeViewProtocol {
    /// Connect a `TreeViewSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: TreeViewSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(tree_view_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension TreeViewProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeView` instance.
    var tree_view_ptr: UnsafeMutablePointer<GtkTreeView> { return ptr.assumingMemoryBound(to: GtkTreeView.self) }

    /// Appends `column` to the list of columns. If `tree_view` has “fixed_height”
    /// mode enabled, then `column` must have its “sizing” property set to be
    /// GTK_TREE_VIEW_COLUMN_FIXED.
    func append(column: TreeViewColumnProtocol) -> CInt {
        let rv = gtk_tree_view_append_column(cast(tree_view_ptr), cast(column.ptr))
        return CInt(rv)
    }

    /// Recursively collapses all visible, expanded nodes in `tree_view`.
    func collapseAll() {
        gtk_tree_view_collapse_all(cast(tree_view_ptr))
    
    }

    /// Collapses a row (hides its child rows, if they exist).
    func collapseRow(path: TreePathProtocol) -> Bool {
        let rv = gtk_tree_view_collapse_row(cast(tree_view_ptr), cast(path.ptr))
        return Bool(rv != 0)
    }

    /// Resizes all columns to their optimal width. Only works after the
    /// treeview has been realized.
    func columnsAutosize() {
        gtk_tree_view_columns_autosize(cast(tree_view_ptr))
    
    }

    /// Converts bin_window coordinates to coordinates for the
    /// tree (the full scrollable area of the tree).
    func convertBinWindowToTreeCoords(bx: CInt, by: CInt, tx: UnsafeMutablePointer<CInt>, ty: UnsafeMutablePointer<CInt>) {
        gtk_tree_view_convert_bin_window_to_tree_coords(cast(tree_view_ptr), gint(bx), gint(by), cast(tx), cast(ty))
    
    }

    /// Converts bin_window coordinates (see `gtk_tree_view_get_bin_window()`)
    /// to widget relative coordinates.
    func convertBinWindowToWidgetCoords(bx: CInt, by: CInt, wx: UnsafeMutablePointer<CInt>, wy: UnsafeMutablePointer<CInt>) {
        gtk_tree_view_convert_bin_window_to_widget_coords(cast(tree_view_ptr), gint(bx), gint(by), cast(wx), cast(wy))
    
    }

    /// Converts tree coordinates (coordinates in full scrollable area of the tree)
    /// to bin_window coordinates.
    func convertTreeToBinWindowCoords(tx: CInt, ty: CInt, bx: UnsafeMutablePointer<CInt>, by: UnsafeMutablePointer<CInt>) {
        gtk_tree_view_convert_tree_to_bin_window_coords(cast(tree_view_ptr), gint(tx), gint(ty), cast(bx), cast(by))
    
    }

    /// Converts tree coordinates (coordinates in full scrollable area of the tree)
    /// to widget coordinates.
    func convertTreeToWidgetCoords(tx: CInt, ty: CInt, wx: UnsafeMutablePointer<CInt>, wy: UnsafeMutablePointer<CInt>) {
        gtk_tree_view_convert_tree_to_widget_coords(cast(tree_view_ptr), gint(tx), gint(ty), cast(wx), cast(wy))
    
    }

    /// Converts widget coordinates to coordinates for the bin_window
    /// (see `gtk_tree_view_get_bin_window()`).
    func convertWidgetToBinWindowCoords(wx: CInt, wy: CInt, bx: UnsafeMutablePointer<CInt>, by: UnsafeMutablePointer<CInt>) {
        gtk_tree_view_convert_widget_to_bin_window_coords(cast(tree_view_ptr), gint(wx), gint(wy), cast(bx), cast(by))
    
    }

    /// Converts widget coordinates to coordinates for the
    /// tree (the full scrollable area of the tree).
    func convertWidgetToTreeCoords(wx: CInt, wy: CInt, tx: UnsafeMutablePointer<CInt>, ty: UnsafeMutablePointer<CInt>) {
        gtk_tree_view_convert_widget_to_tree_coords(cast(tree_view_ptr), gint(wx), gint(wy), cast(tx), cast(ty))
    
    }

    /// Creates a `cairo_surface_t` representation of the row at `path`.
    /// This image is used for a drag icon.
    func createRowDragIcon(path: TreePathProtocol) -> UnsafeMutablePointer<cairo_surface_t>! {
        let rv = gtk_tree_view_create_row_drag_icon(cast(tree_view_ptr), cast(path.ptr))
        return cast(rv)
    }

    /// Turns `tree_view` into a drop destination for automatic DND. Calling
    /// this method sets `GtkTreeView:reorderable` to `false`.
    func enableModelDragDest(targets: UnsafePointer<GtkTargetEntry>, nTargets n_targets: CInt, actions: Gdk.DragAction) {
        gtk_tree_view_enable_model_drag_dest(cast(tree_view_ptr), cast(targets), gint(n_targets), actions)
    
    }

    /// Turns `tree_view` into a drag source for automatic DND. Calling this
    /// method sets `GtkTreeView:reorderable` to `false`.
    func enableModelDragSource(startButtonMask start_button_mask: Gdk.ModifierType, targets: UnsafePointer<GtkTargetEntry>, nTargets n_targets: CInt, actions: Gdk.DragAction) {
        gtk_tree_view_enable_model_drag_source(cast(tree_view_ptr), start_button_mask, cast(targets), gint(n_targets), actions)
    
    }

    /// Recursively expands all nodes in the `tree_view`.
    func expandAll() {
        gtk_tree_view_expand_all(cast(tree_view_ptr))
    
    }

    /// Opens the row so its children are visible.
    func expandRow(path: TreePathProtocol, openAll open_all: Bool) -> Bool {
        let rv = gtk_tree_view_expand_row(cast(tree_view_ptr), cast(path.ptr), gboolean(open_all ? 1 : 0))
        return Bool(rv != 0)
    }

    /// Expands the row at `path`. This will also expand all parent rows of
    /// `path` as necessary.
    func expandTo(path: TreePathProtocol) {
        gtk_tree_view_expand_to_path(cast(tree_view_ptr), cast(path.ptr))
    
    }

    /// Gets the setting set by `gtk_tree_view_set_activate_on_single_click()`.
    func getActivateOnSingleClick() -> Bool {
        let rv = gtk_tree_view_get_activate_on_single_click(cast(tree_view_ptr))
        return Bool(rv != 0)
    }

    /// Fills the bounding rectangle in bin_window coordinates for the cell at the
    /// row specified by `path` and the column specified by `column`.  If `path` is
    /// `nil`, or points to a node not found in the tree, the `y` and `height` fields of
    /// the rectangle will be filled with 0. If `column` is `nil`, the `x` and `width`
    /// fields will be filled with 0.  The returned rectangle is equivalent to the
    /// `background_area` passed to `gtk_cell_renderer_render()`.  These background
    /// areas tile to cover the entire bin window.  Contrast with the `cell_area`,
    /// returned by `gtk_tree_view_get_cell_area()`, which returns only the cell
    /// itself, excluding surrounding borders and the tree expander area.
    func getBackgroundArea(path: TreePathProtocol, column: TreeViewColumnProtocol, rect: Gdk.RectangleProtocol) {
        gtk_tree_view_get_background_area(cast(tree_view_ptr), cast(path.ptr), cast(column.ptr), cast(rect.ptr))
    
    }

    /// Returns the window that `tree_view` renders to.
    /// This is used primarily to compare to `event->window`
    /// to confirm that the event on `tree_view` is on the right window.
    func getBinWindow() -> UnsafeMutablePointer<GdkWindow>! {
        let rv = gtk_tree_view_get_bin_window(cast(tree_view_ptr))
        return cast(rv)
    }

    /// Fills the bounding rectangle in bin_window coordinates for the cell at the
    /// row specified by `path` and the column specified by `column`.  If `path` is
    /// `nil`, or points to a path not currently displayed, the `y` and `height` fields
    /// of the rectangle will be filled with 0. If `column` is `nil`, the `x` and `width`
    /// fields will be filled with 0.  The sum of all cell rects does not cover the
    /// entire tree; there are extra pixels in between rows, for example. The
    /// returned rectangle is equivalent to the `cell_area` passed to
    /// `gtk_cell_renderer_render()`.  This function is only valid if `tree_view` is
    /// realized.
    func getCellArea(path: TreePathProtocol, column: TreeViewColumnProtocol, rect: Gdk.RectangleProtocol) {
        gtk_tree_view_get_cell_area(cast(tree_view_ptr), cast(path.ptr), cast(column.ptr), cast(rect.ptr))
    
    }

    /// Gets the `GtkTreeViewColumn` at the given position in the `tree_view`.
    func getColumn(n: CInt) -> UnsafeMutablePointer<GtkTreeViewColumn>! {
        let rv = gtk_tree_view_get_column(cast(tree_view_ptr), gint(n))
        return cast(rv)
    }

    /// Returns a `GList` of all the `GtkTreeViewColumn` s currently in `tree_view`.
    /// The returned list must be freed with g_list_free ().
    func getColumns() -> UnsafeMutablePointer<GList>! {
        let rv = gtk_tree_view_get_columns(cast(tree_view_ptr))
        return cast(rv)
    }

    /// Fills in `path` and `focus_column` with the current path and focus column.  If
    /// the cursor isn’t currently set, then *`path` will be `nil`.  If no column
    /// currently has focus, then *`focus_column` will be `nil`.
    /// 
    /// The returned `GtkTreePath` must be freed with `gtk_tree_path_free()` when
    /// you are done with it.
    func getCursor(path: TreePathProtocol, focusColumn focus_column: TreeViewColumnProtocol) {
        gtk_tree_view_get_cursor(cast(tree_view_ptr), cast(path.ptr), cast(focus_column.ptr))
    
    }

    /// Determines the destination row for a given position.  `drag_x` and
    /// `drag_y` are expected to be in widget coordinates.  This function is only
    /// meaningful if `tree_view` is realized.  Therefore this function will always
    /// return `false` if `tree_view` is not realized or does not have a model.
    func getDestRowAtPos(dragX drag_x: CInt, dragY drag_y: CInt, path: TreePathProtocol, pos: UnsafeMutablePointer<GtkTreeViewDropPosition>) -> Bool {
        let rv = gtk_tree_view_get_dest_row_at_pos(cast(tree_view_ptr), gint(drag_x), gint(drag_y), cast(path.ptr), cast(pos))
        return Bool(rv != 0)
    }

    /// Gets information about the row that is highlighted for feedback.
    func getDragDestRow(path: TreePathProtocol, pos: UnsafeMutablePointer<GtkTreeViewDropPosition>) {
        gtk_tree_view_get_drag_dest_row(cast(tree_view_ptr), cast(path.ptr), cast(pos))
    
    }

    /// Returns whether or not the tree allows to start interactive searching
    /// by typing in text.
    func getEnableSearch() -> Bool {
        let rv = gtk_tree_view_get_enable_search(cast(tree_view_ptr))
        return Bool(rv != 0)
    }

    /// Returns whether or not tree lines are drawn in `tree_view`.
    func getEnableTreeLines() -> Bool {
        let rv = gtk_tree_view_get_enable_tree_lines(cast(tree_view_ptr))
        return Bool(rv != 0)
    }

    /// Returns the column that is the current expander column.
    /// This column has the expander arrow drawn next to it.
    func getExpanderColumn() -> UnsafeMutablePointer<GtkTreeViewColumn>! {
        let rv = gtk_tree_view_get_expander_column(cast(tree_view_ptr))
        return cast(rv)
    }

    /// Returns whether fixed height mode is turned on for `tree_view`.
    func getFixedHeightMode() -> Bool {
        let rv = gtk_tree_view_get_fixed_height_mode(cast(tree_view_ptr))
        return Bool(rv != 0)
    }

    /// Returns which grid lines are enabled in `tree_view`.
    func getGridLines() -> GtkTreeViewGridLines {
        let rv = gtk_tree_view_get_grid_lines(cast(tree_view_ptr))
        return rv
    }

    /// Gets the `GtkAdjustment` currently being used for the horizontal aspect.
    ///
    /// **get_hadjustment is deprecated:**
    /// Use gtk_scrollable_get_hadjustment()
    @available(*, deprecated) func getHadjustment() -> UnsafeMutablePointer<GtkAdjustment>! {
        let rv = gtk_tree_view_get_hadjustment(cast(tree_view_ptr))
        return cast(rv)
    }

    /// Returns whether all header columns are clickable.
    func getHeadersClickable() -> Bool {
        let rv = gtk_tree_view_get_headers_clickable(cast(tree_view_ptr))
        return Bool(rv != 0)
    }

    /// Returns `true` if the headers on the `tree_view` are visible.
    func getHeadersVisible() -> Bool {
        let rv = gtk_tree_view_get_headers_visible(cast(tree_view_ptr))
        return Bool(rv != 0)
    }

    /// Returns whether hover expansion mode is turned on for `tree_view`.
    func getHoverExpand() -> Bool {
        let rv = gtk_tree_view_get_hover_expand(cast(tree_view_ptr))
        return Bool(rv != 0)
    }

    /// Returns whether hover selection mode is turned on for `tree_view`.
    func getHoverSelection() -> Bool {
        let rv = gtk_tree_view_get_hover_selection(cast(tree_view_ptr))
        return Bool(rv != 0)
    }

    /// Returns the amount, in pixels, of extra indentation for child levels
    /// in `tree_view`.
    func getLevelIndentation() -> CInt {
        let rv = gtk_tree_view_get_level_indentation(cast(tree_view_ptr))
        return CInt(rv)
    }

    /// Returns the model the `GtkTreeView` is based on.  Returns `nil` if the
    /// model is unset.
    func getModel() -> UnsafeMutablePointer<GtkTreeModel>! {
        let rv = gtk_tree_view_get_model(cast(tree_view_ptr))
        return cast(rv)
    }

    /// Queries the number of columns in the given `tree_view`.
    func getNColumns() -> CUnsignedInt {
        let rv = gtk_tree_view_get_n_columns(cast(tree_view_ptr))
        return CUnsignedInt(rv)
    }

    /// Finds the path at the point (`x`, `y`), relative to bin_window coordinates
    /// (please see `gtk_tree_view_get_bin_window()`).
    /// That is, `x` and `y` are relative to an events coordinates. `x` and `y` must
    /// come from an event on the `tree_view` only where `event->window ==
    /// gtk_tree_view_get_bin_window ()`. It is primarily for
    /// things like popup menus. If `path` is non-`nil`, then it will be filled
    /// with the `GtkTreePath` at that point.  This path should be freed with
    /// `gtk_tree_path_free()`.  If `column` is non-`nil`, then it will be filled
    /// with the column at that point.  `cell_x` and `cell_y` return the coordinates
    /// relative to the cell background (i.e. the `background_area` passed to
    /// `gtk_cell_renderer_render()`).  This function is only meaningful if
    /// `tree_view` is realized.  Therefore this function will always return `false`
    /// if `tree_view` is not realized or does not have a model.
    /// 
    /// For converting widget coordinates (eg. the ones you get from
    /// GtkWidget`query`-tooltip), please see
    /// `gtk_tree_view_convert_widget_to_bin_window_coords()`.
    func getPathAtPos(x: CInt, y: CInt, path: TreePathProtocol, column: TreeViewColumnProtocol, cellX cell_x: UnsafeMutablePointer<CInt>, cellY cell_y: UnsafeMutablePointer<CInt>) -> Bool {
        let rv = gtk_tree_view_get_path_at_pos(cast(tree_view_ptr), gint(x), gint(y), cast(path.ptr), cast(column.ptr), cast(cell_x), cast(cell_y))
        return Bool(rv != 0)
    }

    /// Retrieves whether the user can reorder the tree via drag-and-drop. See
    /// `gtk_tree_view_set_reorderable()`.
    func getReorderable() -> Bool {
        let rv = gtk_tree_view_get_reorderable(cast(tree_view_ptr))
        return Bool(rv != 0)
    }

    /// Returns the current row separator function.
    func getRowSeparatorFunc() -> GtkTreeViewRowSeparatorFunc! {
        let rv = gtk_tree_view_get_row_separator_func(cast(tree_view_ptr))
        return rv
    }

    /// Returns whether rubber banding is turned on for `tree_view`.  If the
    /// selection mode is `GTK_SELECTION_MULTIPLE`, rubber banding will allow the
    /// user to select multiple rows by dragging the mouse.
    func getRubberBanding() -> Bool {
        let rv = gtk_tree_view_get_rubber_banding(cast(tree_view_ptr))
        return Bool(rv != 0)
    }

    /// Gets the setting set by `gtk_tree_view_set_rules_hint()`.
    ///
    /// **get_rules_hint is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func getRulesHint() -> Bool {
        let rv = gtk_tree_view_get_rules_hint(cast(tree_view_ptr))
        return Bool(rv != 0)
    }

    /// Gets the column searched on by the interactive search code.
    func getSearchColumn() -> CInt {
        let rv = gtk_tree_view_get_search_column(cast(tree_view_ptr))
        return CInt(rv)
    }

    /// Returns the `GtkEntry` which is currently in use as interactive search
    /// entry for `tree_view`.  In case the built-in entry is being used, `nil`
    /// will be returned.
    func getSearchEntry() -> UnsafeMutablePointer<GtkEntry>! {
        let rv = gtk_tree_view_get_search_entry(cast(tree_view_ptr))
        return cast(rv)
    }

    /// Returns the compare function currently in use.
    func getSearchEqualFunc() -> GtkTreeViewSearchEqualFunc! {
        let rv = gtk_tree_view_get_search_equal_func(cast(tree_view_ptr))
        return rv
    }

    /// Returns the positioning function currently in use.
    func getSearchPositionFunc() -> GtkTreeViewSearchPositionFunc! {
        let rv = gtk_tree_view_get_search_position_func(cast(tree_view_ptr))
        return rv
    }

    /// Gets the `GtkTreeSelection` associated with `tree_view`.
    func getSelection() -> UnsafeMutablePointer<GtkTreeSelection>! {
        let rv = gtk_tree_view_get_selection(cast(tree_view_ptr))
        return cast(rv)
    }

    /// Returns whether or not expanders are drawn in `tree_view`.
    func getShowExpanders() -> Bool {
        let rv = gtk_tree_view_get_show_expanders(cast(tree_view_ptr))
        return Bool(rv != 0)
    }

    /// Returns the column of `tree_view`’s model which is being used for
    /// displaying tooltips on `tree_view`’s rows.
    func getTooltipColumn() -> CInt {
        let rv = gtk_tree_view_get_tooltip_column(cast(tree_view_ptr))
        return CInt(rv)
    }

    /// This function is supposed to be used in a `GtkWidget::query`-tooltip
    /// signal handler for `GtkTreeView`.  The `x`, `y` and `keyboard_tip` values
    /// which are received in the signal handler, should be passed to this
    /// function without modification.
    /// 
    /// The return value indicates whether there is a tree view row at the given
    /// coordinates (`true`) or not (`false`) for mouse tooltips.  For keyboard
    /// tooltips the row returned will be the cursor row.  When `true`, then any of
    /// `model`, `path` and `iter` which have been provided will be set to point to
    /// that row and the corresponding model.  `x` and `y` will always be converted
    /// to be relative to `tree_view`’s bin_window if `keyboard_tooltip` is `false`.
    func getTooltipContext(x: UnsafeMutablePointer<CInt>, y: UnsafeMutablePointer<CInt>, keyboardTip keyboard_tip: Bool, model: TreeModelProtocol, path: TreePathProtocol, iter: TreeIterProtocol) -> Bool {
        let rv = gtk_tree_view_get_tooltip_context(cast(tree_view_ptr), cast(x), cast(y), gboolean(keyboard_tip ? 1 : 0), cast(model.ptr), cast(path.ptr), cast(iter.ptr))
        return Bool(rv != 0)
    }

    /// Gets the `GtkAdjustment` currently being used for the vertical aspect.
    ///
    /// **get_vadjustment is deprecated:**
    /// Use gtk_scrollable_get_vadjustment()
    @available(*, deprecated) func getVadjustment() -> UnsafeMutablePointer<GtkAdjustment>! {
        let rv = gtk_tree_view_get_vadjustment(cast(tree_view_ptr))
        return cast(rv)
    }

    /// Sets `start_path` and `end_path` to be the first and last visible path.
    /// Note that there may be invisible paths in between.
    /// 
    /// The paths should be freed with `gtk_tree_path_free()` after use.
    func getVisibleRange(startPath start_path: TreePathProtocol, endPath end_path: TreePathProtocol) -> Bool {
        let rv = gtk_tree_view_get_visible_range(cast(tree_view_ptr), cast(start_path.ptr), cast(end_path.ptr))
        return Bool(rv != 0)
    }

    /// Fills `visible_rect` with the currently-visible region of the
    /// buffer, in tree coordinates. Convert to bin_window coordinates with
    /// `gtk_tree_view_convert_tree_to_bin_window_coords()`.
    /// Tree coordinates start at 0,0 for row 0 of the tree, and cover the entire
    /// scrollable area of the tree.
    func get(visibleRect visible_rect: Gdk.RectangleProtocol) {
        gtk_tree_view_get_visible_rect(cast(tree_view_ptr), cast(visible_rect.ptr))
    
    }

    /// This inserts the `column` into the `tree_view` at `position`.  If `position` is
    /// -1, then the column is inserted at the end. If `tree_view` has
    /// “fixed_height” mode enabled, then `column` must have its “sizing” property
    /// set to be GTK_TREE_VIEW_COLUMN_FIXED.
    func insert(column: TreeViewColumnProtocol, position: CInt) -> CInt {
        let rv = gtk_tree_view_insert_column(cast(tree_view_ptr), cast(column.ptr), gint(position))
        return CInt(rv)
    }


    // *** insertColumnWithAttributes() is not available because it has a varargs (...) parameter!


    /// Convenience function that inserts a new column into the `GtkTreeView`
    /// with the given cell renderer and a `GtkTreeCellDataFunc` to set cell renderer
    /// attributes (normally using data from the model). See also
    /// `gtk_tree_view_column_set_cell_data_func()`, `gtk_tree_view_column_pack_start()`.
    /// If `tree_view` has “fixed_height” mode enabled, then the new column will have its
    /// “sizing” property set to be GTK_TREE_VIEW_COLUMN_FIXED.
    func insertColumnWithDataFunc(position: CInt, title: UnsafePointer<gchar>, cell: CellRendererProtocol, func_: @escaping TreeCellDataFunc, data: UnsafeMutableRawPointer, dnotify: @escaping GLib.DestroyNotify) -> CInt {
        let rv = gtk_tree_view_insert_column_with_data_func(cast(tree_view_ptr), gint(position), title, cast(cell.ptr), func_, cast(data), dnotify)
        return CInt(rv)
    }

    /// Determine whether the point (`x`, `y`) in `tree_view` is blank, that is no
    /// cell content nor an expander arrow is drawn at the location. If so, the
    /// location can be considered as the background. You might wish to take
    /// special action on clicks on the background, such as clearing a current
    /// selection, having a custom context menu or starting rubber banding.
    /// 
    /// The `x` and `y` coordinate that are provided must be relative to bin_window
    /// coordinates.  That is, `x` and `y` must come from an event on `tree_view`
    /// where `event->window == gtk_tree_view_get_bin_window ()`.
    /// 
    /// For converting widget coordinates (eg. the ones you get from
    /// GtkWidget`query`-tooltip), please see
    /// `gtk_tree_view_convert_widget_to_bin_window_coords()`.
    /// 
    /// The `path`, `column`, `cell_x` and `cell_y` arguments will be filled in
    /// likewise as for `gtk_tree_view_get_path_at_pos()`.  Please see
    /// `gtk_tree_view_get_path_at_pos()` for more information.
    func isBlankAtPos(x: CInt, y: CInt, path: TreePathProtocol, column: TreeViewColumnProtocol, cellX cell_x: UnsafeMutablePointer<CInt>, cellY cell_y: UnsafeMutablePointer<CInt>) -> Bool {
        let rv = gtk_tree_view_is_blank_at_pos(cast(tree_view_ptr), gint(x), gint(y), cast(path.ptr), cast(column.ptr), cast(cell_x), cast(cell_y))
        return Bool(rv != 0)
    }

    /// Calls `func` on all expanded rows.
    func mapExpandedRows(_ func_: @escaping TreeViewMappingFunc, data: UnsafeMutableRawPointer) {
        gtk_tree_view_map_expanded_rows(cast(tree_view_ptr), func_, cast(data))
    
    }

    /// Moves `column` to be after to `base_column`.  If `base_column` is `nil`, then
    /// `column` is placed in the first position.
    func moveColumnAfter(column: TreeViewColumnProtocol, baseColumn base_column: TreeViewColumnProtocol) {
        gtk_tree_view_move_column_after(cast(tree_view_ptr), cast(column.ptr), cast(base_column.ptr))
    
    }

    /// Removes `column` from `tree_view`.
    func remove(column: TreeViewColumnProtocol) -> CInt {
        let rv = gtk_tree_view_remove_column(cast(tree_view_ptr), cast(column.ptr))
        return CInt(rv)
    }

    /// Activates the cell determined by `path` and `column`.
    func rowActivated(path: TreePathProtocol, column: TreeViewColumnProtocol) {
        gtk_tree_view_row_activated(cast(tree_view_ptr), cast(path.ptr), cast(column.ptr))
    
    }

    /// Returns `true` if the node pointed to by `path` is expanded in `tree_view`.
    func rowExpanded(path: TreePathProtocol) -> Bool {
        let rv = gtk_tree_view_row_expanded(cast(tree_view_ptr), cast(path.ptr))
        return Bool(rv != 0)
    }

    /// Moves the alignments of `tree_view` to the position specified by `column` and
    /// `path`.  If `column` is `nil`, then no horizontal scrolling occurs.  Likewise,
    /// if `path` is `nil` no vertical scrolling occurs.  At a minimum, one of `column`
    /// or `path` need to be non-`nil`.  `row_align` determines where the row is
    /// placed, and `col_align` determines where `column` is placed.  Both are expected
    /// to be between 0.0 and 1.0. 0.0 means left/top alignment, 1.0 means
    /// right/bottom alignment, 0.5 means center.
    /// 
    /// If `use_align` is `false`, then the alignment arguments are ignored, and the
    /// tree does the minimum amount of work to scroll the cell onto the screen.
    /// This means that the cell will be scrolled to the edge closest to its current
    /// position.  If the cell is currently visible on the screen, nothing is done.
    /// 
    /// This function only works if the model is set, and `path` is a valid row on the
    /// model.  If the model changes before the `tree_view` is realized, the centered
    /// path will be modified to reflect this change.
    func scrollToCell(path: TreePathProtocol, column: TreeViewColumnProtocol, useAlign use_align: Bool, rowAlign row_align: gfloat, colAlign col_align: gfloat) {
        gtk_tree_view_scroll_to_cell(cast(tree_view_ptr), cast(path.ptr), cast(column.ptr), gboolean(use_align ? 1 : 0), row_align, col_align)
    
    }

    /// Scrolls the tree view such that the top-left corner of the visible
    /// area is `tree_x`, `tree_y`, where `tree_x` and `tree_y` are specified
    /// in tree coordinates.  The `tree_view` must be realized before
    /// this function is called.  If it isn't, you probably want to be
    /// using `gtk_tree_view_scroll_to_cell()`.
    /// 
    /// If either `tree_x` or `tree_y` are -1, then that direction isn’t scrolled.
    func scrollToPoint(treeX tree_x: CInt, treeY tree_y: CInt) {
        gtk_tree_view_scroll_to_point(cast(tree_view_ptr), gint(tree_x), gint(tree_y))
    
    }

    /// Cause the `GtkTreeView::row`-activated signal to be emitted
    /// on a single click instead of a double click.
    func setActivateOnSingleClick(single: Bool) {
        gtk_tree_view_set_activate_on_single_click(cast(tree_view_ptr), gboolean(single ? 1 : 0))
    
    }

    /// Sets a user function for determining where a column may be dropped when
    /// dragged.  This function is called on every column pair in turn at the
    /// beginning of a column drag to determine where a drop can take place.  The
    /// arguments passed to `func` are: the `tree_view`, the `GtkTreeViewColumn` being
    /// dragged, the two `GtkTreeViewColumn` s determining the drop spot, and
    /// `user_data`.  If either of the `GtkTreeViewColumn` arguments for the drop spot
    /// are `nil`, then they indicate an edge.  If `func` is set to be `nil`, then
    /// `tree_view` reverts to the default behavior of allowing all columns to be
    /// dropped everywhere.
    func setColumnDragFunction(_ func_: @escaping TreeViewColumnDropFunc, userData user_data: UnsafeMutableRawPointer, destroy: @escaping GLib.DestroyNotify) {
        gtk_tree_view_set_column_drag_function(cast(tree_view_ptr), func_, cast(user_data), destroy)
    
    }

    /// Sets the current keyboard focus to be at `path`, and selects it.  This is
    /// useful when you want to focus the user’s attention on a particular row.  If
    /// `focus_column` is not `nil`, then focus is given to the column specified by
    /// it. Additionally, if `focus_column` is specified, and `start_editing` is
    /// `true`, then editing should be started in the specified cell.
    /// This function is often followed by `gtk_widget_grab_focus` (`tree_view`)
    /// in order to give keyboard focus to the widget.  Please note that editing
    /// can only happen when the widget is realized.
    /// 
    /// If `path` is invalid for `model`, the current cursor (if any) will be unset
    /// and the function will return without failing.
    func setCursor(path: TreePathProtocol, focusColumn focus_column: TreeViewColumnProtocol, startEditing start_editing: Bool) {
        gtk_tree_view_set_cursor(cast(tree_view_ptr), cast(path.ptr), cast(focus_column.ptr), gboolean(start_editing ? 1 : 0))
    
    }

    /// Sets the current keyboard focus to be at `path`, and selects it.  This is
    /// useful when you want to focus the user’s attention on a particular row.  If
    /// `focus_column` is not `nil`, then focus is given to the column specified by
    /// it. If `focus_column` and `focus_cell` are not `nil`, and `focus_column`
    /// contains 2 or more editable or activatable cells, then focus is given to
    /// the cell specified by `focus_cell`. Additionally, if `focus_column` is
    /// specified, and `start_editing` is `true`, then editing should be started in
    /// the specified cell.  This function is often followed by
    /// `gtk_widget_grab_focus` (`tree_view`) in order to give keyboard focus to the
    /// widget.  Please note that editing can only happen when the widget is
    /// realized.
    /// 
    /// If `path` is invalid for `model`, the current cursor (if any) will be unset
    /// and the function will return without failing.
    func setCursorOnCell(path: TreePathProtocol, focusColumn focus_column: TreeViewColumnProtocol, focusCell focus_cell: CellRendererProtocol, startEditing start_editing: Bool) {
        gtk_tree_view_set_cursor_on_cell(cast(tree_view_ptr), cast(path.ptr), cast(focus_column.ptr), cast(focus_cell.ptr), gboolean(start_editing ? 1 : 0))
    
    }

    /// This function should almost never be used.  It is meant for private use by
    /// ATK for determining the number of visible children that are removed when the
    /// user collapses a row, or a row is deleted.
    ///
    /// **set_destroy_count_func is deprecated:**
    /// Accessibility does not need the function anymore.
    @available(*, deprecated) func setDestroyCountFunc(_ func_: @escaping TreeDestroyCountFunc, data: UnsafeMutableRawPointer, destroy: @escaping GLib.DestroyNotify) {
        gtk_tree_view_set_destroy_count_func(cast(tree_view_ptr), func_, cast(data), destroy)
    
    }

    /// Sets the row that is highlighted for feedback.
    /// If `path` is `nil`, an existing highlight is removed.
    func setDragDestRow(path: TreePathProtocol, pos: TreeViewDropPosition) {
        gtk_tree_view_set_drag_dest_row(cast(tree_view_ptr), cast(path.ptr), pos)
    
    }

    /// If `enable_search` is set, then the user can type in text to search through
    /// the tree interactively (this is sometimes called "typeahead find").
    /// 
    /// Note that even if this is `false`, the user can still initiate a search
    /// using the “start-interactive-search” key binding.
    func set(enableSearch enable_search: Bool) {
        gtk_tree_view_set_enable_search(cast(tree_view_ptr), gboolean(enable_search ? 1 : 0))
    
    }

    /// Sets whether to draw lines interconnecting the expanders in `tree_view`.
    /// This does not have any visible effects for lists.
    func setEnableTreeLines(enabled: Bool) {
        gtk_tree_view_set_enable_tree_lines(cast(tree_view_ptr), gboolean(enabled ? 1 : 0))
    
    }

    /// Sets the column to draw the expander arrow at. It must be in `tree_view`.
    /// If `column` is `nil`, then the expander arrow is always at the first
    /// visible column.
    /// 
    /// If you do not want expander arrow to appear in your tree, set the
    /// expander column to a hidden column.
    func setExpander(column: TreeViewColumnProtocol) {
        gtk_tree_view_set_expander_column(cast(tree_view_ptr), cast(column.ptr))
    
    }

    /// Enables or disables the fixed height mode of `tree_view`.
    /// Fixed height mode speeds up `GtkTreeView` by assuming that all
    /// rows have the same height.
    /// Only enable this option if all rows are the same height and all
    /// columns are of type `GTK_TREE_VIEW_COLUMN_FIXED`.
    func setFixedHeightMode(enable: Bool) {
        gtk_tree_view_set_fixed_height_mode(cast(tree_view_ptr), gboolean(enable ? 1 : 0))
    
    }

    /// Sets which grid lines to draw in `tree_view`.
    func set(gridLines grid_lines: TreeViewGridLines) {
        gtk_tree_view_set_grid_lines(cast(tree_view_ptr), grid_lines)
    
    }

    /// Sets the `GtkAdjustment` for the current horizontal aspect.
    ///
    /// **set_hadjustment is deprecated:**
    /// Use gtk_scrollable_set_hadjustment()
    @available(*, deprecated) func setHadjustment(adjustment: AdjustmentProtocol) {
        gtk_tree_view_set_hadjustment(cast(tree_view_ptr), cast(adjustment.ptr))
    
    }

    /// Allow the column title buttons to be clicked.
    func setHeadersClickable(setting: Bool) {
        gtk_tree_view_set_headers_clickable(cast(tree_view_ptr), gboolean(setting ? 1 : 0))
    
    }

    /// Sets the visibility state of the headers.
    func set(headersVisible headers_visible: Bool) {
        gtk_tree_view_set_headers_visible(cast(tree_view_ptr), gboolean(headers_visible ? 1 : 0))
    
    }

    /// Enables or disables the hover expansion mode of `tree_view`.
    /// Hover expansion makes rows expand or collapse if the pointer
    /// moves over them.
    func setHover(expand: Bool) {
        gtk_tree_view_set_hover_expand(cast(tree_view_ptr), gboolean(expand ? 1 : 0))
    
    }

    /// Enables or disables the hover selection mode of `tree_view`.
    /// Hover selection makes the selected row follow the pointer.
    /// Currently, this works only for the selection modes
    /// `GTK_SELECTION_SINGLE` and `GTK_SELECTION_BROWSE`.
    func setHoverSelection(hover: Bool) {
        gtk_tree_view_set_hover_selection(cast(tree_view_ptr), gboolean(hover ? 1 : 0))
    
    }

    /// Sets the amount of extra indentation for child levels to use in `tree_view`
    /// in addition to the default indentation.  The value should be specified in
    /// pixels, a value of 0 disables this feature and in this case only the default
    /// indentation will be used.
    /// This does not have any visible effects for lists.
    func setLevel(indentation: CInt) {
        gtk_tree_view_set_level_indentation(cast(tree_view_ptr), gint(indentation))
    
    }

    /// Sets the model for a `GtkTreeView`.  If the `tree_view` already has a model
    /// set, it will remove it before setting the new model.  If `model` is `nil`,
    /// then it will unset the old model.
    func set(model: TreeModelProtocol) {
        gtk_tree_view_set_model(cast(tree_view_ptr), cast(model.ptr))
    
    }

    /// This function is a convenience function to allow you to reorder
    /// models that support the `GtkTreeDragSourceIface` and the
    /// `GtkTreeDragDestIface`.  Both `GtkTreeStore` and `GtkListStore` support
    /// these.  If `reorderable` is `true`, then the user can reorder the
    /// model by dragging and dropping rows. The developer can listen to
    /// these changes by connecting to the model’s `GtkTreeModel::row`-inserted
    /// and `GtkTreeModel::row`-deleted signals. The reordering is implemented
    /// by setting up the tree view as a drag source and destination.
    /// Therefore, drag and drop can not be used in a reorderable view for any
    /// other purpose.
    /// 
    /// This function does not give you any degree of control over the order -- any
    /// reordering is allowed.  If more control is needed, you should probably
    /// handle drag and drop manually.
    func set(reorderable: Bool) {
        gtk_tree_view_set_reorderable(cast(tree_view_ptr), gboolean(reorderable ? 1 : 0))
    
    }

    /// Sets the row separator function, which is used to determine
    /// whether a row should be drawn as a separator. If the row separator
    /// function is `nil`, no separators are drawn. This is the default value.
    func setRowSeparatorFunc(_ func_: @escaping TreeViewRowSeparatorFunc, data: UnsafeMutableRawPointer, destroy: @escaping GLib.DestroyNotify) {
        gtk_tree_view_set_row_separator_func(cast(tree_view_ptr), func_, cast(data), destroy)
    
    }

    /// Enables or disables rubber banding in `tree_view`.  If the selection mode
    /// is `GTK_SELECTION_MULTIPLE`, rubber banding will allow the user to select
    /// multiple rows by dragging the mouse.
    func setRubberBanding(enable: Bool) {
        gtk_tree_view_set_rubber_banding(cast(tree_view_ptr), gboolean(enable ? 1 : 0))
    
    }

    /// Sets a hint for the theme to draw even/odd rows in the `tree_view`
    /// with different colors, also known as "zebra striping".
    /// 
    /// This function tells the GTK+ theme that the user interface for your
    /// application requires users to read across tree rows and associate
    /// cells with one another.
    /// 
    /// Do not use it just because you prefer the appearance of the ruled
    /// tree; that’s a question for the theme. Some themes will draw tree
    /// rows in alternating colors even when rules are turned off, and
    /// users who prefer that appearance all the time can choose those
    /// themes. You should call this function only as a semantic hint to
    /// the theme engine that your tree makes alternating colors useful
    /// from a functional standpoint (since it has lots of columns,
    /// generally).
    ///
    /// **set_rules_hint is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func setRulesHint(setting: Bool) {
        gtk_tree_view_set_rules_hint(cast(tree_view_ptr), gboolean(setting ? 1 : 0))
    
    }

    /// Sets `column` as the column where the interactive search code should
    /// search in for the current model.
    /// 
    /// If the search column is set, users can use the “start-interactive-search”
    /// key binding to bring up search popup. The enable-search property controls
    /// whether simply typing text will also start an interactive search.
    /// 
    /// Note that `column` refers to a column of the current model. The search
    /// column is reset to -1 when the model is changed.
    func setSearch(column: CInt) {
        gtk_tree_view_set_search_column(cast(tree_view_ptr), gint(column))
    
    }

    /// Sets the entry which the interactive search code will use for this
    /// `tree_view`.  This is useful when you want to provide a search entry
    /// in our interface at all time at a fixed position.  Passing `nil` for
    /// `entry` will make the interactive search code use the built-in popup
    /// entry again.
    func setSearch(entry: EntryProtocol) {
        gtk_tree_view_set_search_entry(cast(tree_view_ptr), cast(entry.ptr))
    
    }

    /// Sets the compare function for the interactive search capabilities; note
    /// that somewhat like `strcmp()` returning 0 for equality
    /// `GtkTreeViewSearchEqualFunc` returns `false` on matches.
    func set(searchEqualFunc search_equal_func: @escaping TreeViewSearchEqualFunc, searchUserData search_user_data: UnsafeMutableRawPointer, searchDestroy search_destroy: @escaping GLib.DestroyNotify) {
        gtk_tree_view_set_search_equal_func(cast(tree_view_ptr), search_equal_func, cast(search_user_data), search_destroy)
    
    }

    /// Sets the function to use when positioning the search dialog.
    func setSearchPositionFunc(_ func_: @escaping TreeViewSearchPositionFunc, data: UnsafeMutableRawPointer, destroy: @escaping GLib.DestroyNotify) {
        gtk_tree_view_set_search_position_func(cast(tree_view_ptr), func_, cast(data), destroy)
    
    }

    /// Sets whether to draw and enable expanders and indent child rows in
    /// `tree_view`.  When disabled there will be no expanders visible in trees
    /// and there will be no way to expand and collapse rows by default.  Also
    /// note that hiding the expanders will disable the default indentation.  You
    /// can set a custom indentation in this case using
    /// `gtk_tree_view_set_level_indentation()`.
    /// This does not have any visible effects for lists.
    func setShowExpanders(enabled: Bool) {
        gtk_tree_view_set_show_expanders(cast(tree_view_ptr), gboolean(enabled ? 1 : 0))
    
    }

    /// Sets the tip area of `tooltip` to the area `path`, `column` and `cell` have
    /// in common.  For example if `path` is `nil` and `column` is set, the tip
    /// area will be set to the full area covered by `column`.  See also
    /// `gtk_tooltip_set_tip_area()`.
    /// 
    /// Note that if `path` is not specified and `cell` is set and part of a column
    /// containing the expander, the tooltip might not show and hide at the correct
    /// position.  In such cases `path` must be set to the current node under the
    /// mouse cursor for this function to operate correctly.
    /// 
    /// See also `gtk_tree_view_set_tooltip_column()` for a simpler alternative.
    func setTooltipCell(tooltip: TooltipProtocol, path: TreePathProtocol, column: TreeViewColumnProtocol, cell: CellRendererProtocol) {
        gtk_tree_view_set_tooltip_cell(cast(tree_view_ptr), cast(tooltip.ptr), cast(path.ptr), cast(column.ptr), cast(cell.ptr))
    
    }

    /// If you only plan to have simple (text-only) tooltips on full rows, you
    /// can use this function to have `GtkTreeView` handle these automatically
    /// for you. `column` should be set to the column in `tree_view`’s model
    /// containing the tooltip texts, or -1 to disable this feature.
    /// 
    /// When enabled, `GtkWidget:has`-tooltip will be set to `true` and
    /// `tree_view` will connect a `GtkWidget::query`-tooltip signal handler.
    /// 
    /// Note that the signal handler sets the text with `gtk_tooltip_set_markup()`,
    /// so &, <, etc have to be escaped in the text.
    func setTooltip(column: CInt) {
        gtk_tree_view_set_tooltip_column(cast(tree_view_ptr), gint(column))
    
    }

    /// Sets the tip area of `tooltip` to be the area covered by the row at `path`.
    /// See also `gtk_tree_view_set_tooltip_column()` for a simpler alternative.
    /// See also `gtk_tooltip_set_tip_area()`.
    func setTooltipRow(tooltip: TooltipProtocol, path: TreePathProtocol) {
        gtk_tree_view_set_tooltip_row(cast(tree_view_ptr), cast(tooltip.ptr), cast(path.ptr))
    
    }

    /// Sets the `GtkAdjustment` for the current vertical aspect.
    ///
    /// **set_vadjustment is deprecated:**
    /// Use gtk_scrollable_set_vadjustment()
    @available(*, deprecated) func setVadjustment(adjustment: AdjustmentProtocol) {
        gtk_tree_view_set_vadjustment(cast(tree_view_ptr), cast(adjustment.ptr))
    
    }

    /// Undoes the effect of
    /// `gtk_tree_view_enable_model_drag_dest()`. Calling this method sets
    /// `GtkTreeView:reorderable` to `false`.
    func unsetRowsDragDest() {
        gtk_tree_view_unset_rows_drag_dest(cast(tree_view_ptr))
    
    }

    /// Undoes the effect of
    /// `gtk_tree_view_enable_model_drag_source()`. Calling this method sets
    /// `GtkTreeView:reorderable` to `false`.
    func unsetRowsDragSource() {
        gtk_tree_view_unset_rows_drag_source(cast(tree_view_ptr))
    
    }
    /// Gets the setting set by `gtk_tree_view_set_activate_on_single_click()`.
    var activateOnSingleClick: Bool {
        /// Gets the setting set by `gtk_tree_view_set_activate_on_single_click()`.
        get {
            let rv = gtk_tree_view_get_activate_on_single_click(cast(tree_view_ptr))
            return Bool(rv != 0)
        }
        /// Cause the `GtkTreeView::row`-activated signal to be emitted
        /// on a single click instead of a double click.
        nonmutating set {
            gtk_tree_view_set_activate_on_single_click(cast(tree_view_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Returns the window that `tree_view` renders to.
    /// This is used primarily to compare to `event->window`
    /// to confirm that the event on `tree_view` is on the right window.
    var binWindow: UnsafeMutablePointer<GdkWindow>! {
        /// Returns the window that `tree_view` renders to.
        /// This is used primarily to compare to `event->window`
        /// to confirm that the event on `tree_view` is on the right window.
        get {
            let rv = gtk_tree_view_get_bin_window(cast(tree_view_ptr))
            return cast(rv)
        }
    }

    /// Returns a `GList` of all the `GtkTreeViewColumn` s currently in `tree_view`.
    /// The returned list must be freed with g_list_free ().
    var columns: UnsafeMutablePointer<GList>! {
        /// Returns a `GList` of all the `GtkTreeViewColumn` s currently in `tree_view`.
        /// The returned list must be freed with g_list_free ().
        get {
            let rv = gtk_tree_view_get_columns(cast(tree_view_ptr))
            return cast(rv)
        }
    }

    /// Returns whether or not the tree allows to start interactive searching
    /// by typing in text.
    var enableSearch: Bool {
        /// Returns whether or not the tree allows to start interactive searching
        /// by typing in text.
        get {
            let rv = gtk_tree_view_get_enable_search(cast(tree_view_ptr))
            return Bool(rv != 0)
        }
        /// If `enable_search` is set, then the user can type in text to search through
        /// the tree interactively (this is sometimes called "typeahead find").
        /// 
        /// Note that even if this is `false`, the user can still initiate a search
        /// using the “start-interactive-search” key binding.
        nonmutating set {
            gtk_tree_view_set_enable_search(cast(tree_view_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Returns whether or not tree lines are drawn in `tree_view`.
    var enableTreeLines: Bool {
        /// Returns whether or not tree lines are drawn in `tree_view`.
        get {
            let rv = gtk_tree_view_get_enable_tree_lines(cast(tree_view_ptr))
            return Bool(rv != 0)
        }
        /// Sets whether to draw lines interconnecting the expanders in `tree_view`.
        /// This does not have any visible effects for lists.
        nonmutating set {
            gtk_tree_view_set_enable_tree_lines(cast(tree_view_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Returns the column that is the current expander column.
    /// This column has the expander arrow drawn next to it.
    var expanderColumn: UnsafeMutablePointer<GtkTreeViewColumn>! {
        /// Returns the column that is the current expander column.
        /// This column has the expander arrow drawn next to it.
        get {
            let rv = gtk_tree_view_get_expander_column(cast(tree_view_ptr))
            return cast(rv)
        }
        /// Sets the column to draw the expander arrow at. It must be in `tree_view`.
        /// If `column` is `nil`, then the expander arrow is always at the first
        /// visible column.
        /// 
        /// If you do not want expander arrow to appear in your tree, set the
        /// expander column to a hidden column.
        nonmutating set {
            gtk_tree_view_set_expander_column(cast(tree_view_ptr), cast(newValue))
        }
    }

    /// Returns whether fixed height mode is turned on for `tree_view`.
    var fixedHeightMode: Bool {
        /// Returns whether fixed height mode is turned on for `tree_view`.
        get {
            let rv = gtk_tree_view_get_fixed_height_mode(cast(tree_view_ptr))
            return Bool(rv != 0)
        }
        /// Enables or disables the fixed height mode of `tree_view`.
        /// Fixed height mode speeds up `GtkTreeView` by assuming that all
        /// rows have the same height.
        /// Only enable this option if all rows are the same height and all
        /// columns are of type `GTK_TREE_VIEW_COLUMN_FIXED`.
        nonmutating set {
            gtk_tree_view_set_fixed_height_mode(cast(tree_view_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Returns which grid lines are enabled in `tree_view`.
    var gridLines: GtkTreeViewGridLines {
        /// Returns which grid lines are enabled in `tree_view`.
        get {
            let rv = gtk_tree_view_get_grid_lines(cast(tree_view_ptr))
            return rv
        }
        /// Sets which grid lines to draw in `tree_view`.
        nonmutating set {
            gtk_tree_view_set_grid_lines(cast(tree_view_ptr), newValue)
        }
    }

    /// Gets the `GtkAdjustment` currently being used for the horizontal aspect.
    ///
    /// **get_hadjustment is deprecated:**
    /// Use gtk_scrollable_get_hadjustment()
    var hadjustment: UnsafeMutablePointer<GtkAdjustment>! {
        /// Gets the `GtkAdjustment` currently being used for the horizontal aspect.
        ///
        /// **get_hadjustment is deprecated:**
        /// Use gtk_scrollable_get_hadjustment()
        @available(*, deprecated) get {
            let rv = gtk_tree_view_get_hadjustment(cast(tree_view_ptr))
            return cast(rv)
        }
        /// Sets the `GtkAdjustment` for the current horizontal aspect.
        ///
        /// **set_hadjustment is deprecated:**
        /// Use gtk_scrollable_set_hadjustment()
        @available(*, deprecated) nonmutating set {
            gtk_tree_view_set_hadjustment(cast(tree_view_ptr), cast(newValue))
        }
    }

    /// Returns whether all header columns are clickable.
    var headersClickable: Bool {
        /// Returns whether all header columns are clickable.
        get {
            let rv = gtk_tree_view_get_headers_clickable(cast(tree_view_ptr))
            return Bool(rv != 0)
        }
        /// Allow the column title buttons to be clicked.
        nonmutating set {
            gtk_tree_view_set_headers_clickable(cast(tree_view_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Returns `true` if the headers on the `tree_view` are visible.
    var headersVisible: Bool {
        /// Returns `true` if the headers on the `tree_view` are visible.
        get {
            let rv = gtk_tree_view_get_headers_visible(cast(tree_view_ptr))
            return Bool(rv != 0)
        }
        /// Sets the visibility state of the headers.
        nonmutating set {
            gtk_tree_view_set_headers_visible(cast(tree_view_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Returns whether hover expansion mode is turned on for `tree_view`.
    var hoverExpand: Bool {
        /// Returns whether hover expansion mode is turned on for `tree_view`.
        get {
            let rv = gtk_tree_view_get_hover_expand(cast(tree_view_ptr))
            return Bool(rv != 0)
        }
        /// Enables or disables the hover expansion mode of `tree_view`.
        /// Hover expansion makes rows expand or collapse if the pointer
        /// moves over them.
        nonmutating set {
            gtk_tree_view_set_hover_expand(cast(tree_view_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Returns whether hover selection mode is turned on for `tree_view`.
    var hoverSelection: Bool {
        /// Returns whether hover selection mode is turned on for `tree_view`.
        get {
            let rv = gtk_tree_view_get_hover_selection(cast(tree_view_ptr))
            return Bool(rv != 0)
        }
        /// Enables or disables the hover selection mode of `tree_view`.
        /// Hover selection makes the selected row follow the pointer.
        /// Currently, this works only for the selection modes
        /// `GTK_SELECTION_SINGLE` and `GTK_SELECTION_BROWSE`.
        nonmutating set {
            gtk_tree_view_set_hover_selection(cast(tree_view_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Returns whether a rubber banding operation is currently being done
    /// in `tree_view`.
    var isRubberBandingActive: Bool {
        /// Returns whether a rubber banding operation is currently being done
        /// in `tree_view`.
        get {
            let rv = gtk_tree_view_is_rubber_banding_active(cast(tree_view_ptr))
            return Bool(rv != 0)
        }
    }

    /// Returns the amount, in pixels, of extra indentation for child levels
    /// in `tree_view`.
    var levelIndentation: CInt {
        /// Returns the amount, in pixels, of extra indentation for child levels
        /// in `tree_view`.
        get {
            let rv = gtk_tree_view_get_level_indentation(cast(tree_view_ptr))
            return CInt(rv)
        }
        /// Sets the amount of extra indentation for child levels to use in `tree_view`
        /// in addition to the default indentation.  The value should be specified in
        /// pixels, a value of 0 disables this feature and in this case only the default
        /// indentation will be used.
        /// This does not have any visible effects for lists.
        nonmutating set {
            gtk_tree_view_set_level_indentation(cast(tree_view_ptr), gint(newValue))
        }
    }

    var model: UnsafeMutablePointer<GtkTreeModel>! {
        /// Returns the model the `GtkTreeView` is based on.  Returns `nil` if the
        /// model is unset.
        get {
            let rv = gtk_tree_view_get_model(cast(tree_view_ptr))
            return cast(rv)
        }
        /// Sets the model for a `GtkTreeView`.  If the `tree_view` already has a model
        /// set, it will remove it before setting the new model.  If `model` is `nil`,
        /// then it will unset the old model.
        nonmutating set {
            gtk_tree_view_set_model(cast(tree_view_ptr), cast(newValue))
        }
    }

    /// Queries the number of columns in the given `tree_view`.
    var nColumns: CUnsignedInt {
        /// Queries the number of columns in the given `tree_view`.
        get {
            let rv = gtk_tree_view_get_n_columns(cast(tree_view_ptr))
            return CUnsignedInt(rv)
        }
    }

    var reorderable: Bool {
        /// Retrieves whether the user can reorder the tree via drag-and-drop. See
        /// `gtk_tree_view_set_reorderable()`.
        get {
            let rv = gtk_tree_view_get_reorderable(cast(tree_view_ptr))
            return Bool(rv != 0)
        }
        /// This function is a convenience function to allow you to reorder
        /// models that support the `GtkTreeDragSourceIface` and the
        /// `GtkTreeDragDestIface`.  Both `GtkTreeStore` and `GtkListStore` support
        /// these.  If `reorderable` is `true`, then the user can reorder the
        /// model by dragging and dropping rows. The developer can listen to
        /// these changes by connecting to the model’s `GtkTreeModel::row`-inserted
        /// and `GtkTreeModel::row`-deleted signals. The reordering is implemented
        /// by setting up the tree view as a drag source and destination.
        /// Therefore, drag and drop can not be used in a reorderable view for any
        /// other purpose.
        /// 
        /// This function does not give you any degree of control over the order -- any
        /// reordering is allowed.  If more control is needed, you should probably
        /// handle drag and drop manually.
        nonmutating set {
            gtk_tree_view_set_reorderable(cast(tree_view_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Returns the current row separator function.
    var rowSeparatorFunc: GtkTreeViewRowSeparatorFunc! {
        /// Returns the current row separator function.
        get {
            let rv = gtk_tree_view_get_row_separator_func(cast(tree_view_ptr))
            return rv
        }
    }

    /// Returns whether rubber banding is turned on for `tree_view`.  If the
    /// selection mode is `GTK_SELECTION_MULTIPLE`, rubber banding will allow the
    /// user to select multiple rows by dragging the mouse.
    var rubberBanding: Bool {
        /// Returns whether rubber banding is turned on for `tree_view`.  If the
        /// selection mode is `GTK_SELECTION_MULTIPLE`, rubber banding will allow the
        /// user to select multiple rows by dragging the mouse.
        get {
            let rv = gtk_tree_view_get_rubber_banding(cast(tree_view_ptr))
            return Bool(rv != 0)
        }
        /// Enables or disables rubber banding in `tree_view`.  If the selection mode
        /// is `GTK_SELECTION_MULTIPLE`, rubber banding will allow the user to select
        /// multiple rows by dragging the mouse.
        nonmutating set {
            gtk_tree_view_set_rubber_banding(cast(tree_view_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Gets the setting set by `gtk_tree_view_set_rules_hint()`.
    ///
    /// **get_rules_hint is deprecated:**
    /// This method is deprecated.
    var rulesHint: Bool {
        /// Gets the setting set by `gtk_tree_view_set_rules_hint()`.
        ///
        /// **get_rules_hint is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated) get {
            let rv = gtk_tree_view_get_rules_hint(cast(tree_view_ptr))
            return Bool(rv != 0)
        }
        /// Sets a hint for the theme to draw even/odd rows in the `tree_view`
        /// with different colors, also known as "zebra striping".
        /// 
        /// This function tells the GTK+ theme that the user interface for your
        /// application requires users to read across tree rows and associate
        /// cells with one another.
        /// 
        /// Do not use it just because you prefer the appearance of the ruled
        /// tree; that’s a question for the theme. Some themes will draw tree
        /// rows in alternating colors even when rules are turned off, and
        /// users who prefer that appearance all the time can choose those
        /// themes. You should call this function only as a semantic hint to
        /// the theme engine that your tree makes alternating colors useful
        /// from a functional standpoint (since it has lots of columns,
        /// generally).
        ///
        /// **set_rules_hint is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated) nonmutating set {
            gtk_tree_view_set_rules_hint(cast(tree_view_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Gets the column searched on by the interactive search code.
    var searchColumn: CInt {
        /// Gets the column searched on by the interactive search code.
        get {
            let rv = gtk_tree_view_get_search_column(cast(tree_view_ptr))
            return CInt(rv)
        }
        /// Sets `column` as the column where the interactive search code should
        /// search in for the current model.
        /// 
        /// If the search column is set, users can use the “start-interactive-search”
        /// key binding to bring up search popup. The enable-search property controls
        /// whether simply typing text will also start an interactive search.
        /// 
        /// Note that `column` refers to a column of the current model. The search
        /// column is reset to -1 when the model is changed.
        nonmutating set {
            gtk_tree_view_set_search_column(cast(tree_view_ptr), gint(newValue))
        }
    }

    /// Returns the `GtkEntry` which is currently in use as interactive search
    /// entry for `tree_view`.  In case the built-in entry is being used, `nil`
    /// will be returned.
    var searchEntry: UnsafeMutablePointer<GtkEntry>! {
        /// Returns the `GtkEntry` which is currently in use as interactive search
        /// entry for `tree_view`.  In case the built-in entry is being used, `nil`
        /// will be returned.
        get {
            let rv = gtk_tree_view_get_search_entry(cast(tree_view_ptr))
            return cast(rv)
        }
        /// Sets the entry which the interactive search code will use for this
        /// `tree_view`.  This is useful when you want to provide a search entry
        /// in our interface at all time at a fixed position.  Passing `nil` for
        /// `entry` will make the interactive search code use the built-in popup
        /// entry again.
        nonmutating set {
            gtk_tree_view_set_search_entry(cast(tree_view_ptr), cast(newValue))
        }
    }

    /// Returns the compare function currently in use.
    var searchEqualFunc: GtkTreeViewSearchEqualFunc! {
        /// Returns the compare function currently in use.
        get {
            let rv = gtk_tree_view_get_search_equal_func(cast(tree_view_ptr))
            return rv
        }
    }

    /// Returns the positioning function currently in use.
    var searchPositionFunc: GtkTreeViewSearchPositionFunc! {
        /// Returns the positioning function currently in use.
        get {
            let rv = gtk_tree_view_get_search_position_func(cast(tree_view_ptr))
            return rv
        }
    }

    /// Gets the `GtkTreeSelection` associated with `tree_view`.
    var selection: UnsafeMutablePointer<GtkTreeSelection>! {
        /// Gets the `GtkTreeSelection` associated with `tree_view`.
        get {
            let rv = gtk_tree_view_get_selection(cast(tree_view_ptr))
            return cast(rv)
        }
    }

    /// Returns whether or not expanders are drawn in `tree_view`.
    var showExpanders: Bool {
        /// Returns whether or not expanders are drawn in `tree_view`.
        get {
            let rv = gtk_tree_view_get_show_expanders(cast(tree_view_ptr))
            return Bool(rv != 0)
        }
        /// Sets whether to draw and enable expanders and indent child rows in
        /// `tree_view`.  When disabled there will be no expanders visible in trees
        /// and there will be no way to expand and collapse rows by default.  Also
        /// note that hiding the expanders will disable the default indentation.  You
        /// can set a custom indentation in this case using
        /// `gtk_tree_view_set_level_indentation()`.
        /// This does not have any visible effects for lists.
        nonmutating set {
            gtk_tree_view_set_show_expanders(cast(tree_view_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Returns the column of `tree_view`’s model which is being used for
    /// displaying tooltips on `tree_view`’s rows.
    var tooltipColumn: CInt {
        /// Returns the column of `tree_view`’s model which is being used for
        /// displaying tooltips on `tree_view`’s rows.
        get {
            let rv = gtk_tree_view_get_tooltip_column(cast(tree_view_ptr))
            return CInt(rv)
        }
        /// If you only plan to have simple (text-only) tooltips on full rows, you
        /// can use this function to have `GtkTreeView` handle these automatically
        /// for you. `column` should be set to the column in `tree_view`’s model
        /// containing the tooltip texts, or -1 to disable this feature.
        /// 
        /// When enabled, `GtkWidget:has`-tooltip will be set to `true` and
        /// `tree_view` will connect a `GtkWidget::query`-tooltip signal handler.
        /// 
        /// Note that the signal handler sets the text with `gtk_tooltip_set_markup()`,
        /// so &, <, etc have to be escaped in the text.
        nonmutating set {
            gtk_tree_view_set_tooltip_column(cast(tree_view_ptr), gint(newValue))
        }
    }

    /// Gets the `GtkAdjustment` currently being used for the vertical aspect.
    ///
    /// **get_vadjustment is deprecated:**
    /// Use gtk_scrollable_get_vadjustment()
    var vadjustment: UnsafeMutablePointer<GtkAdjustment>! {
        /// Gets the `GtkAdjustment` currently being used for the vertical aspect.
        ///
        /// **get_vadjustment is deprecated:**
        /// Use gtk_scrollable_get_vadjustment()
        @available(*, deprecated) get {
            let rv = gtk_tree_view_get_vadjustment(cast(tree_view_ptr))
            return cast(rv)
        }
        /// Sets the `GtkAdjustment` for the current vertical aspect.
        ///
        /// **set_vadjustment is deprecated:**
        /// Use gtk_scrollable_set_vadjustment()
        @available(*, deprecated) nonmutating set {
            gtk_tree_view_set_vadjustment(cast(tree_view_ptr), cast(newValue))
        }
    }
}



// MARK: - TreeViewAccessible Class

/// The `TreeViewAccessibleProtocol` protocol exposes the methods and properties of an underlying `GtkTreeViewAccessible` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeViewAccessible`.
/// Alternatively, use `TreeViewAccessibleRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///

public protocol TreeViewAccessibleProtocol: ContainerAccessibleProtocol, Atk.SelectionProtocol, Atk.TableProtocol, CellAccessibleParentProtocol {
    /// Untyped pointer to the underlying `GtkTreeViewAccessible` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkTreeViewAccessible` instance.
    var tree_view_accessible_ptr: UnsafeMutablePointer<GtkTreeViewAccessible> { get }
}

/// The `TreeViewAccessibleRef` type acts as a lightweight Swift reference to an underlying `GtkTreeViewAccessible` instance.
/// It exposes methods that can operate on this data type through `TreeViewAccessibleProtocol` conformance.
/// Use `TreeViewAccessibleRef` only as an `unowned` reference to an existing `GtkTreeViewAccessible` instance.
///

public struct TreeViewAccessibleRef: TreeViewAccessibleProtocol {
    /// Untyped pointer to the underlying `GtkTreeViewAccessible` instance.
    /// For type-safe access, use the generated, typed pointer `tree_view_accessible_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension TreeViewAccessibleRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkTreeViewAccessible>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `TreeViewAccessibleProtocol`
    init<T: TreeViewAccessibleProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewAccessibleProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewAccessibleProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewAccessibleProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewAccessibleProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewAccessibleProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `TreeViewAccessible` type acts as a reference-counted owner of an underlying `GtkTreeViewAccessible` instance.
/// It provides the methods that can operate on this data type through `TreeViewAccessibleProtocol` conformance.
/// Use `TreeViewAccessible` as a strong reference or owner of a `GtkTreeViewAccessible` instance.
///

open class TreeViewAccessible: ContainerAccessible, TreeViewAccessibleProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `TreeViewAccessible` instance.
    public init(_ op: UnsafeMutablePointer<GtkTreeViewAccessible>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `TreeViewAccessibleProtocol`
    /// Will retain `GtkTreeViewAccessible`.
    public convenience init<T: TreeViewAccessibleProtocol>(_ other: T) {
        self.init(cast(other.tree_view_accessible_ptr))
        g_object_ref(cast(tree_view_accessible_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewAccessibleProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkTreeViewAccessible.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewAccessibleProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkTreeViewAccessible.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewAccessibleProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkTreeViewAccessible.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewAccessibleProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkTreeViewAccessible>(opaquePointer))
    }



}

public enum TreeViewAccessiblePropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case widget = "widget"
}

public extension TreeViewAccessibleProtocol {
    /// Bind a `TreeViewAccessiblePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TreeViewAccessiblePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(tree_view_accessible_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum TreeViewAccessibleSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyWidget = "notify::widget"
}

public extension TreeViewAccessibleProtocol {
    /// Connect a `TreeViewAccessibleSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: TreeViewAccessibleSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(tree_view_accessible_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension TreeViewAccessibleProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeViewAccessible` instance.
    var tree_view_accessible_ptr: UnsafeMutablePointer<GtkTreeViewAccessible> { return ptr.assumingMemoryBound(to: GtkTreeViewAccessible.self) }

}



// MARK: - TreeViewColumn Class

/// The `TreeViewColumnProtocol` protocol exposes the methods and properties of an underlying `GtkTreeViewColumn` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeViewColumn`.
/// Alternatively, use `TreeViewColumnRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// The GtkTreeViewColumn object represents a visible column in a `GtkTreeView` widget.
/// It allows to set properties of the column header, and functions as a holding pen for
/// the cell renderers which determine how the data in the column is displayed.
/// 
/// Please refer to the [tree widget conceptual overview](#TreeWidget)
/// for an overview of all the objects and data types related to the tree widget and how
/// they work together.
public protocol TreeViewColumnProtocol: InitiallyUnownedProtocol, BuildableProtocol, CellLayoutProtocol {
    /// Untyped pointer to the underlying `GtkTreeViewColumn` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkTreeViewColumn` instance.
    var tree_view_column_ptr: UnsafeMutablePointer<GtkTreeViewColumn> { get }
}

/// The `TreeViewColumnRef` type acts as a lightweight Swift reference to an underlying `GtkTreeViewColumn` instance.
/// It exposes methods that can operate on this data type through `TreeViewColumnProtocol` conformance.
/// Use `TreeViewColumnRef` only as an `unowned` reference to an existing `GtkTreeViewColumn` instance.
///
/// The GtkTreeViewColumn object represents a visible column in a `GtkTreeView` widget.
/// It allows to set properties of the column header, and functions as a holding pen for
/// the cell renderers which determine how the data in the column is displayed.
/// 
/// Please refer to the [tree widget conceptual overview](#TreeWidget)
/// for an overview of all the objects and data types related to the tree widget and how
/// they work together.
public struct TreeViewColumnRef: TreeViewColumnProtocol {
    /// Untyped pointer to the underlying `GtkTreeViewColumn` instance.
    /// For type-safe access, use the generated, typed pointer `tree_view_column_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension TreeViewColumnRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkTreeViewColumn>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `TreeViewColumnProtocol`
    init<T: TreeViewColumnProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkTreeViewColumn`.
    init() {
        let rv = gtk_tree_view_column_new()
        self.init(cast(rv))
    }

    /// Creates a new `GtkTreeViewColumn` using `area` to render its cells.
    init(area: CellAreaProtocol) {
        let rv = gtk_tree_view_column_new_with_area(cast(area.ptr))
        self.init(cast(rv))
    }


    // *** newWithAttributes() is not available because it has a varargs (...) parameter!

    /// Creates a new `GtkTreeViewColumn` using `area` to render its cells.
    static func newWith(area: CellAreaProtocol) -> TreeViewColumnRef! {
        let rv = gtk_tree_view_column_new_with_area(cast(area.ptr))
        return rv.map { TreeViewColumnRef(cast($0)) }
    }


    // *** newWithAttributes() is not available because it has a varargs (...) parameter!

}

/// The `TreeViewColumn` type acts as a reference-counted owner of an underlying `GtkTreeViewColumn` instance.
/// It provides the methods that can operate on this data type through `TreeViewColumnProtocol` conformance.
/// Use `TreeViewColumn` as a strong reference or owner of a `GtkTreeViewColumn` instance.
///
/// The GtkTreeViewColumn object represents a visible column in a `GtkTreeView` widget.
/// It allows to set properties of the column header, and functions as a holding pen for
/// the cell renderers which determine how the data in the column is displayed.
/// 
/// Please refer to the [tree widget conceptual overview](#TreeWidget)
/// for an overview of all the objects and data types related to the tree widget and how
/// they work together.
open class TreeViewColumn: InitiallyUnowned, TreeViewColumnProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `TreeViewColumn` instance.
    public init(_ op: UnsafeMutablePointer<GtkTreeViewColumn>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `TreeViewColumnProtocol`
    /// Will retain `GtkTreeViewColumn`.
    public convenience init<T: TreeViewColumnProtocol>(_ other: T) {
        self.init(cast(other.tree_view_column_ptr))
        g_object_ref(cast(tree_view_column_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkTreeViewColumn.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkTreeViewColumn.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkTreeViewColumn.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkTreeViewColumn>(opaquePointer))
    }

    /// Creates a new `GtkTreeViewColumn`.
    public convenience init() {
        let rv = gtk_tree_view_column_new()
        self.init(cast(rv))
    }

    /// Creates a new `GtkTreeViewColumn` using `area` to render its cells.
    public convenience init(area: CellAreaProtocol) {
        let rv = gtk_tree_view_column_new_with_area(cast(area.ptr))
        self.init(cast(rv))
    }


    // *** newWithAttributes() is not available because it has a varargs (...) parameter!


    /// Creates a new `GtkTreeViewColumn` using `area` to render its cells.
    public static func newWith(area: CellAreaProtocol) -> TreeViewColumn! {
        let rv = gtk_tree_view_column_new_with_area(cast(area.ptr))
        return rv.map { TreeViewColumn(cast($0)) }
    }


    // *** newWithAttributes() is not available because it has a varargs (...) parameter!


}

public enum TreeViewColumnPropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case alignment = "alignment"
    /// The `GtkCellArea` used to layout cell renderers for this column.
    /// 
    /// If no area is specified when creating the tree view column with `gtk_tree_view_column_new_with_area()`
    /// a horizontally oriented `GtkCellAreaBox` will be used.
    case cellArea = "cell-area"
    case clickable = "clickable"
    case expand = "expand"
    case fixedWidth = "fixed-width"
    case maxWidth = "max-width"
    case minWidth = "min-width"
    case reorderable = "reorderable"
    case resizable = "resizable"
    case sizing = "sizing"
    /// Logical sort column ID this column sorts on when selected for sorting. Setting the sort column ID makes the column header
    /// clickable. Set to -1 to make the column unsortable.
    case sortColumnID = "sort-column-id"
    case sortIndicator = "sort-indicator"
    case sortOrder = "sort-order"
    case spacing = "spacing"
    case title = "title"
    case visible = "visible"
    case widget = "widget"
    case width = "width"
    case xOffset = "x-offset"
}

public extension TreeViewColumnProtocol {
    /// Bind a `TreeViewColumnPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TreeViewColumnPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(tree_view_column_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum TreeViewColumnSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    case clicked = "clicked"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property`-changed is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyAlignment = "notify::alignment"
    /// The `GtkCellArea` used to layout cell renderers for this column.
    /// 
    /// If no area is specified when creating the tree view column with `gtk_tree_view_column_new_with_area()`
    /// a horizontally oriented `GtkCellAreaBox` will be used.
    case notifyCellArea = "notify::cell-area"
    case notifyClickable = "notify::clickable"
    case notifyExpand = "notify::expand"
    case notifyFixedWidth = "notify::fixed-width"
    case notifyMaxWidth = "notify::max-width"
    case notifyMinWidth = "notify::min-width"
    case notifyReorderable = "notify::reorderable"
    case notifyResizable = "notify::resizable"
    case notifySizing = "notify::sizing"
    /// Logical sort column ID this column sorts on when selected for sorting. Setting the sort column ID makes the column header
    /// clickable. Set to -1 to make the column unsortable.
    case notifySortColumnID = "notify::sort-column-id"
    case notifySortIndicator = "notify::sort-indicator"
    case notifySortOrder = "notify::sort-order"
    case notifySpacing = "notify::spacing"
    case notifyTitle = "notify::title"
    case notifyVisible = "notify::visible"
    case notifyWidget = "notify::widget"
    case notifyWidth = "notify::width"
    case notifyXOffset = "notify::x-offset"
}

public extension TreeViewColumnProtocol {
    /// Connect a `TreeViewColumnSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: TreeViewColumnSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(tree_view_column_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension TreeViewColumnProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeViewColumn` instance.
    var tree_view_column_ptr: UnsafeMutablePointer<GtkTreeViewColumn> { return ptr.assumingMemoryBound(to: GtkTreeViewColumn.self) }

    /// Adds an attribute mapping to the list in `tree_column`.  The `column` is the
    /// column of the model to get a value from, and the `attribute` is the
    /// parameter on `cell_renderer` to be set from the value. So for example
    /// if column 2 of the model contains strings, you could have the
    /// “text” attribute of a `GtkCellRendererText` get its values from
    /// column 2.
    func addAttribute(cellRenderer cell_renderer: CellRendererProtocol, attribute: UnsafePointer<gchar>, column: CInt) {
        gtk_tree_view_column_add_attribute(cast(tree_view_column_ptr), cast(cell_renderer.ptr), attribute, gint(column))
    
    }

    /// Obtains the horizontal position and size of a cell in a column. If the
    /// cell is not found in the column, `start_pos` and `width` are not changed and
    /// `false` is returned.
    func cellGetPosition(cellRenderer cell_renderer: CellRendererProtocol, xOffset x_offset: UnsafeMutablePointer<CInt>, width: UnsafeMutablePointer<CInt>) -> Bool {
        let rv = gtk_tree_view_column_cell_get_position(cast(tree_view_column_ptr), cast(cell_renderer.ptr), cast(x_offset), cast(width))
        return Bool(rv != 0)
    }

    /// Obtains the width and height needed to render the column.  This is used
    /// primarily by the `GtkTreeView`.
    func cellGetSize(cellArea cell_area: Gdk.RectangleProtocol, xOffset x_offset: UnsafeMutablePointer<CInt>, yOffset y_offset: UnsafeMutablePointer<CInt>, width: UnsafeMutablePointer<CInt>, height: UnsafeMutablePointer<CInt>) {
        gtk_tree_view_column_cell_get_size(cast(tree_view_column_ptr), cast(cell_area.ptr), cast(x_offset), cast(y_offset), cast(width), cast(height))
    
    }

    /// Returns `true` if any of the cells packed into the `tree_column` are visible.
    /// For this to be meaningful, you must first initialize the cells with
    /// `gtk_tree_view_column_cell_set_cell_data()`
    func cellIsVisible() -> Bool {
        let rv = gtk_tree_view_column_cell_is_visible(cast(tree_view_column_ptr))
        return Bool(rv != 0)
    }

    /// Sets the cell renderer based on the `tree_model` and `iter`.  That is, for
    /// every attribute mapping in `tree_column`, it will get a value from the set
    /// column on the `iter`, and use that value to set the attribute on the cell
    /// renderer.  This is used primarily by the `GtkTreeView`.
    func cellSetCellData(treeModel tree_model: TreeModelProtocol, iter: TreeIterProtocol, isExpander is_expander: Bool, isExpanded is_expanded: Bool) {
        gtk_tree_view_column_cell_set_cell_data(cast(tree_view_column_ptr), cast(tree_model.ptr), cast(iter.ptr), gboolean(is_expander ? 1 : 0), gboolean(is_expanded ? 1 : 0))
    
    }

    /// Unsets all the mappings on all renderers on the `tree_column`.
    func clear() {
        gtk_tree_view_column_clear(cast(tree_view_column_ptr))
    
    }

    /// Clears all existing attributes previously set with
    /// `gtk_tree_view_column_set_attributes()`.
    func clearAttributes(cellRenderer cell_renderer: CellRendererProtocol) {
        gtk_tree_view_column_clear_attributes(cast(tree_view_column_ptr), cast(cell_renderer.ptr))
    
    }

    /// Emits the “clicked” signal on the column.  This function will only work if
    /// `tree_column` is clickable.
    func clicked() {
        gtk_tree_view_column_clicked(cast(tree_view_column_ptr))
    
    }

    /// Sets the current keyboard focus to be at `cell`, if the column contains
    /// 2 or more editable and activatable cells.
    func focus(cell: CellRendererProtocol) {
        gtk_tree_view_column_focus_cell(cast(tree_view_column_ptr), cast(cell.ptr))
    
    }

    /// Returns the current x alignment of `tree_column`.  This value can range
    /// between 0.0 and 1.0.
    func getAlignment() -> gfloat {
        let rv = gtk_tree_view_column_get_alignment(cast(tree_view_column_ptr))
        return rv
    }

    /// Returns the button used in the treeview column header
    func getButton() -> UnsafeMutablePointer<GtkWidget>! {
        let rv = gtk_tree_view_column_get_button(cast(tree_view_column_ptr))
        return cast(rv)
    }

    /// Returns `true` if the user can click on the header for the column.
    func getClickable() -> Bool {
        let rv = gtk_tree_view_column_get_clickable(cast(tree_view_column_ptr))
        return Bool(rv != 0)
    }

    /// Returns `true` if the column expands to fill available space.
    func getExpand() -> Bool {
        let rv = gtk_tree_view_column_get_expand(cast(tree_view_column_ptr))
        return Bool(rv != 0)
    }

    /// Gets the fixed width of the column.  This may not be the actual displayed
    /// width of the column; for that, use `gtk_tree_view_column_get_width()`.
    func getFixedWidth() -> CInt {
        let rv = gtk_tree_view_column_get_fixed_width(cast(tree_view_column_ptr))
        return CInt(rv)
    }

    /// Returns the maximum width in pixels of the `tree_column`, or -1 if no maximum
    /// width is set.
    func getMaxWidth() -> CInt {
        let rv = gtk_tree_view_column_get_max_width(cast(tree_view_column_ptr))
        return CInt(rv)
    }

    /// Returns the minimum width in pixels of the `tree_column`, or -1 if no minimum
    /// width is set.
    func getMinWidth() -> CInt {
        let rv = gtk_tree_view_column_get_min_width(cast(tree_view_column_ptr))
        return CInt(rv)
    }

    /// Returns `true` if the `tree_column` can be reordered by the user.
    func getReorderable() -> Bool {
        let rv = gtk_tree_view_column_get_reorderable(cast(tree_view_column_ptr))
        return Bool(rv != 0)
    }

    /// Returns `true` if the `tree_column` can be resized by the end user.
    func getResizable() -> Bool {
        let rv = gtk_tree_view_column_get_resizable(cast(tree_view_column_ptr))
        return Bool(rv != 0)
    }

    /// Returns the current type of `tree_column`.
    func getSizing() -> GtkTreeViewColumnSizing {
        let rv = gtk_tree_view_column_get_sizing(cast(tree_view_column_ptr))
        return rv
    }

    /// Gets the logical `sort_column_id` that the model sorts on when this
    /// column is selected for sorting.
    /// See `gtk_tree_view_column_set_sort_column_id()`.
    func getSortColumnID() -> CInt {
        let rv = gtk_tree_view_column_get_sort_column_id(cast(tree_view_column_ptr))
        return CInt(rv)
    }

    /// Gets the value set by `gtk_tree_view_column_set_sort_indicator()`.
    func getSortIndicator() -> Bool {
        let rv = gtk_tree_view_column_get_sort_indicator(cast(tree_view_column_ptr))
        return Bool(rv != 0)
    }

    /// Gets the value set by `gtk_tree_view_column_set_sort_order()`.
    func getSortOrder() -> GtkSortType {
        let rv = gtk_tree_view_column_get_sort_order(cast(tree_view_column_ptr))
        return rv
    }

    /// Returns the spacing of `tree_column`.
    func getSpacing() -> CInt {
        let rv = gtk_tree_view_column_get_spacing(cast(tree_view_column_ptr))
        return CInt(rv)
    }

    /// Returns the title of the widget.
    func getTitle() -> String! {
        let rv = gtk_tree_view_column_get_title(cast(tree_view_column_ptr))
        return rv.map { String(cString: UnsafePointer<CChar>($0)) }
    }

    /// Returns the `GtkTreeView` wherein `tree_column` has been inserted.
    /// If `column` is currently not inserted in any tree view, `nil` is
    /// returned.
    func getTreeView() -> UnsafeMutablePointer<GtkWidget>! {
        let rv = gtk_tree_view_column_get_tree_view(cast(tree_view_column_ptr))
        return cast(rv)
    }

    /// Returns `true` if `tree_column` is visible.
    func getVisible() -> Bool {
        let rv = gtk_tree_view_column_get_visible(cast(tree_view_column_ptr))
        return Bool(rv != 0)
    }

    /// Returns the `GtkWidget` in the button on the column header.
    /// If a custom widget has not been set then `nil` is returned.
    func getWidget() -> UnsafeMutablePointer<GtkWidget>! {
        let rv = gtk_tree_view_column_get_widget(cast(tree_view_column_ptr))
        return cast(rv)
    }

    /// Returns the current size of `tree_column` in pixels.
    func getWidth() -> CInt {
        let rv = gtk_tree_view_column_get_width(cast(tree_view_column_ptr))
        return CInt(rv)
    }

    /// Returns the current X offset of `tree_column` in pixels.
    func getXOffset() -> CInt {
        let rv = gtk_tree_view_column_get_x_offset(cast(tree_view_column_ptr))
        return CInt(rv)
    }

    /// Adds the `cell` to end of the column. If `expand` is `false`, then the `cell`
    /// is allocated no more space than it needs. Any unused space is divided
    /// evenly between cells for which `expand` is `true`.
    func packEnd(cell: CellRendererProtocol, expand: Bool) {
        gtk_tree_view_column_pack_end(cast(tree_view_column_ptr), cast(cell.ptr), gboolean(expand ? 1 : 0))
    
    }

    /// Packs the `cell` into the beginning of the column. If `expand` is `false`, then
    /// the `cell` is allocated no more space than it needs. Any unused space is divided
    /// evenly between cells for which `expand` is `true`.
    func packStart(cell: CellRendererProtocol, expand: Bool) {
        gtk_tree_view_column_pack_start(cast(tree_view_column_ptr), cast(cell.ptr), gboolean(expand ? 1 : 0))
    
    }

    /// Flags the column, and the cell renderers added to this column, to have
    /// their sizes renegotiated.
    func queueResize() {
        gtk_tree_view_column_queue_resize(cast(tree_view_column_ptr))
    
    }

    /// Sets the alignment of the title or custom widget inside the column header.
    /// The alignment determines its location inside the button -- 0.0 for left, 0.5
    /// for center, 1.0 for right.
    func setAlignment(xalign: gfloat) {
        gtk_tree_view_column_set_alignment(cast(tree_view_column_ptr), xalign)
    
    }


    // *** setAttributes() is not available because it has a varargs (...) parameter!


    /// Sets the `GtkTreeCellDataFunc` to use for the column.  This
    /// function is used instead of the standard attributes mapping for
    /// setting the column value, and should set the value of `tree_column`'s
    /// cell renderer as appropriate.  `func` may be `nil` to remove an
    /// older one.
    func setCellDataFunc(cellRenderer cell_renderer: CellRendererProtocol, func_: @escaping TreeCellDataFunc, funcData func_data: UnsafeMutableRawPointer, destroy: @escaping GLib.DestroyNotify) {
        gtk_tree_view_column_set_cell_data_func(cast(tree_view_column_ptr), cast(cell_renderer.ptr), func_, cast(func_data), destroy)
    
    }

    /// Sets the header to be active if `clickable` is `true`.  When the header is
    /// active, then it can take keyboard focus, and can be clicked.
    func set(clickable: Bool) {
        gtk_tree_view_column_set_clickable(cast(tree_view_column_ptr), gboolean(clickable ? 1 : 0))
    
    }

    /// Sets the column to take available extra space.  This space is shared equally
    /// amongst all columns that have the expand set to `true`.  If no column has this
    /// option set, then the last column gets all extra space.  By default, every
    /// column is created with this `false`.
    /// 
    /// Along with “fixed-width”, the “expand” property changes when the column is
    /// resized by the user.
    func set(expand: Bool) {
        gtk_tree_view_column_set_expand(cast(tree_view_column_ptr), gboolean(expand ? 1 : 0))
    
    }

    /// If `fixed_width` is not -1, sets the fixed width of `tree_column`; otherwise
    /// unsets it.  The effective value of `fixed_width` is clamped between the
    /// minimum and maximum width of the column; however, the value stored in the
    /// “fixed-width” property is not clamped.  If the column sizing is
    /// `GTK_TREE_VIEW_COLUMN_GROW_ONLY` or `GTK_TREE_VIEW_COLUMN_AUTOSIZE`, setting
    /// a fixed width overrides the automatically calculated width.  Note that
    /// `fixed_width` is only a hint to GTK+; the width actually allocated to the
    /// column may be greater or less than requested.
    /// 
    /// Along with “expand”, the “fixed-width” property changes when the column is
    /// resized by the user.
    func set(fixedWidth fixed_width: CInt) {
        gtk_tree_view_column_set_fixed_width(cast(tree_view_column_ptr), gint(fixed_width))
    
    }

    /// Sets the maximum width of the `tree_column`.  If `max_width` is -1, then the
    /// maximum width is unset.  Note, the column can actually be wider than max
    /// width if it’s the last column in a view.  In this case, the column expands to
    /// fill any extra space.
    func set(maxWidth max_width: CInt) {
        gtk_tree_view_column_set_max_width(cast(tree_view_column_ptr), gint(max_width))
    
    }

    /// Sets the minimum width of the `tree_column`.  If `min_width` is -1, then the
    /// minimum width is unset.
    func set(minWidth min_width: CInt) {
        gtk_tree_view_column_set_min_width(cast(tree_view_column_ptr), gint(min_width))
    
    }

    /// If `reorderable` is `true`, then the column can be reordered by the end user
    /// dragging the header.
    func set(reorderable: Bool) {
        gtk_tree_view_column_set_reorderable(cast(tree_view_column_ptr), gboolean(reorderable ? 1 : 0))
    
    }

    /// If `resizable` is `true`, then the user can explicitly resize the column by
    /// grabbing the outer edge of the column button.  If resizable is `true` and
    /// sizing mode of the column is `GTK_TREE_VIEW_COLUMN_AUTOSIZE`, then the sizing
    /// mode is changed to `GTK_TREE_VIEW_COLUMN_GROW_ONLY`.
    func set(resizable: Bool) {
        gtk_tree_view_column_set_resizable(cast(tree_view_column_ptr), gboolean(resizable ? 1 : 0))
    
    }

    /// Sets the growth behavior of `tree_column` to `type`.
    func setSizing(type: TreeViewColumnSizing) {
        gtk_tree_view_column_set_sizing(cast(tree_view_column_ptr), type)
    
    }

    /// Sets the logical `sort_column_id` that this column sorts on when this column
    /// is selected for sorting.  Doing so makes the column header clickable.
    func set(sortColumnID sort_column_id: CInt) {
        gtk_tree_view_column_set_sort_column_id(cast(tree_view_column_ptr), gint(sort_column_id))
    
    }

    /// Call this function with a `setting` of `true` to display an arrow in
    /// the header button indicating the column is sorted. Call
    /// `gtk_tree_view_column_set_sort_order()` to change the direction of
    /// the arrow.
    func setSortIndicator(setting: Bool) {
        gtk_tree_view_column_set_sort_indicator(cast(tree_view_column_ptr), gboolean(setting ? 1 : 0))
    
    }

    /// Changes the appearance of the sort indicator.
    /// 
    /// This does not actually sort the model.  Use
    /// `gtk_tree_view_column_set_sort_column_id()` if you want automatic sorting
    /// support.  This function is primarily for custom sorting behavior, and should
    /// be used in conjunction with `gtk_tree_sortable_set_sort_column_id()` to do
    /// that. For custom models, the mechanism will vary.
    /// 
    /// The sort indicator changes direction to indicate normal sort or reverse sort.
    /// Note that you must have the sort indicator enabled to see anything when
    /// calling this function; see `gtk_tree_view_column_set_sort_indicator()`.
    func setSort(order: SortType) {
        gtk_tree_view_column_set_sort_order(cast(tree_view_column_ptr), order)
    
    }

    /// Sets the spacing field of `tree_column`, which is the number of pixels to
    /// place between cell renderers packed into it.
    func set(spacing: CInt) {
        gtk_tree_view_column_set_spacing(cast(tree_view_column_ptr), gint(spacing))
    
    }

    /// Sets the title of the `tree_column`.  If a custom widget has been set, then
    /// this value is ignored.
    func set(title: UnsafePointer<gchar>) {
        gtk_tree_view_column_set_title(cast(tree_view_column_ptr), title)
    
    }

    /// Sets the visibility of `tree_column`.
    func set(visible: Bool) {
        gtk_tree_view_column_set_visible(cast(tree_view_column_ptr), gboolean(visible ? 1 : 0))
    
    }

    /// Sets the widget in the header to be `widget`.  If widget is `nil`, then the
    /// header button is set with a `GtkLabel` set to the title of `tree_column`.
    func set(widget: WidgetProtocol) {
        gtk_tree_view_column_set_widget(cast(tree_view_column_ptr), cast(widget.ptr))
    
    }
    var alignment: gfloat {
        /// Returns the current x alignment of `tree_column`.  This value can range
        /// between 0.0 and 1.0.
        get {
            let rv = gtk_tree_view_column_get_alignment(cast(tree_view_column_ptr))
            return rv
        }
        /// Sets the alignment of the title or custom widget inside the column header.
        /// The alignment determines its location inside the button -- 0.0 for left, 0.5
        /// for center, 1.0 for right.
        nonmutating set {
            gtk_tree_view_column_set_alignment(cast(tree_view_column_ptr), newValue)
        }
    }

    /// Returns the button used in the treeview column header
    var button: UnsafeMutablePointer<GtkWidget>! {
        /// Returns the button used in the treeview column header
        get {
            let rv = gtk_tree_view_column_get_button(cast(tree_view_column_ptr))
            return cast(rv)
        }
    }

    var clickable: Bool {
        /// Returns `true` if the user can click on the header for the column.
        get {
            let rv = gtk_tree_view_column_get_clickable(cast(tree_view_column_ptr))
            return Bool(rv != 0)
        }
        /// Sets the header to be active if `clickable` is `true`.  When the header is
        /// active, then it can take keyboard focus, and can be clicked.
        nonmutating set {
            gtk_tree_view_column_set_clickable(cast(tree_view_column_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    var expand: Bool {
        /// Returns `true` if the column expands to fill available space.
        get {
            let rv = gtk_tree_view_column_get_expand(cast(tree_view_column_ptr))
            return Bool(rv != 0)
        }
        /// Sets the column to take available extra space.  This space is shared equally
        /// amongst all columns that have the expand set to `true`.  If no column has this
        /// option set, then the last column gets all extra space.  By default, every
        /// column is created with this `false`.
        /// 
        /// Along with “fixed-width”, the “expand” property changes when the column is
        /// resized by the user.
        nonmutating set {
            gtk_tree_view_column_set_expand(cast(tree_view_column_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Gets the fixed width of the column.  This may not be the actual displayed
    /// width of the column; for that, use `gtk_tree_view_column_get_width()`.
    var fixedWidth: CInt {
        /// Gets the fixed width of the column.  This may not be the actual displayed
        /// width of the column; for that, use `gtk_tree_view_column_get_width()`.
        get {
            let rv = gtk_tree_view_column_get_fixed_width(cast(tree_view_column_ptr))
            return CInt(rv)
        }
        /// If `fixed_width` is not -1, sets the fixed width of `tree_column`; otherwise
        /// unsets it.  The effective value of `fixed_width` is clamped between the
        /// minimum and maximum width of the column; however, the value stored in the
        /// “fixed-width” property is not clamped.  If the column sizing is
        /// `GTK_TREE_VIEW_COLUMN_GROW_ONLY` or `GTK_TREE_VIEW_COLUMN_AUTOSIZE`, setting
        /// a fixed width overrides the automatically calculated width.  Note that
        /// `fixed_width` is only a hint to GTK+; the width actually allocated to the
        /// column may be greater or less than requested.
        /// 
        /// Along with “expand”, the “fixed-width” property changes when the column is
        /// resized by the user.
        nonmutating set {
            gtk_tree_view_column_set_fixed_width(cast(tree_view_column_ptr), gint(newValue))
        }
    }

    /// Returns the maximum width in pixels of the `tree_column`, or -1 if no maximum
    /// width is set.
    var maxWidth: CInt {
        /// Returns the maximum width in pixels of the `tree_column`, or -1 if no maximum
        /// width is set.
        get {
            let rv = gtk_tree_view_column_get_max_width(cast(tree_view_column_ptr))
            return CInt(rv)
        }
        /// Sets the maximum width of the `tree_column`.  If `max_width` is -1, then the
        /// maximum width is unset.  Note, the column can actually be wider than max
        /// width if it’s the last column in a view.  In this case, the column expands to
        /// fill any extra space.
        nonmutating set {
            gtk_tree_view_column_set_max_width(cast(tree_view_column_ptr), gint(newValue))
        }
    }

    /// Returns the minimum width in pixels of the `tree_column`, or -1 if no minimum
    /// width is set.
    var minWidth: CInt {
        /// Returns the minimum width in pixels of the `tree_column`, or -1 if no minimum
        /// width is set.
        get {
            let rv = gtk_tree_view_column_get_min_width(cast(tree_view_column_ptr))
            return CInt(rv)
        }
        /// Sets the minimum width of the `tree_column`.  If `min_width` is -1, then the
        /// minimum width is unset.
        nonmutating set {
            gtk_tree_view_column_set_min_width(cast(tree_view_column_ptr), gint(newValue))
        }
    }

    var reorderable: Bool {
        /// Returns `true` if the `tree_column` can be reordered by the user.
        get {
            let rv = gtk_tree_view_column_get_reorderable(cast(tree_view_column_ptr))
            return Bool(rv != 0)
        }
        /// If `reorderable` is `true`, then the column can be reordered by the end user
        /// dragging the header.
        nonmutating set {
            gtk_tree_view_column_set_reorderable(cast(tree_view_column_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    var resizable: Bool {
        /// Returns `true` if the `tree_column` can be resized by the end user.
        get {
            let rv = gtk_tree_view_column_get_resizable(cast(tree_view_column_ptr))
            return Bool(rv != 0)
        }
        /// If `resizable` is `true`, then the user can explicitly resize the column by
        /// grabbing the outer edge of the column button.  If resizable is `true` and
        /// sizing mode of the column is `GTK_TREE_VIEW_COLUMN_AUTOSIZE`, then the sizing
        /// mode is changed to `GTK_TREE_VIEW_COLUMN_GROW_ONLY`.
        nonmutating set {
            gtk_tree_view_column_set_resizable(cast(tree_view_column_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    var sizing: GtkTreeViewColumnSizing {
        /// Returns the current type of `tree_column`.
        get {
            let rv = gtk_tree_view_column_get_sizing(cast(tree_view_column_ptr))
            return rv
        }
        /// Sets the growth behavior of `tree_column` to `type`.
        nonmutating set {
            gtk_tree_view_column_set_sizing(cast(tree_view_column_ptr), newValue)
        }
    }

    /// Gets the logical `sort_column_id` that the model sorts on when this
    /// column is selected for sorting.
    /// See `gtk_tree_view_column_set_sort_column_id()`.
    var sortColumnID: CInt {
        /// Gets the logical `sort_column_id` that the model sorts on when this
        /// column is selected for sorting.
        /// See `gtk_tree_view_column_set_sort_column_id()`.
        get {
            let rv = gtk_tree_view_column_get_sort_column_id(cast(tree_view_column_ptr))
            return CInt(rv)
        }
        /// Sets the logical `sort_column_id` that this column sorts on when this column
        /// is selected for sorting.  Doing so makes the column header clickable.
        nonmutating set {
            gtk_tree_view_column_set_sort_column_id(cast(tree_view_column_ptr), gint(newValue))
        }
    }

    /// Gets the value set by `gtk_tree_view_column_set_sort_indicator()`.
    var sortIndicator: Bool {
        /// Gets the value set by `gtk_tree_view_column_set_sort_indicator()`.
        get {
            let rv = gtk_tree_view_column_get_sort_indicator(cast(tree_view_column_ptr))
            return Bool(rv != 0)
        }
        /// Call this function with a `setting` of `true` to display an arrow in
        /// the header button indicating the column is sorted. Call
        /// `gtk_tree_view_column_set_sort_order()` to change the direction of
        /// the arrow.
        nonmutating set {
            gtk_tree_view_column_set_sort_indicator(cast(tree_view_column_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    /// Gets the value set by `gtk_tree_view_column_set_sort_order()`.
    var sortOrder: GtkSortType {
        /// Gets the value set by `gtk_tree_view_column_set_sort_order()`.
        get {
            let rv = gtk_tree_view_column_get_sort_order(cast(tree_view_column_ptr))
            return rv
        }
        /// Changes the appearance of the sort indicator.
        /// 
        /// This does not actually sort the model.  Use
        /// `gtk_tree_view_column_set_sort_column_id()` if you want automatic sorting
        /// support.  This function is primarily for custom sorting behavior, and should
        /// be used in conjunction with `gtk_tree_sortable_set_sort_column_id()` to do
        /// that. For custom models, the mechanism will vary.
        /// 
        /// The sort indicator changes direction to indicate normal sort or reverse sort.
        /// Note that you must have the sort indicator enabled to see anything when
        /// calling this function; see `gtk_tree_view_column_set_sort_indicator()`.
        nonmutating set {
            gtk_tree_view_column_set_sort_order(cast(tree_view_column_ptr), newValue)
        }
    }

    var spacing: CInt {
        /// Returns the spacing of `tree_column`.
        get {
            let rv = gtk_tree_view_column_get_spacing(cast(tree_view_column_ptr))
            return CInt(rv)
        }
        /// Sets the spacing field of `tree_column`, which is the number of pixels to
        /// place between cell renderers packed into it.
        nonmutating set {
            gtk_tree_view_column_set_spacing(cast(tree_view_column_ptr), gint(newValue))
        }
    }

    var title: String! {
        /// Returns the title of the widget.
        get {
            let rv = gtk_tree_view_column_get_title(cast(tree_view_column_ptr))
            return rv.map { String(cString: UnsafePointer<CChar>($0)) }
        }
        /// Sets the title of the `tree_column`.  If a custom widget has been set, then
        /// this value is ignored.
        nonmutating set {
            gtk_tree_view_column_set_title(cast(tree_view_column_ptr), newValue)
        }
    }

    /// Returns the `GtkTreeView` wherein `tree_column` has been inserted.
    /// If `column` is currently not inserted in any tree view, `nil` is
    /// returned.
    var treeView: UnsafeMutablePointer<GtkWidget>! {
        /// Returns the `GtkTreeView` wherein `tree_column` has been inserted.
        /// If `column` is currently not inserted in any tree view, `nil` is
        /// returned.
        get {
            let rv = gtk_tree_view_column_get_tree_view(cast(tree_view_column_ptr))
            return cast(rv)
        }
    }

    var visible: Bool {
        /// Returns `true` if `tree_column` is visible.
        get {
            let rv = gtk_tree_view_column_get_visible(cast(tree_view_column_ptr))
            return Bool(rv != 0)
        }
        /// Sets the visibility of `tree_column`.
        nonmutating set {
            gtk_tree_view_column_set_visible(cast(tree_view_column_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    var widget: UnsafeMutablePointer<GtkWidget>! {
        /// Returns the `GtkWidget` in the button on the column header.
        /// If a custom widget has not been set then `nil` is returned.
        get {
            let rv = gtk_tree_view_column_get_widget(cast(tree_view_column_ptr))
            return cast(rv)
        }
        /// Sets the widget in the header to be `widget`.  If widget is `nil`, then the
        /// header button is set with a `GtkLabel` set to the title of `tree_column`.
        nonmutating set {
            gtk_tree_view_column_set_widget(cast(tree_view_column_ptr), cast(newValue))
        }
    }

    var width: CInt {
        /// Returns the current size of `tree_column` in pixels.
        get {
            let rv = gtk_tree_view_column_get_width(cast(tree_view_column_ptr))
            return CInt(rv)
        }
    }

    /// Returns the current X offset of `tree_column` in pixels.
    var xOffset: CInt {
        /// Returns the current X offset of `tree_column` in pixels.
        get {
            let rv = gtk_tree_view_column_get_x_offset(cast(tree_view_column_ptr))
            return CInt(rv)
        }
    }
}



// MARK: - UIManager Class

/// The `UIManagerProtocol` protocol exposes the methods and properties of an underlying `GtkUIManager` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `UIManager`.
/// Alternatively, use `UIManagerRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// > GtkUIManager is deprecated since GTK+ 3.10. To construct user interfaces
/// > from XML definitions, you should use `GtkBuilder`, `GMenuModel`, et al. To
/// > work with actions, use `GAction`, `GtkActionable` et al. These newer classes
/// > support richer functionality and integration with various desktop shells.
/// > It should be possible to migrate most/all functionality from GtkUIManager.
/// 
/// A `GtkUIManager` constructs a user interface (menus and toolbars) from
/// one or more UI definitions, which reference actions from one or more
/// action groups.
/// 
/// # UI Definitions # <a name="XML-UI"></a>
/// 
/// The UI definitions are specified in an XML format which can be
/// roughly described by the following DTD.
/// 
/// > Do not confuse the GtkUIManager UI Definitions described here with
/// > the similarly named [GtkBuilder UI Definitions](#BUILDER-UI).
/// 
/// ```
/// <!ELEMENT menubar     (menuitem|separator|placeholder|menu)* >
/// <!ELEMENT menu        (menuitem|separator|placeholder|menu)* >
/// <!ELEMENT popup       (menuitem|separator|placeholder|menu)* >
/// <!ELEMENT toolbar     (toolitem|separator|placeholder)* >
/// <!ELEMENT placeholder (menuitem|toolitem|separator|placeholder|menu)* >
/// <!ELEMENT menuitem     EMPTY >
/// <!ELEMENT toolitem     (menu?) >
/// <!ELEMENT separator    EMPTY >
/// <!ELEMENT accelerator  EMPTY >
/// <!ATTLIST menubar      name                      #IMPLIED
///                        action                    #IMPLIED >
/// <!ATTLIST toolbar      name                      #IMPLIED
///                        action                    #IMPLIED >
/// <!ATTLIST popup        name                      #IMPLIED
///                        action                    #IMPLIED
///                        accelerators (true|false) #IMPLIED >
/// <!ATTLIST placeholder  name                      #IMPLIED
///                        action                    #IMPLIED >
/// <!ATTLIST separator    name                      #IMPLIED
///                        action                    #IMPLIED
///                        expand       (true|false) #IMPLIED >
/// <!ATTLIST menu         name                      #IMPLIED
///                        action                    #REQUIRED
///                        position     (top|bot)    #IMPLIED >
/// <!ATTLIST menuitem     name                      #IMPLIED
///                        action                    #REQUIRED
///                        position     (top|bot)    #IMPLIED
///                        always-show-image (true|false) #IMPLIED >
/// <!ATTLIST toolitem     name                      #IMPLIED
///                        action                    #REQUIRED
///                        position     (top|bot)    #IMPLIED >
/// <!ATTLIST accelerator  name                      #IMPLIED
///                        action                    #REQUIRED >
/// ```
/// 
/// There are some additional restrictions beyond those specified in the
/// DTD, e.g. every toolitem must have a toolbar in its anchestry and
/// every menuitem must have a menubar or popup in its anchestry. Since
/// a `GMarkupParser` is used to parse the UI description, it must not only
/// be valid XML, but valid markup.
/// 
/// If a name is not specified, it defaults to the action. If an action is
/// not specified either, the element name is used. The name and action
/// attributes must not contain “/” characters after parsing (since that
/// would mess up path lookup) and must be usable as XML attributes when
/// enclosed in doublequotes, thus they must not “"” characters or references
/// to the &quot; entity.
/// 
/// # A UI definition #
/// 
/// ```
/// <ui>
///   <menubar>
///     <menu name="FileMenu" action="FileMenuAction">
///       <menuitem name="New" action="New2Action" />
///       <placeholder name="FileMenuAdditions" />
///     </menu>
///     <menu name="JustifyMenu" action="JustifyMenuAction">
///       <menuitem name="Left" action="justify-left"/>
///       <menuitem name="Centre" action="justify-center"/>
///       <menuitem name="Right" action="justify-right"/>
///       <menuitem name="Fill" action="justify-fill"/>
///     </menu>
///   </menubar>
///   <toolbar action="toolbar1">
///     <placeholder name="JustifyToolItems">
///       <separator/>
///       <toolitem name="Left" action="justify-left"/>
///       <toolitem name="Centre" action="justify-center"/>
///       <toolitem name="Right" action="justify-right"/>
///       <toolitem name="Fill" action="justify-fill"/>
///       <separator/>
///     </placeholder>
///   </toolbar>
/// </ui>
/// ```
/// 
/// The constructed widget hierarchy is very similar to the element tree
/// of the XML, with the exception that placeholders are merged into their
/// parents. The correspondence of XML elements to widgets should be
/// almost obvious:
/// 
/// - menubar
/// 
///    a `GtkMenuBar`
/// 
/// - toolbar
/// 
///    a `GtkToolbar`
/// 
/// - popup
/// 
///    a toplevel `GtkMenu`
/// 
/// - menu
/// 
///    a `GtkMenu` attached to a menuitem
/// 
/// - menuitem
/// 
///    a `GtkMenuItem` subclass, the exact type depends on the action
/// 
/// - toolitem
/// 
///    a `GtkToolItem` subclass, the exact type depends on the
///    action. Note that toolitem elements may contain a menu element,
///    but only if their associated action specifies a
///    `GtkMenuToolButton` as proxy.
/// 
/// - separator
/// 
///    a `GtkSeparatorMenuItem` or `GtkSeparatorToolItem`
/// 
/// - accelerator
/// 
///    a keyboard accelerator
/// 
/// The “position” attribute determines where a constructed widget is positioned
/// wrt. to its siblings in the partially constructed tree. If it is
/// “top”, the widget is prepended, otherwise it is appended.
/// 
/// # UI Merging # <a name="UI-Merging"></a>
/// 
/// The most remarkable feature of `GtkUIManager` is that it can overlay a set
/// of menuitems and toolitems over another one, and demerge them later.
/// 
/// Merging is done based on the names of the XML elements. Each element is
/// identified by a path which consists of the names of its anchestors, separated
/// by slashes. For example, the menuitem named “Left” in the example above
/// has the path `/ui/menubar/JustifyMenu/Left` and the
/// toolitem with the same name has path
/// `/ui/toolbar1/JustifyToolItems/Left`.
/// 
/// # Accelerators #
/// 
/// Every action has an accelerator path. Accelerators are installed together
/// with menuitem proxies, but they can also be explicitly added with
/// <accelerator> elements in the UI definition. This makes it possible to
/// have accelerators for actions even if they have no visible proxies.
/// 
/// # Smart Separators # <a name="Smart-Separators"></a>
/// 
/// The separators created by `GtkUIManager` are “smart”, i.e. they do not show up
/// in the UI unless they end up between two visible menu or tool items. Separators
/// which are located at the very beginning or end of the menu or toolbar
/// containing them, or multiple separators next to each other, are hidden. This
/// is a useful feature, since the merging of UI elements from multiple sources
/// can make it hard or impossible to determine in advance whether a separator
/// will end up in such an unfortunate position.
/// 
/// For separators in toolbars, you can set `expand="true"` to
/// turn them from a small, visible separator to an expanding, invisible one.
/// Toolitems following an expanding separator are effectively right-aligned.
/// 
/// # Empty Menus
/// 
/// Submenus pose similar problems to separators inconnection with merging. It is
/// impossible to know in advance whether they will end up empty after merging.
/// `GtkUIManager` offers two ways to treat empty submenus:
/// 
/// - make them disappear by hiding the menu item they’re attached to
/// 
/// - add an insensitive “Empty” item
/// 
/// The behaviour is chosen based on the “hide_if_empty” property of the action
/// to which the submenu is associated.
/// 
/// # GtkUIManager as GtkBuildable # <a name="GtkUIManager-BUILDER-UI"></a>
/// 
/// The GtkUIManager implementation of the GtkBuildable interface accepts
/// GtkActionGroup objects as <child> elements in UI definitions.
/// 
/// A GtkUIManager UI definition as described above can be embedded in
/// an GtkUIManager <object> element in a GtkBuilder UI definition.
/// 
/// The widgets that are constructed by a GtkUIManager can be embedded in
/// other parts of the constructed user interface with the help of the
/// “constructor” attribute. See the example below.
/// 
/// ## An embedded GtkUIManager UI definition
/// 
/// ```
/// <object class="GtkUIManager" id="uiman">
///   <child>
///     <object class="GtkActionGroup" id="actiongroup">
///       <child>
///         <object class="GtkAction" id="file">
///           <property name="label">_File</property>
///         </object>
///       </child>
///     </object>
///   </child>
///   <ui>
///     <menubar name="menubar1">
///       <menu action="file">
///       </menu>
///     </menubar>
///   </ui>
/// </object>
/// <object class="GtkWindow" id="main-window">
///   <child>
///     <object class="GtkMenuBar" id="menubar1" constructor="uiman"/>
///   </child>
/// </object>
/// ```
/// 
public protocol UIManagerProtocol: GLibObject.ObjectProtocol, BuildableProtocol {
    /// Untyped pointer to the underlying `GtkUIManager` instance.
    var ptr: UnsafeMutableRawPointer { get }

    /// Typed pointer to the underlying `GtkUIManager` instance.
    var ui_manager_ptr: UnsafeMutablePointer<GtkUIManager> { get }
}

/// The `UIManagerRef` type acts as a lightweight Swift reference to an underlying `GtkUIManager` instance.
/// It exposes methods that can operate on this data type through `UIManagerProtocol` conformance.
/// Use `UIManagerRef` only as an `unowned` reference to an existing `GtkUIManager` instance.
///
/// > GtkUIManager is deprecated since GTK+ 3.10. To construct user interfaces
/// > from XML definitions, you should use `GtkBuilder`, `GMenuModel`, et al. To
/// > work with actions, use `GAction`, `GtkActionable` et al. These newer classes
/// > support richer functionality and integration with various desktop shells.
/// > It should be possible to migrate most/all functionality from GtkUIManager.
/// 
/// A `GtkUIManager` constructs a user interface (menus and toolbars) from
/// one or more UI definitions, which reference actions from one or more
/// action groups.
/// 
/// # UI Definitions # <a name="XML-UI"></a>
/// 
/// The UI definitions are specified in an XML format which can be
/// roughly described by the following DTD.
/// 
/// > Do not confuse the GtkUIManager UI Definitions described here with
/// > the similarly named [GtkBuilder UI Definitions](#BUILDER-UI).
/// 
/// ```
/// <!ELEMENT menubar     (menuitem|separator|placeholder|menu)* >
/// <!ELEMENT menu        (menuitem|separator|placeholder|menu)* >
/// <!ELEMENT popup       (menuitem|separator|placeholder|menu)* >
/// <!ELEMENT toolbar     (toolitem|separator|placeholder)* >
/// <!ELEMENT placeholder (menuitem|toolitem|separator|placeholder|menu)* >
/// <!ELEMENT menuitem     EMPTY >
/// <!ELEMENT toolitem     (menu?) >
/// <!ELEMENT separator    EMPTY >
/// <!ELEMENT accelerator  EMPTY >
/// <!ATTLIST menubar      name                      #IMPLIED
///                        action                    #IMPLIED >
/// <!ATTLIST toolbar      name                      #IMPLIED
///                        action                    #IMPLIED >
/// <!ATTLIST popup        name                      #IMPLIED
///                        action                    #IMPLIED
///                        accelerators (true|false) #IMPLIED >
/// <!ATTLIST placeholder  name                      #IMPLIED
///                        action                    #IMPLIED >
/// <!ATTLIST separator    name                      #IMPLIED
///                        action                    #IMPLIED
///                        expand       (true|false) #IMPLIED >
/// <!ATTLIST menu         name                      #IMPLIED
///                        action                    #REQUIRED
///                        position     (top|bot)    #IMPLIED >
/// <!ATTLIST menuitem     name                      #IMPLIED
///                        action                    #REQUIRED
///                        position     (top|bot)    #IMPLIED
///                        always-show-image (true|false) #IMPLIED >
/// <!ATTLIST toolitem     name                      #IMPLIED
///                        action                    #REQUIRED
///                        position     (top|bot)    #IMPLIED >
/// <!ATTLIST accelerator  name                      #IMPLIED
///                        action                    #REQUIRED >
/// ```
/// 
/// There are some additional restrictions beyond those specified in the
/// DTD, e.g. every toolitem must have a toolbar in its anchestry and
/// every menuitem must have a menubar or popup in its anchestry. Since
/// a `GMarkupParser` is used to parse the UI description, it must not only
/// be valid XML, but valid markup.
/// 
/// If a name is not specified, it defaults to the action. If an action is
/// not specified either, the element name is used. The name and action
/// attributes must not contain “/” characters after parsing (since that
/// would mess up path lookup) and must be usable as XML attributes when
/// enclosed in doublequotes, thus they must not “"” characters or references
/// to the &quot; entity.
/// 
/// # A UI definition #
/// 
/// ```
/// <ui>
///   <menubar>
///     <menu name="FileMenu" action="FileMenuAction">
///       <menuitem name="New" action="New2Action" />
///       <placeholder name="FileMenuAdditions" />
///     </menu>
///     <menu name="JustifyMenu" action="JustifyMenuAction">
///       <menuitem name="Left" action="justify-left"/>
///       <menuitem name="Centre" action="justify-center"/>
///       <menuitem name="Right" action="justify-right"/>
///       <menuitem name="Fill" action="justify-fill"/>
///     </menu>
///   </menubar>
///   <toolbar action="toolbar1">
///     <placeholder name="JustifyToolItems">
///       <separator/>
///       <toolitem name="Left" action="justify-left"/>
///       <toolitem name="Centre" action="justify-center"/>
///       <toolitem name="Right" action="justify-right"/>
///       <toolitem name="Fill" action="justify-fill"/>
///       <separator/>
///     </placeholder>
///   </toolbar>
/// </ui>
/// ```
/// 
/// The constructed widget hierarchy is very similar to the element tree
/// of the XML, with the exception that placeholders are merged into their
/// parents. The correspondence of XML elements to widgets should be
/// almost obvious:
/// 
/// - menubar
/// 
///    a `GtkMenuBar`
/// 
/// - toolbar
/// 
///    a `GtkToolbar`
/// 
/// - popup
/// 
///    a toplevel `GtkMenu`
/// 
/// - menu
/// 
///    a `GtkMenu` attached to a menuitem
/// 
/// - menuitem
/// 
///    a `GtkMenuItem` subclass, the exact type depends on the action
/// 
/// - toolitem
/// 
///    a `GtkToolItem` subclass, the exact type depends on the
///    action. Note that toolitem elements may contain a menu element,
///    but only if their associated action specifies a
///    `GtkMenuToolButton` as proxy.
/// 
/// - separator
/// 
///    a `GtkSeparatorMenuItem` or `GtkSeparatorToolItem`
/// 
/// - accelerator
/// 
///    a keyboard accelerator
/// 
/// The “position” attribute determines where a constructed widget is positioned
/// wrt. to its siblings in the partially constructed tree. If it is
/// “top”, the widget is prepended, otherwise it is appended.
/// 
/// # UI Merging # <a name="UI-Merging"></a>
/// 
/// The most remarkable feature of `GtkUIManager` is that it can overlay a set
/// of menuitems and toolitems over another one, and demerge them later.
/// 
/// Merging is done based on the names of the XML elements. Each element is
/// identified by a path which consists of the names of its anchestors, separated
/// by slashes. For example, the menuitem named “Left” in the example above
/// has the path `/ui/menubar/JustifyMenu/Left` and the
/// toolitem with the same name has path
/// `/ui/toolbar1/JustifyToolItems/Left`.
/// 
/// # Accelerators #
/// 
/// Every action has an accelerator path. Accelerators are installed together
/// with menuitem proxies, but they can also be explicitly added with
/// <accelerator> elements in the UI definition. This makes it possible to
/// have accelerators for actions even if they have no visible proxies.
/// 
/// # Smart Separators # <a name="Smart-Separators"></a>
/// 
/// The separators created by `GtkUIManager` are “smart”, i.e. they do not show up
/// in the UI unless they end up between two visible menu or tool items. Separators
/// which are located at the very beginning or end of the menu or toolbar
/// containing them, or multiple separators next to each other, are hidden. This
/// is a useful feature, since the merging of UI elements from multiple sources
/// can make it hard or impossible to determine in advance whether a separator
/// will end up in such an unfortunate position.
/// 
/// For separators in toolbars, you can set `expand="true"` to
/// turn them from a small, visible separator to an expanding, invisible one.
/// Toolitems following an expanding separator are effectively right-aligned.
/// 
/// # Empty Menus
/// 
/// Submenus pose similar problems to separators inconnection with merging. It is
/// impossible to know in advance whether they will end up empty after merging.
/// `GtkUIManager` offers two ways to treat empty submenus:
/// 
/// - make them disappear by hiding the menu item they’re attached to
/// 
/// - add an insensitive “Empty” item
/// 
/// The behaviour is chosen based on the “hide_if_empty” property of the action
/// to which the submenu is associated.
/// 
/// # GtkUIManager as GtkBuildable # <a name="GtkUIManager-BUILDER-UI"></a>
/// 
/// The GtkUIManager implementation of the GtkBuildable interface accepts
/// GtkActionGroup objects as <child> elements in UI definitions.
/// 
/// A GtkUIManager UI definition as described above can be embedded in
/// an GtkUIManager <object> element in a GtkBuilder UI definition.
/// 
/// The widgets that are constructed by a GtkUIManager can be embedded in
/// other parts of the constructed user interface with the help of the
/// “constructor” attribute. See the example below.
/// 
/// ## An embedded GtkUIManager UI definition
/// 
/// ```
/// <object class="GtkUIManager" id="uiman">
///   <child>
///     <object class="GtkActionGroup" id="actiongroup">
///       <child>
///         <object class="GtkAction" id="file">
///           <property name="label">_File</property>
///         </object>
///       </child>
///     </object>
///   </child>
///   <ui>
///     <menubar name="menubar1">
///       <menu action="file">
///       </menu>
///     </menubar>
///   </ui>
/// </object>
/// <object class="GtkWindow" id="main-window">
///   <child>
///     <object class="GtkMenuBar" id="menubar1" constructor="uiman"/>
///   </child>
/// </object>
/// ```
/// 
public struct UIManagerRef: UIManagerProtocol {
    /// Untyped pointer to the underlying `GtkUIManager` instance.
    /// For type-safe access, use the generated, typed pointer `ui_manager_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer
}

public extension UIManagerRef {
    /// Designated initialiser from the underlying `C` data type
    init(_ p: UnsafeMutablePointer<GtkUIManager>) {
        ptr = UnsafeMutableRawPointer(p)    }

    /// Reference intialiser for a related type that implements `UIManagerProtocol`
    init<T: UIManagerProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `UIManagerProtocol`.**
    init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `UIManagerProtocol`.**
    init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `UIManagerProtocol`.**
    init(raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `UIManagerProtocol`.**
    init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `UIManagerProtocol`.**
    init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new ui manager object.
    ///
    /// **new is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) init() {
        let rv = gtk_ui_manager_new()
        self.init(cast(rv))
    }
}

/// The `UIManager` type acts as a reference-counted owner of an underlying `GtkUIManager` instance.
/// It provides the methods that can operate on this data type through `UIManagerProtocol` conformance.
/// Use `UIManager` as a strong reference or owner of a `GtkUIManager` instance.
///
/// > GtkUIManager is deprecated since GTK+ 3.10. To construct user interfaces
/// > from XML definitions, you should use `GtkBuilder`, `GMenuModel`, et al. To
/// > work with actions, use `GAction`, `GtkActionable` et al. These newer classes
/// > support richer functionality and integration with various desktop shells.
/// > It should be possible to migrate most/all functionality from GtkUIManager.
/// 
/// A `GtkUIManager` constructs a user interface (menus and toolbars) from
/// one or more UI definitions, which reference actions from one or more
/// action groups.
/// 
/// # UI Definitions # <a name="XML-UI"></a>
/// 
/// The UI definitions are specified in an XML format which can be
/// roughly described by the following DTD.
/// 
/// > Do not confuse the GtkUIManager UI Definitions described here with
/// > the similarly named [GtkBuilder UI Definitions](#BUILDER-UI).
/// 
/// ```
/// <!ELEMENT menubar     (menuitem|separator|placeholder|menu)* >
/// <!ELEMENT menu        (menuitem|separator|placeholder|menu)* >
/// <!ELEMENT popup       (menuitem|separator|placeholder|menu)* >
/// <!ELEMENT toolbar     (toolitem|separator|placeholder)* >
/// <!ELEMENT placeholder (menuitem|toolitem|separator|placeholder|menu)* >
/// <!ELEMENT menuitem     EMPTY >
/// <!ELEMENT toolitem     (menu?) >
/// <!ELEMENT separator    EMPTY >
/// <!ELEMENT accelerator  EMPTY >
/// <!ATTLIST menubar      name                      #IMPLIED
///                        action                    #IMPLIED >
/// <!ATTLIST toolbar      name                      #IMPLIED
///                        action                    #IMPLIED >
/// <!ATTLIST popup        name                      #IMPLIED
///                        action                    #IMPLIED
///                        accelerators (true|false) #IMPLIED >
/// <!ATTLIST placeholder  name                      #IMPLIED
///                        action                    #IMPLIED >
/// <!ATTLIST separator    name                      #IMPLIED
///                        action                    #IMPLIED
///                        expand       (true|false) #IMPLIED >
/// <!ATTLIST menu         name                      #IMPLIED
///                        action                    #REQUIRED
///                        position     (top|bot)    #IMPLIED >
/// <!ATTLIST menuitem     name                      #IMPLIED
///                        action                    #REQUIRED
///                        position     (top|bot)    #IMPLIED
///                        always-show-image (true|false) #IMPLIED >
/// <!ATTLIST toolitem     name                      #IMPLIED
///                        action                    #REQUIRED
///                        position     (top|bot)    #IMPLIED >
/// <!ATTLIST accelerator  name                      #IMPLIED
///                        action                    #REQUIRED >
/// ```
/// 
/// There are some additional restrictions beyond those specified in the
/// DTD, e.g. every toolitem must have a toolbar in its anchestry and
/// every menuitem must have a menubar or popup in its anchestry. Since
/// a `GMarkupParser` is used to parse the UI description, it must not only
/// be valid XML, but valid markup.
/// 
/// If a name is not specified, it defaults to the action. If an action is
/// not specified either, the element name is used. The name and action
/// attributes must not contain “/” characters after parsing (since that
/// would mess up path lookup) and must be usable as XML attributes when
/// enclosed in doublequotes, thus they must not “"” characters or references
/// to the &quot; entity.
/// 
/// # A UI definition #
/// 
/// ```
/// <ui>
///   <menubar>
///     <menu name="FileMenu" action="FileMenuAction">
///       <menuitem name="New" action="New2Action" />
///       <placeholder name="FileMenuAdditions" />
///     </menu>
///     <menu name="JustifyMenu" action="JustifyMenuAction">
///       <menuitem name="Left" action="justify-left"/>
///       <menuitem name="Centre" action="justify-center"/>
///       <menuitem name="Right" action="justify-right"/>
///       <menuitem name="Fill" action="justify-fill"/>
///     </menu>
///   </menubar>
///   <toolbar action="toolbar1">
///     <placeholder name="JustifyToolItems">
///       <separator/>
///       <toolitem name="Left" action="justify-left"/>
///       <toolitem name="Centre" action="justify-center"/>
///       <toolitem name="Right" action="justify-right"/>
///       <toolitem name="Fill" action="justify-fill"/>
///       <separator/>
///     </placeholder>
///   </toolbar>
/// </ui>
/// ```
/// 
/// The constructed widget hierarchy is very similar to the element tree
/// of the XML, with the exception that placeholders are merged into their
/// parents. The correspondence of XML elements to widgets should be
/// almost obvious:
/// 
/// - menubar
/// 
///    a `GtkMenuBar`
/// 
/// - toolbar
/// 
///    a `GtkToolbar`
/// 
/// - popup
/// 
///    a toplevel `GtkMenu`
/// 
/// - menu
/// 
///    a `GtkMenu` attached to a menuitem
/// 
/// - menuitem
/// 
///    a `GtkMenuItem` subclass, the exact type depends on the action
/// 
/// - toolitem
/// 
///    a `GtkToolItem` subclass, the exact type depends on the
///    action. Note that toolitem elements may contain a menu element,
///    but only if their associated action specifies a
///    `GtkMenuToolButton` as proxy.
/// 
/// - separator
/// 
///    a `GtkSeparatorMenuItem` or `GtkSeparatorToolItem`
/// 
/// - accelerator
/// 
///    a keyboard accelerator
/// 
/// The “position” attribute determines where a constructed widget is positioned
/// wrt. to its siblings in the partially constructed tree. If it is
/// “top”, the widget is prepended, otherwise it is appended.
/// 
/// # UI Merging # <a name="UI-Merging"></a>
/// 
/// The most remarkable feature of `GtkUIManager` is that it can overlay a set
/// of menuitems and toolitems over another one, and demerge them later.
/// 
/// Merging is done based on the names of the XML elements. Each element is
/// identified by a path which consists of the names of its anchestors, separated
/// by slashes. For example, the menuitem named “Left” in the example above
/// has the path `/ui/menubar/JustifyMenu/Left` and the
/// toolitem with the same name has path
/// `/ui/toolbar1/JustifyToolItems/Left`.
/// 
/// # Accelerators #
/// 
/// Every action has an accelerator path. Accelerators are installed together
/// with menuitem proxies, but they can also be explicitly added with
/// <accelerator> elements in the UI definition. This makes it possible to
/// have accelerators for actions even if they have no visible proxies.
/// 
/// # Smart Separators # <a name="Smart-Separators"></a>
/// 
/// The separators created by `GtkUIManager` are “smart”, i.e. they do not show up
/// in the UI unless they end up between two visible menu or tool items. Separators
/// which are located at the very beginning or end of the menu or toolbar
/// containing them, or multiple separators next to each other, are hidden. This
/// is a useful feature, since the merging of UI elements from multiple sources
/// can make it hard or impossible to determine in advance whether a separator
/// will end up in such an unfortunate position.
/// 
/// For separators in toolbars, you can set `expand="true"` to
/// turn them from a small, visible separator to an expanding, invisible one.
/// Toolitems following an expanding separator are effectively right-aligned.
/// 
/// # Empty Menus
/// 
/// Submenus pose similar problems to separators inconnection with merging. It is
/// impossible to know in advance whether they will end up empty after merging.
/// `GtkUIManager` offers two ways to treat empty submenus:
/// 
/// - make them disappear by hiding the menu item they’re attached to
/// 
/// - add an insensitive “Empty” item
/// 
/// The behaviour is chosen based on the “hide_if_empty” property of the action
/// to which the submenu is associated.
/// 
/// # GtkUIManager as GtkBuildable # <a name="GtkUIManager-BUILDER-UI"></a>
/// 
/// The GtkUIManager implementation of the GtkBuildable interface accepts
/// GtkActionGroup objects as <child> elements in UI definitions.
/// 
/// A GtkUIManager UI definition as described above can be embedded in
/// an GtkUIManager <object> element in a GtkBuilder UI definition.
/// 
/// The widgets that are constructed by a GtkUIManager can be embedded in
/// other parts of the constructed user interface with the help of the
/// “constructor” attribute. See the example below.
/// 
/// ## An embedded GtkUIManager UI definition
/// 
/// ```
/// <object class="GtkUIManager" id="uiman">
///   <child>
///     <object class="GtkActionGroup" id="actiongroup">
///       <child>
///         <object class="GtkAction" id="file">
///           <property name="label">_File</property>
///         </object>
///       </child>
///     </object>
///   </child>
///   <ui>
///     <menubar name="menubar1">
///       <menu action="file">
///       </menu>
///     </menubar>
///   </ui>
/// </object>
/// <object class="GtkWindow" id="main-window">
///   <child>
///     <object class="GtkMenuBar" id="menubar1" constructor="uiman"/>
///   </child>
/// </object>
/// ```
/// 
open class UIManager: GLibObject.Object, UIManagerProtocol {
    /// Designated initialiser from the underlying `C` data type.
    /// Ownership is transferred to the `UIManager` instance.
    public init(_ op: UnsafeMutablePointer<GtkUIManager>) {
        super.init(cast(op))
    }

    /// Reference convenience intialiser for a related type that implements `UIManagerProtocol`
    /// Will retain `GtkUIManager`.
    public convenience init<T: UIManagerProtocol>(_ other: T) {
        self.init(cast(other.ui_manager_ptr))
        g_object_ref(cast(ui_manager_ptr))
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `UIManagerProtocol`.**
    public convenience init<T>(cPointer: UnsafeMutablePointer<T>) {
        self.init(cPointer.withMemoryRebound(to: GtkUIManager.self, capacity: 1) { $0 })
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `UIManagerProtocol`.**
    public convenience init(raw: UnsafeRawPointer) {
        self.init(UnsafeMutableRawPointer(mutating: raw).assumingMemoryBound(to: GtkUIManager.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `UIManagerProtocol`.**
    public convenience init(raw: UnsafeMutableRawPointer) {
        self.init(raw.assumingMemoryBound(to: GtkUIManager.self))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `UIManagerProtocol`.**
    public convenience init(opaquePointer: OpaquePointer) {
        self.init(UnsafeMutablePointer<GtkUIManager>(opaquePointer))
    }

    /// Creates a new ui manager object.
    ///
    /// **new is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) public convenience init() {
        let rv = gtk_ui_manager_new()
        self.init(cast(rv))
    }


}

public enum UIManagerPropertyName: String, PropertyNameProtocol {
    /// The "add-tearoffs" property controls whether generated menus
    /// have tearoff menu items.
    /// 
    /// Note that this only affects regular menus. Generated popup
    /// menus never have tearoff menu items.
    ///
    /// **add-tearoffs is deprecated:**
    /// Tearoff menus are deprecated and should not
    ///     be used in newly written code.
    case addTearoffs = "add-tearoffs"
    case ui = "ui"
}

public extension UIManagerProtocol {
    /// Bind a `UIManagerPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: UIManagerPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default_, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default_, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(cast(ui_manager_ptr)).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef(cast($0)) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }
}

public enum UIManagerSignalName: String, SignalNameProtocol {
    /// The `actions`-changed signal is emitted whenever the set of actions
    /// changes.
    ///
    /// **actions-changed is deprecated:**
    /// This method is deprecated.
    case actionsChanged = "actions-changed"
    /// The `add`-widget signal is emitted for each generated menubar and toolbar.
    /// It is not emitted for generated popup menus, which can be obtained by
    /// `gtk_ui_manager_get_widget()`.
    ///
    /// **add-widget is deprecated:**
    /// This method is deprecated.
    case addWidget = "add-widget"
    /// The `connect`-proxy signal is emitted after connecting a proxy to
    /// an action in the group.
    /// 
    /// This is intended for simple customizations for which a custom action
    /// class would be too clumsy, e.g. showing tooltips for menuitems in the
    /// statusbar.
    ///
    /// **connect-proxy is deprecated:**
    /// This method is deprecated.
    case connectProxy = "connect-proxy"
    /// The `disconnect`-proxy signal is emitted after disconnecting a proxy
    /// from an action in the group.
    ///
    /// **disconnect-proxy is deprecated:**
    /// This method is deprecated.
    case disconnectProxy = "disconnect-proxy"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `post`-activate signal is emitted just after the `action`
    /// is activated.
    /// 
    /// This is intended for applications to get notification
    /// just after any action is activated.
    ///
    /// **post-activate is deprecated:**
    /// This method is deprecated.
    case postActivate = "post-activate"
    /// The `pre`-activate signal is emitted just before the `action`
    /// is activated.
    /// 
    /// This is intended for applications to get notification
    /// just before any action is activated.
    ///
    /// **pre-activate is deprecated:**
    /// This method is deprecated.
    case preActivate = "pre-activate"
    /// The "add-tearoffs" property controls whether generated menus
    /// have tearoff menu items.
    /// 
    /// Note that this only affects regular menus. Generated popup
    /// menus never have tearoff menu items.
    ///
    /// **add-tearoffs is deprecated:**
    /// Tearoff menus are deprecated and should not
    ///     be used in newly written code.
    case notifyAddTearoffs = "notify::add-tearoffs"
    case notifyUi = "notify::ui"
}

public extension UIManagerProtocol {
    /// Connect a `UIManagerSignalName` signal to a given signal handler.
    /// - Parameter signal: the signal to connect
    /// - Parameter flags: signal connection flags
    /// - Parameter handler: signal handler to use
    /// - Returns: positive handler ID, or a value less than or equal to `0` in case of an error
    @discardableResult func connect(signal kind: UIManagerSignalName, flags f: ConnectFlags = ConnectFlags(0), to handler: @escaping GLibObject.SignalHandler) -> CUnsignedLong {
        func _connect(signal name: UnsafePointer<gchar>, flags: ConnectFlags, data: GLibObject.SignalHandlerClosureHolder, handler: @convention(c) @escaping (gpointer, gpointer) -> Void) -> CUnsignedLong {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(data).toOpaque())
            let callback = unsafeBitCast(handler, to: GLibObject.Callback.self)
            let rv = GLibObject.ObjectRef(cast(ui_manager_ptr)).signalConnectData(detailedSignal: name, cHandler: callback, data: holder, destroyData: {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
                let _ = $1
            }, connectFlags: flags)
            return rv
        }
        let rv = _connect(signal: kind.name, flags: f, data: ClosureHolder(handler)) {
            let ptr = UnsafeRawPointer($1)
            let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            holder.call(())
        }
        return rv
    }
}

public extension UIManagerProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkUIManager` instance.
    var ui_manager_ptr: UnsafeMutablePointer<GtkUIManager> { return ptr.assumingMemoryBound(to: GtkUIManager.self) }

    /// Adds a UI element to the current contents of `manager`.
    /// 
    /// If `type` is `GTK_UI_MANAGER_AUTO`, GTK+ inserts a menuitem, toolitem or
    /// separator if such an element can be inserted at the place determined by
    /// `path`. Otherwise `type` must indicate an element that can be inserted at
    /// the place determined by `path`.
    /// 
    /// If `path` points to a menuitem or toolitem, the new element will be inserted
    /// before or after this item, depending on `top`.
    ///
    /// **add_ui is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func addUi(mergeID merge_id: CUnsignedInt, path: UnsafePointer<gchar>, name: UnsafePointer<gchar>, action: UnsafePointer<gchar>, type: UIManagerItemType, top: Bool) {
        gtk_ui_manager_add_ui(cast(ui_manager_ptr), guint(merge_id), path, name, action, type, gboolean(top ? 1 : 0))
    
    }

    /// Parses a file containing a [UI definition](#XML-UI) and
    /// merges it with the current contents of `manager`.
    ///
    /// **add_ui_from_file is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func addUiFrom(file String_: UnsafePointer<gchar>) throws -> CUnsignedInt {
        var error: Optional<UnsafeMutablePointer<GError>> = nil
        let rv = gtk_ui_manager_add_ui_from_file(cast(ui_manager_ptr), String_, &error)
        if let error = error {
                throw ErrorType(error)
        }
        return CUnsignedInt(rv)
    }

    /// Parses a resource file containing a [UI definition](#XML-UI) and
    /// merges it with the current contents of `manager`.
    ///
    /// **add_ui_from_resource is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func addUiFrom(resource resource_path: UnsafePointer<gchar>) throws -> CUnsignedInt {
        var error: Optional<UnsafeMutablePointer<GError>> = nil
        let rv = gtk_ui_manager_add_ui_from_resource(cast(ui_manager_ptr), resource_path, &error)
        if let error = error {
                throw ErrorType(error)
        }
        return CUnsignedInt(rv)
    }

    /// Parses a string containing a [UI definition](#XML-UI) and merges it with
    /// the current contents of `manager`. An enclosing <ui> element is added if
    /// it is missing.
    ///
    /// **add_ui_from_string is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func addUiFrom(stringBuffer buffer: UnsafePointer<gchar>, length: gssize) throws -> CUnsignedInt {
        var error: Optional<UnsafeMutablePointer<GError>> = nil
        let rv = gtk_ui_manager_add_ui_from_string(cast(ui_manager_ptr), buffer, length, &error)
        if let error = error {
                throw ErrorType(error)
        }
        return CUnsignedInt(rv)
    }

    /// Makes sure that all pending updates to the UI have been completed.
    /// 
    /// This may occasionally be necessary, since `GtkUIManager` updates the
    /// UI in an idle function. A typical example where this function is
    /// useful is to enforce that the menubar and toolbar have been added to
    /// the main window before showing it:
    /// (C Language Example):
    /// ```C
    /// gtk_container_add (GTK_CONTAINER (window), vbox);
    /// g_signal_connect (merge, "add-widget",
    ///                   G_CALLBACK (add_widget), vbox);
    /// gtk_ui_manager_add_ui_from_file (merge, "my-menus");
    /// gtk_ui_manager_add_ui_from_file (merge, "my-toolbars");
    /// gtk_ui_manager_ensure_update (merge);
    /// gtk_widget_show (window);
    /// ```
    /// 
    ///
    /// **ensure_update is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func ensureUpdate() {
        gtk_ui_manager_ensure_update(cast(ui_manager_ptr))
    
    }

    /// Returns the `GtkAccelGroup` associated with `manager`.
    ///
    /// **get_accel_group is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func getAccelGroup() -> UnsafeMutablePointer<GtkAccelGroup>! {
        let rv = gtk_ui_manager_get_accel_group(cast(ui_manager_ptr))
        return cast(rv)
    }

    /// Looks up an action by following a path. See `gtk_ui_manager_get_widget()`
    /// for more information about paths.
    ///
    /// **get_action is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func getAction(path: UnsafePointer<gchar>) -> UnsafeMutablePointer<GtkAction>! {
        let rv = gtk_ui_manager_get_action(cast(ui_manager_ptr), path)
        return cast(rv)
    }

    /// Returns the list of action groups associated with `manager`.
    ///
    /// **get_action_groups is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func getActionGroups() -> UnsafeMutablePointer<GList>! {
        let rv = gtk_ui_manager_get_action_groups(cast(ui_manager_ptr))
        return cast(rv)
    }

    /// Returns whether menus generated by this `GtkUIManager`
    /// will have tearoff menu items.
    ///
    /// **get_add_tearoffs is deprecated:**
    /// Tearoff menus are deprecated and should not
    ///     be used in newly written code.
    @available(*, deprecated) func getAddTearoffs() -> Bool {
        let rv = gtk_ui_manager_get_add_tearoffs(cast(ui_manager_ptr))
        return Bool(rv != 0)
    }

    /// Obtains a list of all toplevel widgets of the requested types.
    ///
    /// **get_toplevels is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func getToplevels(types: UIManagerItemType) -> SListRef! {
        let rv = gtk_ui_manager_get_toplevels(cast(ui_manager_ptr), types)
        return cast(rv.map { SListRef($0) })
    }

    /// Creates a [UI definition](#XML-UI) of the merged UI.
    ///
    /// **get_ui is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func getUi() -> String! {
        let rv = gtk_ui_manager_get_ui(cast(ui_manager_ptr))
        return rv.map { String(cString: UnsafePointer<CChar>($0)) }
    }

    /// Looks up a widget by following a path.
    /// The path consists of the names specified in the XML description of the UI.
    /// separated by “/”. Elements which don’t have a name or action attribute in
    /// the XML (e.g. <popup>) can be addressed by their XML element name
    /// (e.g. "popup"). The root element ("/ui") can be omitted in the path.
    /// 
    /// Note that the widget found by following a path that ends in a <menu>;
    /// element is the menuitem to which the menu is attached, not the menu it
    /// manages.
    /// 
    /// Also note that the widgets constructed by a ui manager are not tied to
    /// the lifecycle of the ui manager. If you add the widgets returned by this
    /// function to some container or explicitly ref them, they will survive the
    /// destruction of the ui manager.
    ///
    /// **get_widget is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func getWidget(path: UnsafePointer<gchar>) -> UnsafeMutablePointer<GtkWidget>! {
        let rv = gtk_ui_manager_get_widget(cast(ui_manager_ptr), path)
        return cast(rv)
    }

    /// Inserts an action group into the list of action groups associated
    /// with `manager`. Actions in earlier groups hide actions with the same
    /// name in later groups.
    /// 
    /// If `pos` is larger than the number of action groups in `manager`, or
    /// negative, `action_group` will be inserted at the end of the internal
    /// list.
    ///
    /// **insert_action_group is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func insert(actionGroup action_group: ActionGroupProtocol, pos: CInt) {
        gtk_ui_manager_insert_action_group(cast(ui_manager_ptr), cast(action_group.ptr), gint(pos))
    
    }

    /// Returns an unused merge id, suitable for use with
    /// `gtk_ui_manager_add_ui()`.
    ///
    /// **new_merge_id is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func newMergeID() -> CUnsignedInt {
        let rv = gtk_ui_manager_new_merge_id(cast(ui_manager_ptr))
        return CUnsignedInt(rv)
    }

    /// Removes an action group from the list of action groups associated
    /// with `manager`.
    ///
    /// **remove_action_group is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func remove(actionGroup action_group: ActionGroupProtocol) {
        gtk_ui_manager_remove_action_group(cast(ui_manager_ptr), cast(action_group.ptr))
    
    }

    /// Unmerges the part of `manager`'s content identified by `merge_id`.
    ///
    /// **remove_ui is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated) func removeUi(mergeID merge_id: CUnsignedInt) {
        gtk_ui_manager_remove_ui(cast(ui_manager_ptr), guint(merge_id))
    
    }

    /// Sets the “add_tearoffs” property, which controls whether menus
    /// generated by this `GtkUIManager` will have tearoff menu items.
    /// 
    /// Note that this only affects regular menus. Generated popup
    /// menus never have tearoff menu items.
    ///
    /// **set_add_tearoffs is deprecated:**
    /// Tearoff menus are deprecated and should not
    ///     be used in newly written code.
    @available(*, deprecated) func set(addTearoffs add_tearoffs: Bool) {
        gtk_ui_manager_set_add_tearoffs(cast(ui_manager_ptr), gboolean(add_tearoffs ? 1 : 0))
    
    }
    /// Returns the `GtkAccelGroup` associated with `manager`.
    ///
    /// **get_accel_group is deprecated:**
    /// This method is deprecated.
    var accelGroup: UnsafeMutablePointer<GtkAccelGroup>! {
        /// Returns the `GtkAccelGroup` associated with `manager`.
        ///
        /// **get_accel_group is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated) get {
            let rv = gtk_ui_manager_get_accel_group(cast(ui_manager_ptr))
            return cast(rv)
        }
    }

    /// Returns the list of action groups associated with `manager`.
    ///
    /// **get_action_groups is deprecated:**
    /// This method is deprecated.
    var actionGroups: UnsafeMutablePointer<GList>! {
        /// Returns the list of action groups associated with `manager`.
        ///
        /// **get_action_groups is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated) get {
            let rv = gtk_ui_manager_get_action_groups(cast(ui_manager_ptr))
            return cast(rv)
        }
    }

    /// Returns whether menus generated by this `GtkUIManager`
    /// will have tearoff menu items.
    ///
    /// **get_add_tearoffs is deprecated:**
    /// Tearoff menus are deprecated and should not
    ///     be used in newly written code.
    var addTearoffs: Bool {
        /// Returns whether menus generated by this `GtkUIManager`
        /// will have tearoff menu items.
        ///
        /// **get_add_tearoffs is deprecated:**
        /// Tearoff menus are deprecated and should not
        ///     be used in newly written code.
        @available(*, deprecated) get {
            let rv = gtk_ui_manager_get_add_tearoffs(cast(ui_manager_ptr))
            return Bool(rv != 0)
        }
        /// Sets the “add_tearoffs” property, which controls whether menus
        /// generated by this `GtkUIManager` will have tearoff menu items.
        /// 
        /// Note that this only affects regular menus. Generated popup
        /// menus never have tearoff menu items.
        ///
        /// **set_add_tearoffs is deprecated:**
        /// Tearoff menus are deprecated and should not
        ///     be used in newly written code.
        @available(*, deprecated) nonmutating set {
            gtk_ui_manager_set_add_tearoffs(cast(ui_manager_ptr), gboolean(newValue ? 1 : 0))
        }
    }

    var ui: String! {
        /// Creates a [UI definition](#XML-UI) of the merged UI.
        ///
        /// **get_ui is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated) get {
            let rv = gtk_ui_manager_get_ui(cast(ui_manager_ptr))
            return rv.map { String(cString: UnsafePointer<CChar>($0)) }
        }
    }
}



